# 基础题-01：顺序查找

## 题目

**问题**：实现顺序查找算法

**要求**：
1. 实现顺序查找函数
2. 查找成功返回索引，失败返回-1
3. 统计查找次数

---

## 输入输出

- **输入**：有序或无序数组，目标值
- **输出**：目标值的索引位置，查找次数

---

## 样例

**输入**：
```
数组：[3, 1, 4, 1, 5, 9, 2, 6]
目标值：5
```

**输出**：
```
找到目标值，索引：4
查找次数：5
```

---

## 思路提示

1. **基本思路**：
   - 从数组第一个元素开始
   - 逐个比较每个元素
   - 找到目标值或遍历完整个数组

2. **优化思路**：
   - 如果数组有序，可以提前终止
   - 使用哨兵可以简化边界判断

---

## 时间与空间复杂度

- **时间复杂度**：
  - 最好情况：O(1)（第一个元素就是目标）
  - 最坏情况：O(n)（最后一个元素或不存在）
  - 平均情况：O(n)

- **空间复杂度**：O(1)

---

## 参考答案（可选）

```java
// 顺序查找
public static int sequentialSearch(int[] arr, int target) {
    int count = 0;  // 查找次数
    for (int i = 0; i < arr.length; i++) {
        count++;
        if (arr[i] == target) {
            System.out.println("查找次数：" + count);
            return i;
        }
    }
    System.out.println("查找次数：" + count);
    return -1;  // 未找到
}

// 带哨兵的顺序查找（优化版）
public static int sequentialSearchWithSentinel(int[] arr, int target) {
    int n = arr.length;
    // 保存最后一个元素
    int last = arr[n - 1];
    // 设置哨兵
    arr[n - 1] = target;
    
    int i = 0;
    while (arr[i] != target) {
        i++;
    }
    
    // 恢复最后一个元素
    arr[n - 1] = last;
    
    // 判断是否找到
    if (i < n - 1 || arr[n - 1] == target) {
        return i;
    }
    return -1;
}
```

---

**难度**：⭐⭐  
**类型**：基础算法



