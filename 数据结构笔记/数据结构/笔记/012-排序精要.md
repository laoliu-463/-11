# 排序精要

> 排序算法核心知识  
> 最后更新：2025年1月

## 📚 相关：[时间复杂度精要](./009-时间复杂度精要.md) | [代码练习](../代码练习/08-排序/) | [思维导图](./数据结构思维导图.md)

---

## 📑 目录

- [一、基本概念](#一基本概念)
  - [1.1 排序的定义](#11-排序的定义)
  - [1.2 排序的分类](#12-排序的分类)
  - [1.3 排序的稳定性](#13-排序的稳定性)
  - [1.4 排序算法的评价指标](#14-排序算法的评价指标)
- [二、插入排序](#二插入排序)
  - [2.1 基本概念](#21-基本概念)
  - [2.2 直接插入排序](#22-直接插入排序)
  - [2.3 折半插入排序](#23-折半插入排序)
  - [2.4 插入排序的优化](#24-插入排序的优化)
- [三、希尔排序](#三希尔排序)
  - [3.1 基本概念](#31-基本概念)
  - [3.2 算法思想](#32-算法思想)
  - [3.3 算法实现](#33-算法实现)
  - [3.4 增量序列](#34-增量序列)
  - [3.5 算法示例](#35-算法示例)
- [四、交换排序](#四交换排序)
  - [4.1 冒泡排序](#41-冒泡排序)
  - [4.2 快速排序](#42-快速排序)
- [五、选择排序](#五选择排序)
  - [5.1 简单选择排序](#51-简单选择排序)
  - [5.2 堆排序](#52-堆排序)
- [六、归并排序](#六归并排序)
- [七、计数排序](#七计数排序)
- [八、插入排序 vs 希尔排序](#八插入排序-vs-希尔排序)
- [九、时间复杂度总结](#九时间复杂度总结)

---

## 一、基本概念

### 1.1 排序的定义

**排序（Sorting）**：将一组数据按照某个关键字的大小，递增或递减地排列起来。

**排序的目的：**
- 提高查找效率（有序表查找更快）
- 便于数据分析和处理
- 满足特定应用需求

**排序的关键字：**
- 可以是单个字段（如年龄、成绩）
- 可以是多个字段（如先按年龄，再按成绩）

---

### 1.2 排序的分类

#### 按存储位置分类

1. **内部排序（Internal Sort）**
   - 数据全部在内存中
   - 排序过程不需要访问外存
   - 适用于数据量较小的情况

2. **外部排序（External Sort）**
   - 数据量太大，无法全部放入内存
   - 需要借助外存（磁盘）进行排序
   - 适用于大数据量的情况

#### 按排序方法分类

1. **插入排序**
   - 直接插入排序
   - 折半插入排序
   - 希尔排序

2. **交换排序**
   - 冒泡排序
   - 快速排序

3. **选择排序**
   - 简单选择排序
   - 堆排序

4. **归并排序**

5. **基数排序**

#### 按时间复杂度分类

| 时间复杂度 | 算法 |
|----------|------|
| O(n²) | 直接插入、冒泡、简单选择 |
| O(n log n) | 快速、堆、归并 |
| O(n^1.3) | 希尔排序 |
| O(d(n+r)) | 基数排序 |

---

### 1.3 排序的稳定性

**稳定排序（Stable Sort）**：如果两个关键字相等的记录，排序后它们的相对位置不变。

**不稳定排序（Unstable Sort）**：排序后相等记录的相对位置可能改变。

**示例：**
```
原始序列：[3, 2, 2*, 1]
          ↑     ↑
          (2和2*表示值相等但不同的记录)

稳定排序结果：[1, 2, 2*, 3]  ✅ 2在2*之前
不稳定排序结果：[1, 2*, 2, 3]  ❌ 2*在2之前
```

**稳定性重要性：**
- 多关键字排序时，稳定性很重要
- 例如：先按年龄排序，再按成绩排序，需要保持年龄相同者的相对顺序

---

### 1.4 排序算法的评价指标

1. **时间复杂度**
   - 最好情况
   - 平均情况
   - 最坏情况

2. **空间复杂度**
   - 原地排序：O(1)
   - 非原地排序：O(n) 或更多

3. **稳定性**
   - 稳定 vs 不稳定

4. **适用场景**
   - 数据规模
   - 数据特征（是否基本有序）
   - 内存限制

---

## 二、插入排序

### 2.1 基本概念

**插入排序（Insertion Sort）**：将待排序的记录按其关键字的大小插入到已排序序列的适当位置，直到全部插入完毕。

**核心思想：**
- 将数组分为两部分：已排序部分和未排序部分
- 每次从未排序部分取出一个元素，插入到已排序部分的正确位置
- 重复直到未排序部分为空

**类比：**
就像整理手中的扑克牌，每次从桌上拿一张牌，插入到手中已排序的牌的正确位置。

---

### 2.2 直接插入排序

**直接插入排序（Straight Insertion Sort）**：最简单的插入排序，逐个元素插入。

#### 算法步骤

1. 假设第一个元素已排序
2. 从第二个元素开始，逐个处理
3. 对于当前元素：
   - 保存当前元素的值
   - 将已排序部分中大于当前元素的元素后移
   - 将当前元素插入到正确位置
4. 重复步骤3，直到所有元素处理完毕

#### 算法实现

```c
#include <stdio.h>
#include <stdlib.h>

// 打印数组
void PrintArray(int arr[], int n) {
    printf("[");
    for (int i = 0; i < n; i++) {
        printf("%d", arr[i]);
        if (i < n - 1) printf(", ");
    }
    printf("]\n");
}

// 直接插入排序（升序）
void InsertionSort(int arr[], int n) {
    // 从第二个元素开始（索引1）
    for (int i = 1; i < n; i++) {
        int key = arr[i];  // 当前要插入的元素
        int j = i - 1;     // 已排序部分的最后一个位置
        
        // 将大于key的元素后移
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        // 插入key到正确位置
        arr[j + 1] = key;
    }
}

// 带详细注释的版本
void InsertionSortDetailed(int arr[], int n) {
    printf("初始数组: ");
    PrintArray(arr, n);
    
    // 外层循环：处理每个未排序的元素
    for (int i = 1; i < n; i++) {
        int key = arr[i];  // 当前要插入的元素
        int j = i - 1;     // 已排序部分的最后一个位置
        
        printf("\n第%d轮：插入元素 %d\n", i, key);
        printf("插入前: ");
        PrintArray(arr, n);
        
        // 内层循环：在已排序部分找到插入位置
        // 将大于key的元素向右移动
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];  // 元素后移
            j--;                  // 继续向左查找
        }
        
        // 插入key到正确位置
        arr[j + 1] = key;
        
        printf("插入后: ");
        PrintArray(arr, n);
    }
}

// 降序版本
void InsertionSortDescending(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        int j = i - 1;
        
        // 将小于key的元素后移（降序）
        while (j >= 0 && arr[j] < key) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = key;
    }
}
```

#### 算法示例

**示例：对数组 [5, 2, 4, 6, 1, 3] 进行排序**

```
初始：[5, 2, 4, 6, 1, 3]
      ↑
      已排序部分（只有5）

第1轮：插入2
  已排序：[5]  未排序：[2, 4, 6, 1, 3]
  2 < 5，5后移：[5, 5, 4, 6, 1, 3]
  插入2：[2, 5, 4, 6, 1, 3]

第2轮：插入4
  已排序：[2, 5]  未排序：[4, 6, 1, 3]
  4 < 5，5后移：[2, 5, 5, 6, 1, 3]
  4 > 2，插入4：[2, 4, 5, 6, 1, 3]

第3轮：插入6
  已排序：[2, 4, 5]  未排序：[6, 1, 3]
  6 > 5，直接插入：[2, 4, 5, 6, 1, 3]

第4轮：插入1
  已排序：[2, 4, 5, 6]  未排序：[1, 3]
  1 < 6，6后移：[2, 4, 5, 6, 6, 3]
  1 < 5，5后移：[2, 4, 5, 5, 6, 3]
  1 < 4，4后移：[2, 4, 4, 5, 6, 3]
  1 < 2，2后移：[2, 2, 4, 5, 6, 3]
  插入1：[1, 2, 4, 5, 6, 3]

第5轮：插入3
  已排序：[1, 2, 4, 5, 6]  未排序：[3]
  3 < 6，6后移：[1, 2, 4, 5, 6, 6]
  3 < 5，5后移：[1, 2, 4, 5, 5, 6]
  3 < 4，4后移：[1, 2, 4, 4, 5, 6]
  3 > 2，插入3：[1, 2, 3, 4, 5, 6]

最终结果：[1, 2, 3, 4, 5, 6]
```

#### 时间复杂度分析

**最好情况：** O(n)
- 数组已经有序
- 每个元素只需要比较一次，不需要移动
- 总比较次数：n-1次

**最坏情况：** O(n²)
- 数组完全逆序
- 每个元素需要比较和移动i次（i为当前位置）
- 总比较次数：1 + 2 + ... + (n-1) = n(n-1)/2 = O(n²)
- 总移动次数：也是O(n²)

**平均情况：** O(n²)
- 平均每个元素需要比较和移动n/2次
- 总时间复杂度：O(n²)

**空间复杂度：** O(1)
- 只需要常数个额外空间（key, j等变量）

**稳定性：** ✅ 稳定
- 相等元素不会交换位置

---

### 2.3 折半插入排序

**折半插入排序（Binary Insertion Sort）**：在直接插入排序的基础上，使用折半查找来找到插入位置。

#### 算法思想

- 查找插入位置时，使用折半查找代替顺序查找
- 减少比较次数，但移动次数不变

#### 算法实现

```c
// 折半插入排序
void BinaryInsertionSort(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        
        // 使用折半查找找到插入位置
        int left = 0;
        int right = i - 1;
        int insertPos = i;  // 默认插入位置
        
        while (left <= right) {
            int mid = (left + right) / 2;
            if (arr[mid] > key) {
                right = mid - 1;
                insertPos = mid;  // 插入位置在mid或之前
            } else {
                left = mid + 1;
                insertPos = mid + 1;  // 插入位置在mid之后
            }
        }
        
        // 将insertPos到i-1的元素后移
        for (int j = i - 1; j >= insertPos; j--) {
            arr[j + 1] = arr[j];
        }
        
        // 插入key
        arr[insertPos] = key;
    }
}

// 更清晰的实现
void BinaryInsertionSortV2(int arr[], int n) {
    for (int i = 1; i < n; i++) {
        int key = arr[i];
        
        // 折半查找插入位置
        int left = 0;
        int right = i - 1;
        
        while (left <= right) {
            int mid = (left + right) / 2;
            if (arr[mid] <= key) {
                left = mid + 1;  // 在右半部分查找
            } else {
                right = mid - 1;  // 在左半部分查找
            }
        }
        
        // left就是插入位置
        // 将left到i-1的元素后移
        for (int j = i - 1; j >= left; j--) {
            arr[j + 1] = arr[j];
        }
        
        // 插入key
        arr[left] = key;
    }
}
```

#### 时间复杂度分析

**比较次数：**
- 折半查找：O(log n)
- n个元素：O(n log n)

**移动次数：**
- 仍然是O(n²)（元素移动次数不变）

**总时间复杂度：** O(n²)
- 虽然比较次数减少到O(n log n)，但移动次数仍然是O(n²)
- 总体时间复杂度仍然是O(n²)

**空间复杂度：** O(1)

**稳定性：** ✅ 稳定

**适用场景：**
- 当比较操作比移动操作耗时更多时，折半插入排序有优势
- 但实际应用中，直接插入排序通常更快（因为移动操作通常很快）

---

### 2.4 插入排序的优化

#### 优化1：减少交换操作

使用临时变量保存待插入元素，减少交换次数：

```c
// 优化前：可能有多余的交换
for (int i = 1; i < n; i++) {
    for (int j = i; j > 0 && arr[j] < arr[j-1]; j--) {
        // swap(arr, j, j-1);  // 多次交换
        int temp = arr[j];
        arr[j] = arr[j-1];
        arr[j-1] = temp;
    }
}

// 优化后：只移动，最后插入
for (int i = 1; i < n; i++) {
    int key = arr[i];
    int j = i - 1;
    while (j >= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];  // 只移动
        j--;
    }
    arr[j + 1] = key;  // 最后插入
}
```

#### 优化2：哨兵技巧

使用哨兵元素，简化边界判断：

```c
void InsertionSortWithSentinel(int arr[], int n) {
    // 假设arr[0]是哨兵，数据从arr[1]开始
    // 或者在调用前将数据整体后移一位
    
    for (int i = 2; i < n; i++) {
        arr[0] = arr[i]; // 设置哨兵
        int j = i - 1;
        
        // 由于有哨兵，j永远不会小于0（arr[0]会终止循环）
        while (arr[j] > arr[0]) {
            arr[j + 1] = arr[j];
            j--;
        }
        
        arr[j + 1] = arr[0];
    }
}
```

---

## 三、希尔排序

### 3.1 基本概念

**希尔排序（Shell Sort）**：是插入排序的一种改进版本，也称为**缩小增量排序**。

**发明者：** Donald Shell（1959年）

**核心思想：**
- 将数组按照一定的增量（gap）分成若干组
- 对每组进行插入排序
- 逐渐减小增量，重复上述过程
- 当增量为1时，整个数组基本有序，最后进行一次插入排序

**为什么有效：**
- 插入排序对基本有序的数组效率很高（O(n)）
- 希尔排序通过分组排序，使数组快速接近有序
- 最后用插入排序完成最终排序

---

### 3.2 算法思想

**步骤：**
1. 选择一个增量序列（gap sequence）
2. 按增量将数组分组
3. 对每组进行插入排序
4. 减小增量，重复步骤2-3
5. 当增量为1时，进行最后一次插入排序

**示例：增量序列 [5, 3, 1]**

```
初始数组：[8, 9, 1, 7, 2, 3, 5, 4, 6, 0]

gap = 5：分成5组
  组1：[8, 3] → [3, 8]
  组2：[9, 5] → [5, 9]
  组3：[1, 4] → [1, 4]
  组4：[7, 6] → [6, 7]
  组5：[2, 0] → [0, 2]
结果：[3, 5, 1, 6, 0, 8, 9, 4, 7, 2]

gap = 3：分成3组
  组1：[3, 6, 9, 2] → [2, 3, 6, 9]
  组2：[5, 0, 4] → [0, 4, 5]
  组3：[1, 8, 7] → [1, 7, 8]
结果：[2, 0, 1, 3, 4, 7, 6, 5, 8, 9]

gap = 1：整个数组进行插入排序
  最终结果：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

---

### 3.3 算法实现

```c
// 希尔排序（使用希尔增量：n/2, n/4, ..., 1）
void ShellSort(int arr[], int n) {
    // 增量序列：n/2, n/4, n/8, ..., 1
    for (int gap = n / 2; gap > 0; gap /= 2) {
        // 对每个分组进行插入排序
        for (int i = gap; i < n; i++) {
            int key = arr[i];
            int j = i;
            
            // 在组内进行插入排序
            while (j >= gap && arr[j - gap] > key) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            
            arr[j] = key;
        }
    }
}

// 带详细注释的版本
void ShellSortDetailed(int arr[], int n) {
    printf("初始数组: ");
    PrintArray(arr, n);
    
    // 增量序列
    for (int gap = n / 2; gap > 0; gap /= 2) {
        printf("\n增量 gap = %d\n", gap);
        
        // 对每个分组进行插入排序
        for (int i = gap; i < n; i++) {
            int key = arr[i];
            int j = i;
            
            printf("  处理元素 arr[%d] = %d\n", i, key);
            
            // 在组内进行插入排序
            while (j >= gap && arr[j - gap] > key) {
                arr[j] = arr[j - gap];
                j -= gap;
                printf("    移动: arr[%d] = arr[%d]\n", j + gap, j);
            }
            
            arr[j] = key;
            printf("    插入: arr[%d] = %d\n", j, key);
            printf("  当前状态: ");
            PrintArray(arr, n);
        }
    }
}

// 使用Knuth增量序列（3h+1）
void ShellSortKnuth(int arr[], int n) {
    // 计算最大增量（Knuth序列：1, 4, 13, 40, 121, ...）
    int h = 1;
    while (h < n / 3) {
        h = 3 * h + 1;  // 1, 4, 13, 40, 121, ...
    }
    
    // 使用Knuth增量序列
    while (h >= 1) {
        for (int i = h; i < n; i++) {
            int key = arr[i];
            int j = i;
            
            while (j >= h && arr[j - h] > key) {
                arr[j] = arr[j - h];
                j -= h;
            }
            
            arr[j] = key;
        }
        
        h = h / 3;  // 减小增量
    }
}

// 使用Sedgewick增量序列（性能更好）
void ShellSortSedgewick(int arr[], int n) {
    // Sedgewick增量序列
    int gaps[] = {1, 5, 19, 41, 109, 209, 505, 929, 2161, 3905, 
                  8929, 16001, 36289, 64769, 146305, 260609};
    int gapsLen = sizeof(gaps) / sizeof(gaps[0]);
    
    // 找到合适的起始增量
    int gapIndex = 0;
    while (gapIndex < gapsLen - 1 && gaps[gapIndex] < n / 3) {
        gapIndex++;
    }
    
    // 使用Sedgewick增量序列
    while (gapIndex >= 0) {
        int gap = gaps[gapIndex];
        // 确保gap不超过n
        if (gap >= n) {
            gapIndex--;
            continue;
        }
        
        for (int i = gap; i < n; i++) {
            int key = arr[i];
            int j = i;
            
            while (j >= gap && arr[j - gap] > key) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            
            arr[j] = key;
        }
        
        gapIndex--;
    }
}
```

---

### 3.4 增量序列

增量序列的选择对希尔排序的性能有很大影响。

#### 1. 希尔增量（Shell's Increment）

**序列：** n/2, n/4, n/8, ..., 1

**特点：**
- 简单易实现
- 最坏情况：O(n²)
- 不是最优的

**代码：**
```c
for (int gap = n / 2; gap > 0; gap /= 2) {
    // ...
}
```

#### 2. Knuth增量序列

**序列：** 1, 4, 13, 40, 121, 364, 1093, ...（3h+1）

**公式：** h = 3h + 1

**特点：**
- 性能优于希尔增量
- 最坏情况：O(n^1.5)

**代码：**
```c
int h = 1;
while (h < n / 3) {
    h = 3 * h + 1;
}
while (h >= 1) {
    // ...
    h = h / 3;
}
```

#### 3. Sedgewick增量序列

**序列：** 1, 5, 19, 41, 109, 209, 505, 929, ...

**特点：**
- 性能最好
- 最坏情况：O(n^1.3)
- 实际应用中推荐使用

---

### 3.5 算法示例

**示例：对数组 [8, 9, 1, 7, 2, 3, 5, 4, 6, 0] 进行希尔排序**

**使用增量序列：[5, 3, 1]**

```
初始：[8, 9, 1, 7, 2, 3, 5, 4, 6, 0]
索引： 0  1  2  3  4  5  6  7  8  9

=== gap = 5 ===
分组：
  组1：索引 0,5 → [8, 3] → [3, 8]
  组2：索引 1,6 → [9, 5] → [5, 9]
  组3：索引 2,7 → [1, 4] → [1, 4]
  组4：索引 3,8 → [7, 6] → [6, 7]
  组5：索引 4,9 → [2, 0] → [0, 2]
结果：[3, 5, 1, 6, 0, 8, 9, 4, 7, 2]

=== gap = 3 ===
分组：
  组1：索引 0,3,6,9 → [3, 6, 9, 2] → [2, 3, 6, 9]
  组2：索引 1,4,7 → [5, 0, 4] → [0, 4, 5]
  组3：索引 2,5,8 → [1, 8, 7] → [1, 7, 8]
结果：[2, 0, 1, 3, 4, 7, 6, 5, 8, 9]

=== gap = 1 ===
对整个数组进行插入排序：
  [2, 0, 1, 3, 4, 7, 6, 5, 8, 9]
  → [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

最终结果：[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

---

### 3.6 时间复杂度分析

**时间复杂度：**
- **最好情况：** O(n log n)（使用好的增量序列）
- **平均情况：** O(n^1.3)（使用Sedgewick增量序列）
- **最坏情况：** O(n²)（使用希尔增量序列）

**空间复杂度：** O(1)
- 只需要常数个额外空间

**稳定性：** ❌ 不稳定
- 分组排序可能改变相等元素的相对位置

**性能特点：**
- 比直接插入排序快得多
- 对于中等规模的数据，性能接近O(n log n)的排序算法
- 增量序列的选择对性能影响很大

---

## 四、交换排序

交换排序的核心思想是通过**交换**元素的位置来达到排序的目的。

### 4.1 冒泡排序

#### 4.1.1 基本概念

**冒泡排序（Bubble Sort）**：通过重复遍历待排序序列，比较相邻元素并交换位置，使较大的元素逐渐"冒泡"到序列的末尾。

**核心思想：**
- 比较相邻的两个元素
- 如果前一个元素大于后一个元素，则交换它们的位置
- 重复这个过程，直到没有需要交换的元素

**类比：**
就像水中的气泡，较大的气泡会逐渐上浮到水面。

---

#### 4.1.2 算法步骤

1. 从第一个元素开始，比较相邻的两个元素
2. 如果前一个元素大于后一个元素，交换它们的位置
3. 继续比较下一对相邻元素，直到序列末尾
4. 此时最大的元素已经"冒泡"到末尾
5. 重复步骤1-4，但不再处理已排序的末尾部分
6. 直到所有元素都排序完成

---

#### 4.1.3 算法实现

```c
// 交换两个元素
void Swap(int arr[], int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

// 冒泡排序（基础版本）
void BubbleSort(int arr[], int n) {
    // 外层循环：控制排序轮数
    for (int i = 0; i < n - 1; i++) {
        // 内层循环：每轮比较相邻元素
        for (int j = 0; j < n - 1 - i; j++) {
            // 如果前一个元素大于后一个元素，交换
            if (arr[j] > arr[j + 1]) {
                Swap(arr, j, j + 1);
            }
        }
    }
}

// 带详细注释的版本
void BubbleSortDetailed(int arr[], int n) {
    printf("初始数组: ");
    PrintArray(arr, n);
    
    for (int i = 0; i < n - 1; i++) {
        printf("\n第%d轮排序:\n", i + 1);
        int swapped = 0;
        
        for (int j = 0; j < n - 1 - i; j++) {
            printf("  比较 arr[%d]=%d 和 arr[%d]=%d", 
                j, arr[j], j + 1, arr[j + 1]);
            
            if (arr[j] > arr[j + 1]) {
                Swap(arr, j, j + 1);
                swapped = 1;
                printf(" → 交换\n");
            } else {
                printf(" → 不交换\n");
            }
        }
        
        printf("  本轮结果: ");
        PrintArray(arr, n);
        
        // 优化：如果本轮没有交换，说明已经有序
        if (!swapped) {
            printf("  数组已有序，提前结束\n");
            break;
        }
    }
}

// 优化版本：提前终止
void BubbleSortOptimized(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int swapped = 0;  // 标记本轮是否有交换
        
        for (int j = 0; j < n - 1 - i; j++) {
            if (arr[j] > arr[j + 1]) {
                Swap(arr, j, j + 1);
                swapped = 1;
            }
        }
        
        // 如果本轮没有交换，说明数组已经有序
        if (!swapped) {
            break;  // 提前结束
        }
    }
}

// 双向冒泡排序（鸡尾酒排序）
void CocktailSort(int arr[], int n) {
    int left = 0;
    int right = n - 1;
    
    while (left < right) {
        // 从左到右冒泡
        for (int i = left; i < right; i++) {
            if (arr[i] > arr[i + 1]) {
                Swap(arr, i, i + 1);
            }
        }
        right--;  // 右边界减1
        
        // 从右到左冒泡
        for (int i = right; i > left; i--) {
            if (arr[i] < arr[i - 1]) {
                Swap(arr, i, i - 1);
            }
        }
        left++;  // 左边界加1
    }
}
```

---

#### 4.1.4 算法示例

**示例：对数组 [5, 2, 8, 1, 9] 进行冒泡排序**

```
初始：[5, 2, 8, 1, 9]

第1轮：
  比较 5 和 2 → 交换：[2, 5, 8, 1, 9]
  比较 5 和 8 → 不交换：[2, 5, 8, 1, 9]
  比较 8 和 1 → 交换：[2, 5, 1, 8, 9]
  比较 8 和 9 → 不交换：[2, 5, 1, 8, 9]
  结果：最大元素9已到末尾

第2轮：
  比较 2 和 5 → 不交换：[2, 5, 1, 8, 9]
  比较 5 和 1 → 交换：[2, 1, 5, 8, 9]
  比较 5 和 8 → 不交换：[2, 1, 5, 8, 9]
  结果：第二大元素8已到正确位置

第3轮：
  比较 2 和 1 → 交换：[1, 2, 5, 8, 9]
  比较 2 和 5 → 不交换：[1, 2, 5, 8, 9]
  结果：第三大元素5已到正确位置

第4轮：
  比较 1 和 2 → 不交换：[1, 2, 5, 8, 9]
  结果：数组已有序

最终结果：[1, 2, 5, 8, 9]
```

---

#### 4.1.5 时间复杂度分析

**最好情况：** O(n)
- 数组已经有序
- 只需要一轮遍历，发现没有交换就结束
- 使用优化版本可以达到O(n)

**最坏情况：** O(n²)
- 数组完全逆序
- 需要n-1轮，每轮需要n-i-1次比较
- 总比较次数：n(n-1)/2 = O(n²)

**平均情况：** O(n²)
- 平均需要n(n-1)/2次比较

**空间复杂度：** O(1)
- 只需要常数个额外空间

**稳定性：** ✅ 稳定
- 相等元素不会交换位置

---

### 4.2 快速排序

#### 4.2.1 基本概念

**快速排序（Quick Sort）**：采用**分治法**（Divide and Conquer）的排序算法，通过选择一个基准元素，将数组分成两部分，一部分小于基准，一部分大于基准，然后递归地对两部分进行排序。

**核心思想：**
- **分治**：将问题分解为更小的子问题
- **基准（Pivot）**：选择一个元素作为基准
- **分区（Partition）**：将数组分成两部分
- **递归**：对两部分分别递归排序

**特点：**
- 平均时间复杂度：O(n log n)
- 最坏时间复杂度：O(n²)
- 实际应用中非常快
- 不稳定排序

---

#### 4.2.2 算法思想

**快速排序的步骤：**

1. **选择基准（Pivot）**
   - 从数组中选择一个元素作为基准
   - 常见选择：第一个元素、最后一个元素、中间元素、随机元素

2. **分区（Partition）**
   - 将数组重新排列，使得：
     - 基准左边的元素都小于等于基准
     - 基准右边的元素都大于等于基准
   - 基准元素到达最终位置

3. **递归排序**
   - 递归地对基准左边和右边的子数组进行排序

**分区过程示例：**
```
初始：[5, 2, 8, 1, 9, 3]
选择基准：5（第一个元素）

分区过程：
  左指针i从左边开始，右指针j从右边开始
  找到左边第一个>5的元素：8
  找到右边第一个<5的元素：3
  交换8和3：[5, 2, 3, 1, 9, 8]
  继续：找到左边>5的元素：9
  找到右边<5的元素：1
  交换9和1：[5, 2, 3, 1, 9, 8]
  继续：i和j相遇
  将基准5放到正确位置：[1, 2, 3, 5, 9, 8]

结果：5在正确位置，左边都≤5，右边都≥5
```

---

#### 4.2.3 算法实现

```c
// 分区函数（Lomuto分区方案）
int Partition(int arr[], int left, int right) {
    int pivot = arr[right];  // 选择最后一个元素作为基准
    int i = left - 1;        // 小于基准的区域的边界
    
    for (int j = left; j < right; j++) {
        // 如果当前元素小于等于基准
        if (arr[j] <= pivot) {
            i++;
            Swap(arr, i, j);
        }
    }
    
    // 将基准放到正确位置
    Swap(arr, i + 1, right);
    return i + 1;
}

// 快速排序（递归函数）
void QuickSortRecursive(int arr[], int left, int right) {
    if (left < right) {
        // 分区，获取基准的最终位置
        int pivotIndex = Partition(arr, left, right);
        
        // 递归排序左半部分
        QuickSortRecursive(arr, left, pivotIndex - 1);
        
        // 递归排序右半部分
        QuickSortRecursive(arr, pivotIndex + 1, right);
    }
}

// 快速排序（主函数）
void QuickSort(int arr[], int n) {
    QuickSortRecursive(arr, 0, n - 1);
}

// Hoare分区方案（更高效）
int PartitionHoare(int arr[], int left, int right) {
    int pivot = arr[left];  // 选择第一个元素作为基准
    int i = left - 1;
    int j = right + 1;
    
    while (1) {
        // 从左边找到第一个大于等于基准的元素
        do {
            i++;
        } while (arr[i] < pivot);
        
        // 从右边找到第一个小于等于基准的元素
        do {
            j--;
        } while (arr[j] > pivot);
        
        // 如果两个指针相遇，分区完成
        if (i >= j) {
            return j;
        }
        
        // 交换两个元素
        Swap(arr, i, j);
    }
}

// 使用Hoare分区的快速排序
void QuickSortHoareRecursive(int arr[], int left, int right) {
    if (left < right) {
        int pivotIndex = PartitionHoare(arr, left, right);
        QuickSortHoareRecursive(arr, left, pivotIndex);
        QuickSortHoareRecursive(arr, pivotIndex + 1, right);
    }
}

void QuickSortHoare(int arr[], int n) {
    QuickSortHoareRecursive(arr, 0, n - 1);
}

// 三路快速排序（处理重复元素）
void QuickSort3WayRecursive(int arr[], int left, int right) {
    if (left >= right) return;
    
    int pivot = arr[left];
    int lt = left;      // arr[left+1...lt] < pivot
    int i = left + 1;   // arr[lt+1...i-1] == pivot
    int gt = right + 1; // arr[gt...right] > pivot
    
    while (i < gt) {
        if (arr[i] < pivot) {
            lt++;
            Swap(arr, lt, i);
            i++;
        } else if (arr[i] > pivot) {
            gt--;
            Swap(arr, gt, i);
        } else {
            i++;
        }
    }
    
    Swap(arr, left, lt);
    
    QuickSort3WayRecursive(arr, left, lt - 1);
    QuickSort3WayRecursive(arr, gt, right);
}

void QuickSort3Way(int arr[], int n) {
    QuickSort3WayRecursive(arr, 0, n - 1);
}

// 随机化快速排序（避免最坏情况）
void QuickSortRandomizedRecursive(int arr[], int left, int right) {
    if (left < right) {
        // 随机选择基准
        int randomIndex = left + rand() % (right - left + 1);
        Swap(arr, randomIndex, right);
        
        int pivotIndex = Partition(arr, left, right);
        QuickSortRandomizedRecursive(arr, left, pivotIndex - 1);
        QuickSortRandomizedRecursive(arr, pivotIndex + 1, right);
    }
}

void QuickSortRandomized(int arr[], int n) {
    QuickSortRandomizedRecursive(arr, 0, n - 1);
}
```

---

#### 4.2.4 分区过程详解

**Lomuto分区方案：**

```
初始：[5, 2, 8, 1, 9, 3]
选择基准：3（最后一个元素）
pivot = 3, i = -1

j=0: arr[0]=5 > 3，不移动，i不变
j=1: arr[1]=2 ≤ 3，i++，交换arr[0]和arr[1]
     [2, 5, 8, 1, 9, 3], i=0
j=2: arr[2]=8 > 3，不移动
j=3: arr[3]=1 ≤ 3，i++，交换arr[1]和arr[3]
     [2, 1, 8, 5, 9, 3], i=1
j=4: arr[4]=9 > 3，不移动

最后：交换arr[i+1]和arr[right]
     [2, 1, 3, 5, 9, 8]
     
返回pivotIndex = 2
```

**Hoare分区方案：**

```
初始：[5, 2, 8, 1, 9, 3]
选择基准：5（第一个元素）
pivot = 5, i = -1, j = 6

第1轮：
  i++找到≥5的元素：arr[0]=5
  j--找到≤5的元素：arr[5]=3
  交换：[3, 2, 8, 1, 9, 5]

第2轮：
  i++找到≥5的元素：arr[2]=8
  j--找到≤5的元素：arr[3]=1
  交换：[3, 2, 1, 8, 9, 5]

第3轮：
  i++找到≥5的元素：arr[3]=8
  j--找到≤5的元素：arr[2]=1
  i=3, j=2, i≥j，停止

返回j=2
```

---

#### 4.2.5 算法示例

**示例：对数组 [5, 2, 8, 1, 9, 3] 进行快速排序**

```
初始：[5, 2, 8, 1, 9, 3]

第1次分区（基准=3）：
  [2, 1, 3, 5, 9, 8]
  基准3在位置2

递归左半部分 [2, 1]：
  第2次分区（基准=1）：
    [1, 2]
    基准1在位置0
  左半部分 [1] 已有序
  右半部分 [2] 已有序

递归右半部分 [5, 9, 8]：
  第3次分区（基准=8）：
    [5, 8, 9]
    基准8在位置1
  左半部分 [5] 已有序
  右半部分 [9] 已有序

最终结果：[1, 2, 3, 5, 8, 9]
```

---

#### 4.2.6 时间复杂度分析

**最好情况：** O(n log n)
- 每次分区都能将数组分成大小相等的两部分
- 递归深度：log n
- 每层处理：O(n)
- 总时间复杂度：O(n log n)

**最坏情况：** O(n²)
- 每次分区都只能分成一个元素和其余部分
- 递归深度：n
- 每层处理：O(n)
- 总时间复杂度：O(n²)
- **常见情况**：数组已经有序或完全逆序，且选择第一个/最后一个元素作为基准

**平均情况：** O(n log n)
- 随机数据下，快速排序的平均性能很好
- 实际应用中，快速排序通常比其他O(n log n)算法更快

**空间复杂度：** O(log n) ~ O(n)
- 递归调用栈的深度
- 最好情况：O(log n)
- 最坏情况：O(n)

**稳定性：** ❌ 不稳定
- 分区过程中可能改变相等元素的相对位置

---

#### 4.2.7 优化策略

1. **随机化基准选择**
   - 避免最坏情况
   - 随机选择基准元素

2. **三路快速排序**
   - 处理大量重复元素
   - 将数组分成三部分：< pivot, = pivot, > pivot

3. **小数组使用插入排序**
   - 当子数组长度小于某个阈值（如10）时，使用插入排序
   - 减少递归开销

4. **尾递归优化**
   - 减少递归调用栈的深度

---

## 五、选择排序

选择排序的核心思想是通过**选择**最小（或最大）的元素来达到排序的目的。

### 5.1 简单选择排序

#### 5.1.1 基本概念

**简单选择排序（Simple Selection Sort）**：每次从待排序序列中选择最小（或最大）的元素，放到已排序序列的末尾。

**核心思想：**
- 将数组分为两部分：已排序部分和未排序部分
- 每次从未排序部分选择最小元素
- 将其与未排序部分的第一个元素交换
- 重复直到未排序部分为空

**类比：**
就像从一堆牌中每次选出最小的牌，依次排列。

---

#### 5.1.2 算法步骤

1. 假设第一个元素是最小的
2. 遍历未排序部分，找到真正的最小元素
3. 将最小元素与未排序部分的第一个元素交换
4. 已排序部分增加一个元素
5. 重复步骤2-4，直到所有元素都排序完成

---

#### 5.1.3 算法实现

```c
// 简单选择排序（升序）
void SelectionSort(int arr[], int n) {
    // 外层循环：控制已排序部分的边界
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;  // 假设当前位置是最小元素
        
        // 内层循环：在未排序部分找到最小元素
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;  // 更新最小元素的位置
            }
        }
        
        // 将最小元素与未排序部分的第一个元素交换
        if (minIndex != i) {
            Swap(arr, i, minIndex);
        }
    }
}

// 带详细注释的版本
void SelectionSortDetailed(int arr[], int n) {
    printf("初始数组: ");
    PrintArray(arr, n);
    
    for (int i = 0; i < n - 1; i++) {
        int minIndex = i;
        
        printf("\n第%d轮：在未排序部分 [%d...%d] 中找最小值\n", 
            i + 1, i, n - 1);
        
        // 找到最小元素
        for (int j = i + 1; j < n; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        printf("  找到最小值 arr[%d] = %d\n", minIndex, arr[minIndex]);
        
        // 交换
        if (minIndex != i) {
            Swap(arr, i, minIndex);
            printf("  交换 arr[%d] 和 arr[%d]\n", i, minIndex);
        } else {
            printf("  已在正确位置，无需交换\n");
        }
        
        printf("  当前状态: ");
        PrintArray(arr, n);
    }
}

// 降序版本
void SelectionSortDescending(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        int maxIndex = i;  // 找最大值
        
        for (int j = i + 1; j < n; j++) {
            if (arr[j] > arr[maxIndex]) {
                maxIndex = j;
            }
        }
        
        if (maxIndex != i) {
            Swap(arr, i, maxIndex);
        }
    }
}
```

---

#### 5.1.4 算法示例

**示例：对数组 [5, 2, 8, 1, 9] 进行简单选择排序**

```
初始：[5, 2, 8, 1, 9]
      ↑
      已排序部分（空）

第1轮：在 [5, 2, 8, 1, 9] 中找最小值
  最小值：1（位置3）
  交换 arr[0] 和 arr[3]：[1, 2, 8, 5, 9]
  已排序部分：[1]

第2轮：在 [2, 8, 5, 9] 中找最小值
  最小值：2（位置1）
  已在正确位置，无需交换：[1, 2, 8, 5, 9]
  已排序部分：[1, 2]

第3轮：在 [8, 5, 9] 中找最小值
  最小值：5（位置3）
  交换 arr[2] 和 arr[3]：[1, 2, 5, 8, 9]
  已排序部分：[1, 2, 5]

第4轮：在 [8, 9] 中找最小值
  最小值：8（位置3）
  已在正确位置，无需交换：[1, 2, 5, 8, 9]
  已排序部分：[1, 2, 5, 8]

最终结果：[1, 2, 5, 8, 9]
```

---

#### 5.1.5 时间复杂度分析

**最好情况：** O(n²)
- 即使数组已经有序，仍然需要比较所有元素
- 比较次数：n(n-1)/2

**最坏情况：** O(n²)
- 数组完全逆序
- 比较次数：n(n-1)/2
- 交换次数：n-1

**平均情况：** O(n²)
- 无论数据分布如何，都需要n(n-1)/2次比较

**空间复杂度：** O(1)
- 只需要常数个额外空间

**稳定性：** ❌ 不稳定
- 交换操作可能改变相等元素的相对位置
- 示例：[5, 5*, 2] → [2, 5*, 5]（5和5*的相对位置改变）

---

### 5.2 堆排序

#### 5.2.1 基本概念

**堆排序（Heap Sort）**：利用**堆**这种数据结构设计的排序算法。

**堆（Heap）**：完全二叉树，满足堆性质：
- **大顶堆**：父节点的值大于等于子节点的值
- **小顶堆**：父节点的值小于等于子节点的值

**核心思想：**
1. 将数组构建成堆
2. 每次取出堆顶元素（最大或最小）
3. 调整剩余元素使其仍满足堆性质
4. 重复步骤2-3，直到堆为空

**特点：**
- 时间复杂度：O(n log n)
- 空间复杂度：O(1)
- 不稳定排序
- 适合大规模数据

---

#### 5.2.2 堆的性质

**完全二叉树的性质：**
- 对于索引为i的节点：
  - 左子节点索引：2i + 1
  - 右子节点索引：2i + 2
  - 父节点索引：(i - 1) / 2

**大顶堆示例：**
```
        9
       / \
      7   8
     / \ / \
    3  5 6  4

数组表示：[9, 7, 8, 3, 5, 6, 4]
索引：     0  1  2  3  4  5  6
```

---

#### 5.2.3 算法思想

**堆排序的步骤：**

1. **构建堆（Heapify）**
   - 从最后一个非叶子节点开始
   - 自底向上调整，使每个子树都满足堆性质

2. **排序**
   - 将堆顶元素（最大值）与数组末尾元素交换
   - 堆的大小减1
   - 调整堆，使其重新满足堆性质
   - 重复直到堆为空

**关键操作：**
- **下沉（Sink/Down）**：将节点向下调整，使其满足堆性质
- **上浮（Swim/Up）**：将节点向上调整，使其满足堆性质

---

#### 5.2.4 算法实现

```c
// 调整堆（下沉操作）
// arr: 数组
// n: 堆的大小
// i: 要调整的节点索引
void Heapify(int arr[], int n, int i) {
    int largest = i;        // 假设当前节点最大
    int left = 2 * i + 1;   // 左子节点
    int right = 2 * i + 2;  // 右子节点
    
    // 如果左子节点存在且大于当前节点
    if (left < n && arr[left] > arr[largest]) {
        largest = left;
    }
    
    // 如果右子节点存在且大于当前节点
    if (right < n && arr[right] > arr[largest]) {
        largest = right;
    }
    
    // 如果最大值不是当前节点，需要交换并继续调整
    if (largest != i) {
        Swap(arr, i, largest);
        // 递归调整被交换的子树
        Heapify(arr, n, largest);
    }
}

// 堆排序（升序，使用大顶堆）
void HeapSort(int arr[], int n) {
    // 步骤1：构建大顶堆
    // 从最后一个非叶子节点开始，自底向上调整
    for (int i = n / 2 - 1; i >= 0; i--) {
        Heapify(arr, n, i);
    }
    
    // 步骤2：排序
    // 每次将堆顶元素（最大值）放到数组末尾
    for (int i = n - 1; i > 0; i--) {
        // 交换堆顶和当前末尾元素
        Swap(arr, 0, i);
        
        // 调整堆，使其重新满足堆性质
        Heapify(arr, i, 0);
    }
}

// 非递归版本的heapify
void HeapifyIterative(int arr[], int n, int i) {
    while (1) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;
        
        if (left < n && arr[left] > arr[largest]) {
            largest = left;
        }
        
        if (right < n && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest == i) {
            break;  // 已经满足堆性质
        }
        
        Swap(arr, i, largest);
        i = largest;  // 继续向下调整
    }
}

// 带详细注释的版本
void HeapSortDetailed(int arr[], int n) {
    printf("初始数组: ");
    PrintArray(arr, n);
    
    // 构建堆
    printf("\n=== 构建大顶堆 ===\n");
    for (int i = n / 2 - 1; i >= 0; i--) {
        printf("调整节点 arr[%d] = %d\n", i, arr[i]);
        Heapify(arr, n, i);
        printf("当前状态: ");
        PrintArray(arr, n);
    }
    printf("堆构建完成: ");
    PrintArray(arr, n);
    
    // 排序
    printf("\n=== 排序过程 ===\n");
    for (int i = n - 1; i > 0; i--) {
        printf("\n第%d轮：交换堆顶 arr[0]=%d 和 arr[%d]=%d\n",
            n - i, arr[0], i, arr[i]);
        Swap(arr, 0, i);
        printf("交换后: ");
        PrintArray(arr, n);
        
        printf("调整堆（大小=%d）\n", i);
        Heapify(arr, i, 0);
        printf("调整后: ");
        PrintArray(arr, n);
    }
}
```

---

#### 5.2.5 算法示例

**示例：对数组 [5, 2, 8, 1, 9, 3] 进行堆排序**

```
初始：[5, 2, 8, 1, 9, 3]

=== 构建大顶堆 ===
完全二叉树表示：
        5
       / \
      2   8
     / \ / \
    1  9 3

步骤1：调整节点2（索引2）
  比较：8 > 5，交换
        8
       / \
      2   5
     / \ / \
    1  9 3
  数组：[8, 2, 5, 1, 9, 3]

步骤2：调整节点1（索引1）
  比较：9 > 2，交换
        8
       / \
      9   5
     / \ / \
    1  2 3
  数组：[8, 9, 5, 1, 2, 3]

步骤3：调整节点0（索引0）
  比较：9 > 8，交换
        9
       / \
      8   5
     / \ / \
    1  2 3
  数组：[9, 8, 5, 1, 2, 3]

堆构建完成：[9, 8, 5, 1, 2, 3]

=== 排序过程 ===
第1轮：交换堆顶9和末尾3
  [3, 8, 5, 1, 2, 9]
  调整堆：[8, 3, 5, 1, 2, 9]

第2轮：交换堆顶8和末尾2
  [2, 3, 5, 1, 8, 9]
  调整堆：[5, 3, 2, 1, 8, 9]

第3轮：交换堆顶5和末尾1
  [1, 3, 2, 5, 8, 9]
  调整堆：[3, 1, 2, 5, 8, 9]

第4轮：交换堆顶3和末尾2
  [2, 1, 3, 5, 8, 9]
  调整堆：[2, 1, 3, 5, 8, 9]

第5轮：交换堆顶2和末尾1
  [1, 2, 3, 5, 8, 9]

最终结果：[1, 2, 3, 5, 8, 9]
```

---

#### 5.2.6 时间复杂度分析

**构建堆：** O(n)
- 从最后一个非叶子节点开始调整
- 虽然每个节点调整的时间是O(log n)，但整体是O(n)

**排序过程：** O(n log n)
- 需要n-1次交换
- 每次调整堆的时间是O(log n)
- 总时间：O(n log n)

**总时间复杂度：** O(n log n)
- 最好情况：O(n log n)
- 平均情况：O(n log n)
- 最坏情况：O(n log n)
- **特点**：时间复杂度稳定，不受数据分布影响

**空间复杂度：** O(1)
- 只需要常数个额外空间
- 堆排序是原地排序

**稳定性：** ❌ 不稳定
- 堆调整过程中可能改变相等元素的相对位置

---

#### 5.2.7 堆排序的优势

1. **时间复杂度稳定**
   - 无论数据分布如何，都是O(n log n)

2. **空间复杂度低**
   - O(1)空间复杂度，适合内存受限的场景

3. **适合大规模数据**
   - 性能稳定，不会出现快速排序的最坏情况

4. **适合外部排序**
   - 可以用于外部排序（处理大数据）

---

#### 5.2.8 堆排序 vs 快速排序

| 特性 | 堆排序 | 快速排序 |
|------|--------|---------|
| **时间复杂度（平均）** | O(n log n) | O(n log n) |
| **时间复杂度（最坏）** | O(n log n) | O(n²) |
| **空间复杂度** | O(1) | O(log n) |
| **稳定性** | ❌ 不稳定 | ❌ 不稳定 |
| **性能稳定性** | ✅ 稳定 | ❌ 不稳定（可能退化） |
| **实际性能** | 较慢 | 较快 |
| **适用场景** | 需要稳定性能、内存受限 | 一般情况下的首选 |

---

## 六、归并排序

### 6.1 基本概念

**归并排序（Merge Sort）**：采用**分治法**（Divide and Conquer）的排序算法，将数组分成两半，分别排序，然后合并两个有序数组。

**核心思想：**
- **分治**：将数组分成两半
- **递归**：对两半分别递归排序
- **合并**：将两个有序数组合并成一个有序数组

**特点：**
- 时间复杂度：O(n log n)（稳定）
- 空间复杂度：O(n)
- 稳定排序
- 适合大规模数据，特别是需要稳定排序的场景

---

### 6.2 算法思想

**归并排序的步骤：**

1. **分解（Divide）**
   - 将数组分成两半
   - 递归地对两半进行排序

2. **合并（Merge）**
   - 将两个有序数组合并成一个有序数组
   - 使用双指针技术

**合并过程示例：**
```
左数组：[2, 5, 8]  右数组：[1, 3, 9]
指针：  i=0         指针：  j=0

比较 arr[i]=2 和 arr[j]=1 → 1更小，放入结果，j++
结果：[1]

比较 arr[i]=2 和 arr[j]=3 → 2更小，放入结果，i++
结果：[1, 2]

比较 arr[i]=5 和 arr[j]=3 → 3更小，放入结果，j++
结果：[1, 2, 3]

...继续直到一个数组为空，将另一个数组剩余元素全部加入

最终结果：[1, 2, 3, 5, 8, 9]
```

---

### 6.3 算法实现

```c
// 合并两个有序数组
void Merge(int arr[], int left, int mid, int right) {
    // 计算两个子数组的大小
    int n1 = mid - left + 1;  // 左子数组大小
    int n2 = right - mid;      // 右子数组大小
    
    // 创建临时数组
    int *leftArr = (int *)malloc(n1 * sizeof(int));
    int *rightArr = (int *)malloc(n2 * sizeof(int));
    
    // 复制数据到临时数组
    for (int i = 0; i < n1; i++) {
        leftArr[i] = arr[left + i];
    }
    for (int j = 0; j < n2; j++) {
        rightArr[j] = arr[mid + 1 + j];
    }
    
    // 合并两个有序数组
    int i = 0, j = 0;  // 两个子数组的指针
    int k = left;      // 原数组的指针
    
    while (i < n1 && j < n2) {
        if (leftArr[i] <= rightArr[j]) {
            arr[k++] = leftArr[i++];
        } else {
            arr[k++] = rightArr[j++];
        }
    }
    
    // 复制剩余元素
    while (i < n1) {
        arr[k++] = leftArr[i++];
    }
    while (j < n2) {
        arr[k++] = rightArr[j++];
    }
    
    free(leftArr);
    free(rightArr);
}

// 归并排序（递归函数）
void MergeSortRecursive(int arr[], int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;  // 防止溢出
        
        // 递归排序左半部分
        MergeSortRecursive(arr, left, mid);
        
        // 递归排序右半部分
        MergeSortRecursive(arr, mid + 1, right);
        
        // 合并两个有序数组
        Merge(arr, left, mid, right);
    }
}

// 归并排序（主函数）
void MergeSort(int arr[], int n) {
    if (n <= 1) return;
    MergeSortRecursive(arr, 0, n - 1);
}

// 带详细注释的版本
void MergeSortDetailedRecursive(int arr[], int left, int right, int depth) {
    for (int i = 0; i < depth; i++) printf("  ");
    printf("归并排序 [%d...%d]\n", left, right);
    
    if (left < right) {
        int mid = left + (right - left) / 2;
        
        MergeSortDetailedRecursive(arr, left, mid, depth + 1);
        MergeSortDetailedRecursive(arr, mid + 1, right, depth + 1);
        
        for (int i = 0; i < depth; i++) printf("  ");
        printf("合并 [%d...%d] 和 [%d...%d]\n", left, mid, mid + 1, right);
        Merge(arr, left, mid, right);
        
        for (int i = 0; i < depth; i++) printf("  ");
        printf("结果: ");
        // 打印当前范围的数组
        printf("[");
        for (int i = left; i <= right; i++) {
            printf("%d", arr[i]);
            if (i < right) printf(", ");
        }
        printf("]\n");
    }
}

void MergeSortDetailed(int arr[], int n) {
    if (n <= 1) return;
    MergeSortDetailedRecursive(arr, 0, n - 1, 0);
}

// 非递归版本（自底向上）
void MergeSortIterative(int arr[], int n) {
    // 从大小为1的子数组开始，逐步增大
    for (int size = 1; size < n; size *= 2) {
        // 合并相邻的子数组
        for (int left = 0; left < n - size; left += 2 * size) {
            int mid = left + size - 1;
            int right = left + 2 * size - 1;
            if (right >= n) right = n - 1;
            
            Merge(arr, left, mid, right);
        }
    }
}
```

---

### 6.4 算法示例

**示例：对数组 [5, 2, 8, 1, 9, 3] 进行归并排序**

```
初始：[5, 2, 8, 1, 9, 3]

分解过程：
  [5, 2, 8, 1, 9, 3]
    /              \
[5, 2, 8]      [1, 9, 3]
  /    \         /    \
[5]  [2, 8]   [1]  [9, 3]
     /  \          /  \
   [2]  [8]     [9]  [3]

合并过程：
合并 [2] 和 [8] → [2, 8]
合并 [5] 和 [2, 8] → [2, 5, 8]

合并 [9] 和 [3] → [3, 9]
合并 [1] 和 [3, 9] → [1, 3, 9]

合并 [2, 5, 8] 和 [1, 3, 9]：
  比较 2 和 1 → 1，结果：[1]
  比较 2 和 3 → 2，结果：[1, 2]
  比较 5 和 3 → 3，结果：[1, 2, 3]
  比较 5 和 9 → 5，结果：[1, 2, 3, 5]
  比较 8 和 9 → 8，结果：[1, 2, 3, 5, 8]
  剩余 9，结果：[1, 2, 3, 5, 8, 9]

最终结果：[1, 2, 3, 5, 8, 9]
```

---

### 6.5 时间复杂度分析

**时间复杂度：** O(n log n)
- **分解**：O(log n)层
- **每层合并**：O(n)
- **总时间**：O(n log n)
- **特点**：最好、平均、最坏情况都是O(n log n)

**空间复杂度：** O(n)
- 需要额外的临时数组存储合并结果
- 递归调用栈：O(log n)
- 总空间：O(n)

**稳定性：** ✅ 稳定
- 合并时，相等元素保持原有顺序（使用<=而不是<）

---

### 6.6 归并排序的优势

1. **时间复杂度稳定**
   - 无论数据分布如何，都是O(n log n)

2. **稳定排序**
   - 适合需要稳定排序的场景

3. **适合外部排序**
   - 可以用于外部排序（处理大数据）

4. **适合链表排序**
   - 可以高效地对链表进行排序

---

## 七、计数排序

### 7.1 基本概念

**计数排序（Counting Sort）**：一种**非比较**排序算法，通过统计每个值的出现次数来排序。

**核心思想：**
- 统计每个值出现的次数
- 根据统计结果重建有序数组

**适用条件：**
- 数据范围较小（k较小）
- 数据是整数
- 数据范围已知

**特点：**
- 时间复杂度：O(n + k)
- 空间复杂度：O(k)
- 稳定排序（如果实现正确）
- 非常快，当k较小时

---

### 7.2 算法思想

**计数排序的步骤：**

1. **统计频率**
   - 创建一个计数数组，大小为数据范围
   - 统计每个值出现的次数

2. **计算前缀和**
   - 将计数数组转换为前缀和数组
   - 前缀和表示每个值在排序后数组中的位置范围

3. **重建数组**
   - 从后往前遍历原数组
   - 根据前缀和数组确定每个元素的位置
   - 放入结果数组

**示例：**
```
原数组：[2, 5, 3, 0, 2, 3, 0, 3]
数据范围：[0, 5]

步骤1：统计频率
  计数数组：[2, 0, 2, 3, 0, 1]
  表示：0出现2次，1出现0次，2出现2次，3出现3次，4出现0次，5出现1次

步骤2：计算前缀和
  前缀和：[2, 2, 4, 7, 7, 8]
  表示：0在[0,2)，1在[2,2)，2在[2,4)，3在[4,7)，4在[7,7)，5在[7,8)

步骤3：重建数组（从后往前）
  处理3：位置6，结果[_, _, _, _, _, _, 3, _]
  处理0：位置1，结果[_, 0, _, _, _, _, 3, _]
  处理3：位置5，结果[_, 0, _, _, _, 3, 3, _]
  ...
  最终结果：[0, 0, 2, 2, 3, 3, 3, 5]
```

---

### 7.3 算法实现

```c
// 计数排序（假设数据范围是[0, maxValue]）
void CountingSort(int arr[], int n, int maxValue) {
    // 步骤1：创建计数数组并统计频率
    int *count = (int *)calloc(maxValue + 1, sizeof(int));
    for (int i = 0; i < n; i++) {
        count[arr[i]]++;
    }
    
    // 步骤2：计算前缀和（每个值在结果数组中的起始位置）
    for (int i = 1; i <= maxValue; i++) {
        count[i] += count[i - 1];
    }
    
    // 步骤3：重建数组（从后往前遍历，保证稳定性）
    int *output = (int *)malloc(n * sizeof(int));
    for (int i = n - 1; i >= 0; i--) {
        int num = arr[i];
        output[count[num] - 1] = num;
        count[num]--;  // 减少计数，为下一个相同值留位置
    }
    
    // 步骤4：复制回原数组
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
    
    free(count);
    free(output);
}

// 自动确定数据范围的版本
void CountingSortAuto(int arr[], int n) {
    if (n == 0) return;
    
    // 找到最大值和最小值
    int min = arr[0];
    int max = arr[0];
    for (int i = 0; i < n; i++) {
        if (arr[i] < min) min = arr[i];
        if (arr[i] > max) max = arr[i];
    }
    
    // 数据范围：[min, max]
    int range = max - min + 1;
    
    // 创建计数数组
    int *count = (int *)calloc(range, sizeof(int));
    for (int i = 0; i < n; i++) {
        count[arr[i] - min]++;  // 偏移到[0, range)
    }
    
    // 计算前缀和
    for (int i = 1; i < range; i++) {
        count[i] += count[i - 1];
    }
    
    // 重建数组
    int *output = (int *)malloc(n * sizeof(int));
    for (int i = n - 1; i >= 0; i--) {
        int num = arr[i];
        output[count[num - min] - 1] = num;
        count[num - min]--;
    }
    
    // 复制回原数组
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
    
    free(count);
    free(output);
}

// 带详细注释的版本
void CountingSortDetailed(int arr[], int n, int maxValue) {
    printf("初始数组: ");
    PrintArray(arr, n);
    printf("数据范围: [0, %d]\n", maxValue);
    
    // 步骤1：统计频率
    int *count = (int *)calloc(maxValue + 1, sizeof(int));
    for (int i = 0; i < n; i++) {
        count[arr[i]]++;
    }
    printf("\n步骤1：统计频率\n");
    printf("计数数组: ");
    PrintArray(count, maxValue + 1);
    
    // 步骤2：计算前缀和
    for (int i = 1; i <= maxValue; i++) {
        count[i] += count[i - 1];
    }
    printf("\n步骤2：计算前缀和\n");
    printf("前缀和数组: ");
    PrintArray(count, maxValue + 1);
    
    // 步骤3：重建数组
    int *output = (int *)malloc(n * sizeof(int));
    printf("\n步骤3：重建数组（从后往前）\n");
    for (int i = n - 1; i >= 0; i--) {
        int num = arr[i];
        int pos = count[num] - 1;
        output[pos] = num;
        count[num]--;
        printf("  处理 arr[%d]=%d，放入位置%d，结果: ", i, num, pos);
        PrintArray(output, n);
    }
    
    // 步骤4：复制回原数组
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
    printf("\n最终结果: ");
    PrintArray(arr, n);
    
    free(count);
    free(output);
}
```

---

### 7.4 算法示例

**示例：对数组 [2, 5, 3, 0, 2, 3, 0, 3] 进行计数排序**

```
初始：[2, 5, 3, 0, 2, 3, 0, 3]
数据范围：[0, 5]

步骤1：统计频率
  值：0  1  2  3  4  5
  次数：2  0  2  3  0  1
  计数数组：[2, 0, 2, 3, 0, 1]

步骤2：计算前缀和
  前缀和：[2, 2, 4, 7, 7, 8]
  含义：
    0在位置[0, 2)
    1在位置[2, 2)（不存在）
    2在位置[2, 4)
    3在位置[4, 7)
    4在位置[7, 7)（不存在）
    5在位置[7, 8)

步骤3：重建数组（从后往前）
  处理arr[7]=3：位置6，结果[_, _, _, _, _, _, 3, _]
  处理arr[6]=0：位置1，结果[_, 0, _, _, _, _, 3, _]
  处理arr[5]=3：位置5，结果[_, 0, _, _, _, 3, 3, _]
  处理arr[4]=2：位置3，结果[_, 0, _, 2, _, 3, 3, _]
  处理arr[3]=0：位置0，结果[0, 0, _, 2, _, 3, 3, _]
  处理arr[2]=3：位置4，结果[0, 0, _, 2, 3, 3, 3, _]
  处理arr[1]=5：位置7，结果[0, 0, _, 2, 3, 3, 3, 5]
  处理arr[0]=2：位置2，结果[0, 0, 2, 2, 3, 3, 3, 5]

最终结果：[0, 0, 2, 2, 3, 3, 3, 5]
```

---

### 7.5 时间复杂度分析

**时间复杂度：** O(n + k)
- **统计频率**：O(n)
- **计算前缀和**：O(k)
- **重建数组**：O(n)
- **总时间**：O(n + k)
- **当k = O(n)时**：时间复杂度为O(n)，非常快

**空间复杂度：** O(k)
- 计数数组：O(k)
- 输出数组：O(n)
- **总空间**：O(n + k)

**稳定性：** ✅ 稳定（如果从后往前遍历）
- 从后往前遍历可以保证相等元素的相对顺序

---

### 7.6 计数排序的优势和限制

**优势：**
1. **非常快**
   - 当k较小时，时间复杂度接近O(n)

2. **稳定排序**
   - 可以实现为稳定排序

3. **简单直观**
   - 算法逻辑简单

**限制：**
1. **数据范围限制**
   - 需要知道数据的范围
   - k不能太大，否则空间开销大

2. **数据类型限制**
   - 只能用于整数排序
   - 不能用于浮点数或字符串

3. **空间开销**
   - 需要额外的O(k)空间

---

### 7.7 适用场景

1. **数据范围小**
   - 例如：年龄（0-150）、成绩（0-100）

2. **整数排序**
   - 只能用于整数

3. **需要稳定排序**
   - 计数排序可以实现为稳定排序

4. **性能要求高**
   - 当k较小时，比O(n log n)算法快

---

## 八、插入排序 vs 希尔排序

| 特性 | 直接插入排序 | 折半插入排序 | 希尔排序 |
|------|------------|------------|---------|
| **时间复杂度（最好）** | O(n) | O(n log n) | O(n log n) |
| **时间复杂度（平均）** | O(n²) | O(n²) | O(n^1.3) |
| **时间复杂度（最坏）** | O(n²) | O(n²) | O(n²) |
| **空间复杂度** | O(1) | O(1) | O(1) |
| **稳定性** | ✅ 稳定 | ✅ 稳定 | ❌ 不稳定 |
| **适用场景** | 小规模、基本有序 | 比较操作耗时 | 中等规模数据 |
| **实现复杂度** | 简单 | 中等 | 中等 |
| **增量序列** | 无 | 无 | 需要选择 |

**选择建议：**
- **小规模数据（<50）**：直接插入排序
- **基本有序的数据**：直接插入排序（接近O(n)）
- **中等规模数据（50-1000）**：希尔排序
- **大规模数据（>1000）**：快速排序、归并排序、堆排序

---

## 九、时间复杂度总结

### 插入排序类算法对比

| 算法 | 最好情况 | 平均情况 | 最坏情况 | 空间复杂度 | 稳定性 |
|------|---------|---------|---------|----------|--------|
| **直接插入排序** | O(n) | O(n²) | O(n²) | O(1) | ✅ 稳定 |
| **折半插入排序** | O(n log n) | O(n²) | O(n²) | O(1) | ✅ 稳定 |
| **希尔排序** | O(n log n) | O(n^1.3) | O(n²) | O(1) | ❌ 不稳定 |

### 交换排序类算法对比

| 算法 | 最好情况 | 平均情况 | 最坏情况 | 空间复杂度 | 稳定性 |
|------|---------|---------|---------|----------|--------|
| **冒泡排序** | O(n) | O(n²) | O(n²) | O(1) | ✅ 稳定 |
| **快速排序** | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ 不稳定 |

### 选择排序类算法对比

| 算法 | 最好情况 | 平均情况 | 最坏情况 | 空间复杂度 | 稳定性 |
|------|---------|---------|---------|----------|--------|
| **简单选择排序** | O(n²) | O(n²) | O(n²) | O(1) | ❌ 不稳定 |
| **堆排序** | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ 不稳定 |

### 归并排序和计数排序对比

| 算法 | 最好情况 | 平均情况 | 最坏情况 | 空间复杂度 | 稳定性 |
|------|---------|---------|---------|----------|--------|
| **归并排序** | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ 稳定 |
| **计数排序** | O(n + k) | O(n + k) | O(n + k) | O(n + k) | ✅ 稳定 |

### 所有排序算法对比

| 算法 | 最好情况 | 平均情况 | 最坏情况 | 空间复杂度 | 稳定性 | 适用场景 |
|------|---------|---------|---------|----------|--------|---------|
| **直接插入排序** | O(n) | O(n²) | O(n²) | O(1) | ✅ | 小规模、基本有序 |
| **折半插入排序** | O(n log n) | O(n²) | O(n²) | O(1) | ✅ | 比较操作耗时 |
| **希尔排序** | O(n log n) | O(n^1.3) | O(n²) | O(1) | ❌ | 中等规模 |
| **冒泡排序** | O(n) | O(n²) | O(n²) | O(1) | ✅ | 教学、小规模 |
| **快速排序** | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ | 大规模、随机数据 |
| **简单选择排序** | O(n²) | O(n²) | O(n²) | O(1) | ❌ | 教学、小规模 |
| **堆排序** | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ | 大规模、需要O(1)空间 |
| **归并排序** | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ | 大规模、需要稳定 |
| **计数排序** | O(n + k) | O(n + k) | O(n + k) | O(n + k) | ✅ | 数据范围小、整数 |

### 冒泡排序 vs 快速排序

| 特性 | 冒泡排序 | 快速排序 |
|------|---------|---------|
| **时间复杂度（最好）** | O(n) | O(n log n) |
| **时间复杂度（平均）** | O(n²) | O(n log n) |
| **时间复杂度（最坏）** | O(n²) | O(n²) |
| **空间复杂度** | O(1) | O(log n) ~ O(n) |
| **稳定性** | ✅ 稳定 | ❌ 不稳定 |
| **实现复杂度** | 简单 | 中等 |
| **适用场景** | 教学、小规模数据 | 大规模数据、实际应用 |
| **优化潜力** | 有限 | 很大（随机化、三路分区等） |
| **实际性能** | 慢 | 快 |

---

## 总结

```
✅ 插入排序 = 逐个插入 + 已排序部分维护
✅ 直接插入排序：简单直观，适合小规模数据
✅ 折半插入排序：减少比较次数，但移动次数不变
✅ 希尔排序：分组插入 + 增量递减，性能更好

✅ 交换排序 = 通过交换元素位置达到排序目的
✅ 冒泡排序：相邻元素比较交换，简单但效率低
✅ 快速排序：分治法 + 分区，实际应用中最快

✅ 选择排序 = 选择最小（最大）元素达到排序目的
✅ 简单选择排序：每次选择最小元素，时间复杂度O(n²)
✅ 堆排序：利用堆结构，时间复杂度O(n log n)，性能稳定

✅ 归并排序 = 分治法 + 合并有序数组
✅ 归并排序：稳定排序，时间复杂度O(n log n)，适合需要稳定的场景

✅ 计数排序 = 统计频率 + 重建数组
✅ 计数排序：非比较排序，时间复杂度O(n+k)，适合数据范围小的整数

📌 核心特点：
   - 插入排序：稳定、简单、适合基本有序的数据
   - 希尔排序：不稳定、性能好、适合中等规模数据
   - 冒泡排序：稳定、简单、适合教学和小规模数据
   - 快速排序：不稳定、性能优秀、适合大规模数据
   - 简单选择排序：不稳定、时间复杂度O(n²)
   - 堆排序：不稳定、性能稳定、适合大规模数据
   - 归并排序：稳定、性能稳定、适合需要稳定的场景
   - 计数排序：稳定、非常快（当k小时）、适合数据范围小的整数

💡 选择建议：
   - 小规模（<50）→ 直接插入排序或冒泡排序
   - 基本有序 → 直接插入排序（接近O(n)）
   - 中等规模（50-1000）→ 希尔排序
   - 大规模（>1000）→ 快速排序（首选）、归并排序、堆排序
   - 需要稳定排序 → 插入排序、冒泡排序、归并排序、计数排序
   - 需要O(1)空间 → 插入排序、希尔排序、冒泡排序、堆排序、简单选择排序
   - 数据范围小（k=O(n)）→ 计数排序（最快）
   - 需要稳定且性能稳定 → 归并排序
```

---

**精简要点**: 
- **插入排序类**：简单直观，适合小规模和基本有序的数据。希尔排序通过分组和增量递减，显著提升了性能 🔢
- **交换排序类**：冒泡排序简单易懂但效率低；快速排序采用分治法，是实际应用中最快的排序算法之一 ⚡
- **选择排序类**：简单选择排序效率低；堆排序利用堆结构，性能稳定且空间复杂度低 🎯
- **归并排序**：稳定排序的代表，性能稳定，适合需要稳定排序的大规模数据 🔀
- **计数排序**：非比较排序，当数据范围小时性能极佳，时间复杂度可达O(n) 📊

