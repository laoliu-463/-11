# 动态规划精要

> 动态规划（Dynamic Programming）核心知识  
> 最后更新：2025年1月

## 📚 相关：[时间复杂度精要](./009-时间复杂度精要.md) | [图精要](./011-图精要.md) | [思维导图](./数据结构思维导图.md)

---

## 📑 目录

- [一、基本概念](#一基本概念)
- [二、核心思想](#二核心思想)
- [三、适用条件](#三适用条件)
- [四、解题步骤](#四解题步骤)
- [五、经典问题](#五经典问题)
- [六、优化技巧](#六优化技巧)
- [七、与其他算法对比](#七与其他算法对比)
- [八、时间复杂度分析](#八时间复杂度分析)

---

## 一、基本概念

### 1.1 什么是动态规划？

**动态规划（Dynamic Programming, DP）** 是一种通过把原问题分解为相对简单的子问题的方式来解决复杂问题的方法。

**核心特点：**
- **重叠子问题**：子问题会被重复计算
- **最优子结构**：问题的最优解包含子问题的最优解
- **记忆化**：通过存储子问题的解来避免重复计算

### 1.2 为什么叫"动态规划"？

**历史由来：**
- 1950年代，Richard Bellman提出
- "Dynamic"指问题具有重叠子问题的特性
- "Programming"指规划、优化的过程

**通俗理解：**
- **动态**：问题状态会变化，需要逐步求解
- **规划**：通过规划子问题的求解顺序来优化

### 1.3 动态规划 vs 其他方法

| 方法 | 特点 | 适用场景 |
|------|------|---------|
| **暴力递归** | 重复计算子问题 | 简单问题 |
| **记忆化递归** | 存储子问题解 | 有重叠子问题 |
| **动态规划** | 自底向上求解 | 有重叠子问题和最优子结构 |
| **贪心算法** | 局部最优 | 有贪心选择性质 |
| **分治算法** | 子问题独立 | 子问题不重叠 |

---

## 二、核心思想

### 2.1 核心思想

**动态规划的核心思想：**

1. **将问题分解为子问题**
   - 找到问题的子结构
   - 定义状态表示子问题

2. **找到状态转移方程**
   - 描述子问题之间的关系
   - 如何从子问题的解得到原问题的解

3. **自底向上求解**
   - 从最小的子问题开始
   - 逐步求解更大的子问题
   - 直到得到原问题的解

### 2.2 关键要素

**动态规划的四个关键要素：**

1. **状态定义（State）**
   - 用dp[i]或dp[i][j]表示什么
   - 状态的含义要清晰

2. **状态转移方程（Transition）**
   - dp[i] = f(dp[i-1], dp[i-2], ...)
   - 描述状态之间的关系

3. **初始状态（Base Case）**
   - dp[0] = ?
   - dp[1] = ?
   - 最小子问题的解

4. **计算顺序（Order）**
   - 从哪个方向计算
   - 确保计算dp[i]时，所需的状态已经计算好

### 2.3 示例：斐波那契数列

**问题：** 计算第n个斐波那契数

**暴力递归：**
```java
// 时间复杂度：O(2^n)
int fib(int n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}
```

**问题：** 存在大量重复计算
```
fib(5)
├── fib(4)
│   ├── fib(3)
│   │   ├── fib(2) ← 重复计算
│   │   └── fib(1)
│   └── fib(2) ← 重复计算
└── fib(3)
    ├── fib(2) ← 重复计算
    └── fib(1)
```

**动态规划：**
```java
// 时间复杂度：O(n)，空间复杂度：O(n)
int fibDP(int n) {
    if (n <= 1) return n;
    
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

// 空间优化：O(1)
int fibDPOptimized(int n) {
    if (n <= 1) return n;
    
    int prev2 = 0;  // dp[i-2]
    int prev1 = 1;  // dp[i-1]
    
    for (int i = 2; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```

---

## 三、适用条件

### 3.1 两个必要条件

**动态规划适用的两个必要条件：**

1. **最优子结构（Optimal Substructure）**
   - 问题的最优解包含子问题的最优解
   - 可以通过子问题的最优解构造原问题的最优解

2. **重叠子问题（Overlapping Subproblems）**
   - 递归过程中，相同的子问题会被多次计算
   - 通过记忆化可以避免重复计算

### 3.2 判断方法

**如何判断一个问题是否适合用动态规划？**

1. **能否分解为子问题？**
   - 问题可以分解为相似的子问题

2. **子问题是否重叠？**
   - 递归树中有重复的节点

3. **是否有最优子结构？**
   - 子问题的最优解能构成原问题的最优解

**示例：**

**✅ 适合DP：**
- 斐波那契数列（重叠子问题）
- 最长公共子序列（最优子结构 + 重叠子问题）
- 0-1背包问题（最优子结构 + 重叠子问题）

**❌ 不适合DP：**
- 归并排序（子问题不重叠）
- 快速排序（子问题不重叠）
- 二分查找（子问题不重叠）

---

## 四、解题步骤

### 4.1 五步解题法

**动态规划解题的五个步骤：**

1. **确定dp数组及下标的含义**
   - dp[i]表示什么？
   - dp[i][j]表示什么？

2. **确定状态转移方程**
   - dp[i] = ?
   - 如何从已知状态推导出当前状态

3. **确定初始值**
   - dp[0] = ?
   - dp[1] = ?
   - 边界条件

4. **确定遍历顺序**
   - 从前往后？从后往前？
   - 确保计算dp[i]时，所需状态已计算

5. **举例推导dp数组**
   - 手动计算几个例子
   - 验证状态转移方程的正确性

### 4.2 示例：爬楼梯问题

**问题：** 每次可以爬1或2个台阶，爬到第n阶有多少种方法？

**解题步骤：**

**步骤1：确定dp数组及下标的含义**
- dp[i]：爬到第i阶的方法数

**步骤2：确定状态转移方程**
- 要到达第i阶，可以从第i-1阶爬1步，或从第i-2阶爬2步
- dp[i] = dp[i-1] + dp[i-2]

**步骤3：确定初始值**
- dp[0] = 1（起点，1种方法）
- dp[1] = 1（爬1步，1种方法）

**步骤4：确定遍历顺序**
- 从i=2开始，从小到大遍历

**步骤5：举例推导**
```
n=0: dp[0] = 1
n=1: dp[1] = 1
n=2: dp[2] = dp[1] + dp[0] = 1 + 1 = 2
n=3: dp[3] = dp[2] + dp[1] = 2 + 1 = 3
n=4: dp[4] = dp[3] + dp[2] = 3 + 2 = 5
```

**代码实现：**
```java
public int climbStairs(int n) {
    if (n <= 1) return 1;
    
    int[] dp = new int[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

// 空间优化
public int climbStairsOptimized(int n) {
    if (n <= 1) return 1;
    
    int prev2 = 1;  // dp[i-2]
    int prev1 = 1;  // dp[i-1]
    
    for (int i = 2; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    
    return prev1;
}
```

---

## 五、经典问题

### 5.1 最长公共子序列（LCS）

**问题：** 给定两个字符串，求它们的最长公共子序列的长度。

**示例：**
```
text1 = "abcde"
text2 = "ace"
最长公共子序列："ace"，长度为3
```

**解题步骤：**

**步骤1：确定dp数组及下标的含义**
- dp[i][j]：text1[0...i-1]和text2[0...j-1]的最长公共子序列长度

**步骤2：确定状态转移方程**
```java
if (text1[i-1] == text2[j-1]) {
    dp[i][j] = dp[i-1][j-1] + 1;
} else {
    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);
}
```

**步骤3：确定初始值**
- dp[0][j] = 0（空字符串）
- dp[i][0] = 0（空字符串）

**代码实现：**
```java
public int longestCommonSubsequence(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    
    int[][] dp = new int[m + 1][n + 1];
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    
    return dp[m][n];
}

// 空间优化：O(min(m, n))
public int longestCommonSubsequenceOptimized(String text1, String text2) {
    int m = text1.length();
    int n = text2.length();
    
    // 使用较短的字符串长度作为dp数组大小
    if (m < n) {
        return longestCommonSubsequenceOptimized(text2, text1);
    }
    
    int[] dp = new int[n + 1];
    
    for (int i = 1; i <= m; i++) {
        int prev = 0;  // dp[i-1][j-1]
        for (int j = 1; j <= n; j++) {
            int temp = dp[j];  // 保存dp[i-1][j]
            if (text1.charAt(i - 1) == text2.charAt(j - 1)) {
                dp[j] = prev + 1;
            } else {
                dp[j] = Math.max(dp[j], dp[j - 1]);
            }
            prev = temp;
        }
    }
    
    return dp[n];
}
```

### 5.2 0-1背包问题

**问题描述：** 有n个物品，每个物品有重量w[i]和价值v[i]，背包容量为W，每个物品只能选择0次或1次（不能分割），求能装入的最大价值。

**示例：**
```
物品：
  物品1：重量2，价值3
  物品2：重量3，价值4
  物品3：重量4，价值5
  物品4：重量5，价值6

背包容量：8

最优方案：选择物品2和物品4
  重量：3 + 5 = 8
  价值：4 + 6 = 10
```

**问题分析：**

对于每个物品，有两种选择：
1. **不选**：价值不变，容量不变
2. **选**：价值增加v[i]，容量减少w[i]

**解题步骤：**

**步骤1：确定dp数组及下标的含义**
- dp[i][j]：前i个物品，容量为j的背包能装的最大价值
- i：物品编号（1到n）
- j：背包容量（0到W）

**步骤2：确定状态转移方程**

对于第i个物品：
- **不选**：dp[i][j] = dp[i-1][j]
- **选**（如果容量足够）：dp[i][j] = dp[i-1][j-w[i-1]] + v[i-1]

取两者的最大值：
```java
dp[i][j] = Math.max(
    dp[i-1][j],                              // 不选第i个物品
    dp[i-1][j-w[i-1]] + v[i-1]              // 选第i个物品
);
```

**步骤3：确定初始值**
- dp[0][j] = 0（没有物品，价值为0）
- dp[i][0] = 0（容量为0，无法装物品）

**步骤4：确定遍历顺序**
- 外层循环：遍历物品（i从1到n）
- 内层循环：遍历容量（j从1到W）

**步骤5：举例推导dp数组**

```
物品：w=[2,3,4,5], v=[3,4,5,6], W=8

dp数组（行：物品，列：容量）：
       0  1  2  3  4  5  6  7  8
物品0  0  0  0  0  0  0  0  0  0
物品1  0  0  3  3  3  3  3  3  3
物品2  0  0  3  4  4  7  7  7  7
物品3  0  0  3  4  5  7  8  9  9
物品4  0  0  3  4  5  7  8  9 10

最优值：dp[4][8] = 10
```

**代码实现：**

```java
// 基础版本：二维数组
public int knapsack(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    int[][] dp = new int[n + 1][capacity + 1];
    
    // 初始化：dp[0][j] = 0, dp[i][0] = 0（Java数组默认值为0）
    
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= capacity; j++) {
            // 不选第i个物品
            dp[i][j] = dp[i - 1][j];
            
            // 选第i个物品（如果容量足够）
            if (j >= weights[i - 1]) {
                dp[i][j] = Math.max(
                    dp[i][j],
                    dp[i - 1][j - weights[i - 1]] + values[i - 1]
                );
            }
        }
    }
    
    return dp[n][capacity];
}

// 空间优化：一维数组
public int knapsackOptimized(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    int[] dp = new int[capacity + 1];
    
    for (int i = 0; i < n; i++) {
        // 从后往前遍历，避免覆盖未使用的状态
        // 因为dp[j]依赖于dp[j-weights[i]]，需要保证dp[j-weights[i]]是上一轮的值
        for (int j = capacity; j >= weights[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
        }
    }
    
    return dp[capacity];
}

// 回溯找具体方案
public List<Integer> knapsackWithPath(int[] weights, int[] values, int capacity) {
    int n = weights.length;
    int[][] dp = new int[n + 1][capacity + 1];
    
    // 计算dp数组
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= capacity; j++) {
            dp[i][j] = dp[i - 1][j];
            if (j >= weights[i - 1]) {
                dp[i][j] = Math.max(
                    dp[i][j],
                    dp[i - 1][j - weights[i - 1]] + values[i - 1]
                );
            }
        }
    }
    
    // 回溯找方案
    List<Integer> selected = new ArrayList<>();
    int i = n, j = capacity;
    
    while (i > 0 && j > 0) {
        // 如果dp[i][j] == dp[i-1][j]，说明没有选第i个物品
        if (dp[i][j] == dp[i - 1][j]) {
            i--;  // 不选，继续看前i-1个物品
        } else {
            // 选了第i个物品
            selected.add(i - 1);  // 物品编号（0-indexed）
            j -= weights[i - 1];
            i--;
        }
    }
    
    Collections.reverse(selected);  // 反转，得到正序
    return selected;
}

// 完整示例
public class KnapsackExample {
    public static void main(String[] args) {
        int[] weights = {2, 3, 4, 5};
        int[] values = {3, 4, 5, 6};
        int capacity = 8;
        
        // 计算最大价值
        int maxValue = knapsack(weights, values, capacity);
        System.out.println("最大价值: " + maxValue);
        
        // 找具体方案
        List<Integer> selected = knapsackWithPath(weights, values, capacity);
        System.out.println("选择的物品: " + selected);
        System.out.print("物品详情: ");
        for (int idx : selected) {
            System.out.printf("物品%d(重量%d,价值%d) ", 
                idx + 1, weights[idx], values[idx]);
        }
        System.out.println();
    }
}
```

**时间复杂度：** O(n × W)
- n：物品数量
- W：背包容量

**空间复杂度：**
- 基础版本：O(n × W)
- 优化版本：O(W)

**为什么从后往前遍历？**

在一维数组优化中，必须从后往前遍历：

```java
// ❌ 错误：从前往后遍历
for (int j = weights[i]; j <= capacity; j++) {
    dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
    // 问题：dp[j-weights[i]]可能已经被当前物品更新过了
    // 导致一个物品被选多次（违反0-1背包规则）
}

// ✅ 正确：从后往前遍历
for (int j = capacity; j >= weights[i]; j--) {
    dp[j] = Math.max(dp[j], dp[j - weights[i]] + values[i]);
    // dp[j-weights[i]]是上一轮（前i-1个物品）的值
    // 保证每个物品最多选一次
}
```

**示例演示：**

```
物品：w=2, v=3，容量W=5

从前往后遍历（错误）：
j=2: dp[2] = max(0, dp[0]+3) = 3
j=4: dp[4] = max(0, dp[2]+3) = 6  ← 错误！物品被选了2次
j=6: dp[6] = max(0, dp[4]+3) = 9  ← 错误！物品被选了3次

从后往前遍历（正确）：
j=5: dp[5] = max(0, dp[3]+3) = 3
j=4: dp[4] = max(0, dp[2]+3) = 3
j=3: dp[3] = max(0, dp[1]+3) = 3
j=2: dp[2] = max(0, dp[0]+3) = 3
```

**变种问题：**

1. **恰好装满背包**
   - 初始化：dp[0] = 0，其他为-∞
   - 只有dp[j-w[i]] != -∞时才能转移

2. **方案数问题**
   - dp[i][j]：前i个物品，容量为j的方案数
   - 转移：dp[i][j] = dp[i-1][j] + dp[i-1][j-w[i]]

3. **最优方案数**
   - 同时记录最大价值和方案数
   - 如果价值相同，方案数相加

### 5.3 最长递增子序列（LIS）

**问题：** 给定一个数组，求最长递增子序列的长度。

**示例：**
```
nums = [10, 9, 2, 5, 3, 7, 101, 18]
最长递增子序列：[2, 3, 7, 18]，长度为4
```

**解题步骤：**

**步骤1：确定dp数组及下标的含义**
- dp[i]：以nums[i]结尾的最长递增子序列长度

**步骤2：确定状态转移方程**
```java
dp[i] = 1;  // 初始值：至少包含自己
for (int j = 0; j < i; j++) {
    if (nums[j] < nums[i]) {
        dp[i] = Math.max(dp[i], dp[j] + 1);
    }
}
```

**代码实现：**
```java
public int lengthOfLIS(int[] nums) {
    int n = nums.length;
    int[] dp = new int[n];
    Arrays.fill(dp, 1);
    
    int maxLen = 1;
    for (int i = 1; i < n; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[j] < nums[i]) {
                dp[i] = Math.max(dp[i], dp[j] + 1);
            }
        }
        maxLen = Math.max(maxLen, dp[i]);
    }
    
    return maxLen;
}

// 优化：二分查找 O(n log n)
public int lengthOfLISOptimized(int[] nums) {
    List<Integer> tails = new ArrayList<>();
    
    for (int num : nums) {
        int left = 0, right = tails.size();
        
        // 二分查找：找到第一个 >= num 的位置
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (tails.get(mid) < num) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        
        if (left == tails.size()) {
            tails.add(num);
        } else {
            tails.set(left, num);
        }
    }
    
    return tails.size();
}
```

### 5.4 编辑距离

**问题：** 给定两个字符串，求将一个字符串转换为另一个字符串所需的最少操作次数（插入、删除、替换）。

**解题步骤：**

**步骤1：确定dp数组及下标的含义**
- dp[i][j]：word1[0...i-1]转换为word2[0...j-1]的最少操作次数

**步骤2：确定状态转移方程**
```java
if (word1[i-1] == word2[j-1]) {
    dp[i][j] = dp[i-1][j-1];  // 不需要操作
} else {
    dp[i][j] = Math.min(
        dp[i-1][j] + 1,      // 删除word1[i-1]
        dp[i][j-1] + 1,      // 插入word2[j-1]
        dp[i-1][j-1] + 1     // 替换word1[i-1]为word2[j-1]
    );
}
```

**代码实现：**
```java
public int minDistance(String word1, String word2) {
    int m = word1.length();
    int n = word2.length();
    
    int[][] dp = new int[m + 1][n + 1];
    
    // 初始化：空字符串转换
    for (int i = 0; i <= m; i++) {
        dp[i][0] = i;  // 删除i个字符
    }
    for (int j = 0; j <= n; j++) {
        dp[0][j] = j;  // 插入j个字符
    }
    
    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = Math.min(
                    Math.min(dp[i - 1][j], dp[i][j - 1]),
                    dp[i - 1][j - 1]
                ) + 1;
            }
        }
    }
    
    return dp[m][n];
}
```

---

## 六、优化技巧

### 6.1 空间优化

**一维滚动数组：**

当dp[i]只依赖于dp[i-1]或dp[i-2]时，可以用变量代替数组。

**示例：斐波那契数列**
```java
// 优化前：O(n)空间
int[] dp = new int[n + 1];

// 优化后：O(1)空间
int prev2 = 0, prev1 = 1;
```

**二维滚动数组：**

当dp[i][j]只依赖于dp[i-1][...]时，可以用一维数组代替二维数组。

**示例：0-1背包**
```java
// 优化前：O(n*W)空间
int[][] dp = new int[n + 1][capacity + 1];

// 优化后：O(W)空间
int[] dp = new int[capacity + 1];
// 从后往前遍历，避免覆盖未使用的状态
```

### 6.2 状态压缩

**位运算优化：**

当状态可以用位表示时，可以用位运算优化。

**示例：旅行商问题（TSP）**
```java
// 状态：visited[i]表示是否访问过城市i
// 可以用整数mask的二进制位表示
int mask = (1 << n) - 1;  // 所有城市都访问过
```

### 6.3 记忆化搜索

**自顶向下的动态规划：**

```java
Map<String, Integer> memo = new HashMap<>();

int dp(int i, int j) {
    String key = i + "," + j;
    if (memo.containsKey(key)) {
        return memo.get(key);
    }
    
    // 计算dp[i][j]
    int result = ...;
    memo.put(key, result);
    return result;
}
```

---

## 七、与其他算法对比

### 7.1 动态规划 vs 贪心算法

| 特性 | 动态规划 | 贪心算法 |
|------|---------|---------|
| **选择方式** | 考虑所有可能的选择 | 每次选择局部最优 |
| **子问题** | 子问题可能重叠 | 子问题通常独立 |
| **最优性** | 保证全局最优 | 不一定全局最优 |
| **时间复杂度** | 通常较高 | 通常较低 |
| **适用场景** | 有重叠子问题 | 有贪心选择性质 |

**示例：找零问题**

**贪心算法（不一定最优）：**
```java
// 贪心：每次选择最大的硬币
// 对于coins=[1, 3, 4], amount=6
// 贪心：4+1+1=3个硬币
// 最优：3+3=2个硬币
```

**动态规划（保证最优）：**
```java
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, amount + 1);
    dp[0] = 0;
    
    for (int i = 1; i <= amount; i++) {
        for (int coin : coins) {
            if (coin <= i) {
                dp[i] = Math.min(dp[i], dp[i - coin] + 1);
            }
        }
    }
    
    return dp[amount] > amount ? -1 : dp[amount];
}
```

### 7.2 动态规划 vs 分治算法

| 特性 | 动态规划 | 分治算法 |
|------|---------|---------|
| **子问题** | 重叠 | 独立 |
| **求解方式** | 自底向上 | 自顶向下 |
| **存储** | 存储子问题解 | 不存储 |
| **适用场景** | 有重叠子问题 | 子问题独立 |

---

## 八、时间复杂度分析

### 8.1 一般情况

**时间复杂度：**
- **状态数** × **每个状态的转移时间**
- 通常为O(n²)或O(n³)

**空间复杂度：**
- 通常为O(n)或O(n²)
- 可以通过优化降低到O(1)或O(n)

### 8.2 经典问题复杂度

| 问题 | 时间复杂度 | 空间复杂度 | 优化后空间 |
|------|-----------|-----------|----------|
| **斐波那契数列** | O(n) | O(n) | O(1) |
| **爬楼梯** | O(n) | O(n) | O(1) |
| **最长公共子序列** | O(mn) | O(mn) | O(min(m,n)) |
| **0-1背包** | O(nW) | O(nW) | O(W) |
| **最长递增子序列** | O(n²) | O(n) | O(n) |
| **编辑距离** | O(mn) | O(mn) | O(min(m,n)) |

---

## 总结

```
✅ 动态规划 = 重叠子问题 + 最优子结构 + 记忆化
✅ 核心思想：将问题分解为子问题，自底向上求解
✅ 解题步骤：定义状态 → 状态转移 → 初始值 → 遍历顺序

📌 关键要素：
   - 状态定义：dp[i]表示什么
   - 状态转移：如何从子问题得到原问题
   - 初始状态：最小子问题的解
   - 计算顺序：确保依赖关系正确

💡 优化技巧：
   - 空间优化：滚动数组
   - 状态压缩：位运算
   - 记忆化搜索：自顶向下

⚠️ 注意事项：
   - 必须满足最优子结构和重叠子问题
   - 注意边界条件和初始值
   - 验证状态转移方程的正确性
```

---

**精简要点**: 动态规划通过将问题分解为重叠子问题并记忆化求解，是解决最优化问题的重要方法。掌握状态定义、状态转移方程和优化技巧是学习动态规划的关键 🎯✨

