# 字符串匹配精要

> 字符串匹配算法的核心知识  
> 最后更新：2025年1月

## 📚 相关：[查找精要](./013-查找精要.md) | [时间复杂度精要](./009-时间复杂度精要.md) | [思维导图](./数据结构思维导图.md)

---

## 📑 目录

- [一、基本概念](#一基本概念)
  - [1.1 字符串匹配问题](#11-字符串匹配问题)
  - [1.2 基本术语](#12-基本术语)
- [二、朴素匹配算法（BF算法）](#二朴素匹配算法bf算法)
  - [2.1 算法思想](#21-算法思想)
  - [2.2 算法实现](#22-算法实现)
  - [2.3 时间复杂度分析](#23-时间复杂度分析)
- [三、KMP算法](#三kmp算法)
  - [3.1 算法思想](#31-算法思想)
  - [3.2 核心概念：next数组](#32-核心概念next数组)
  - [3.3 next数组的构建](#33-next数组的构建)
  - [3.4 KMP算法实现](#34-kmp算法实现)
  - [3.5 算法示例详解](#35-算法示例详解)
  - [3.6 时间复杂度分析](#36-时间复杂度分析)
  - [3.7 空间复杂度分析](#37-空间复杂度分析)
  - [3.8 优化：nextval数组](#38-优化nextval数组)
- [四、算法对比](#四算法对比)
- [五、应用场景](#五应用场景)
- [六、常见考点](#六常见考点)

---

## 一、基本概念

### 1.1 字符串匹配问题

**字符串匹配（String Matching）**：在一个主串（文本串）中查找一个模式串（子串）是否出现，如果出现，返回出现的位置。

**问题描述：**
- **主串（Text）**：被搜索的字符串，长度为n
- **模式串（Pattern）**：要查找的字符串，长度为m
- **目标**：在主串中找到模式串第一次出现的位置（或所有出现的位置）

**示例：**
```
主串：  "ababcababa"
模式串： "ababa"
结果：  在位置5找到匹配（从0开始计数）
```

### 1.2 基本术语

- **前缀（Prefix）**：字符串的前i个字符组成的子串（i从1到m）
  - 例如："abc"的前缀有："a", "ab", "abc"
- **后缀（Suffix）**：字符串的后i个字符组成的子串（i从1到m）
  - 例如："abc"的后缀有："c", "bc", "abc"
- **最长公共前后缀（Longest Common Prefix-Suffix）**：既是前缀又是后缀的最长子串
  - 例如："ababa"的最长公共前后缀是"aba"（长度为3）
- **部分匹配值（Partial Match Value）**：最长公共前后缀的长度

---

## 二、朴素匹配算法（BF算法）

### 2.1 算法思想

**BF算法（Brute Force，暴力匹配）**：逐个比较主串和模式串的每个字符。

**算法步骤：**
1. 从主串的第一个字符开始，与模式串的第一个字符比较
2. 如果相等，继续比较下一个字符
3. 如果不等，主串指针回退，模式串指针重置，从主串的下一个位置重新开始
4. 重复直到找到匹配或主串遍历完毕

### 2.2 算法实现

```java
public class BruteForce {
    /**
     * BF算法：朴素字符串匹配
     * @param text 主串
     * @param pattern 模式串
     * @return 第一次匹配的位置，未找到返回-1
     */
    public static int bruteForce(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        // 主串最多只需要检查到 n-m 位置
        for (int i = 0; i <= n - m; i++) {
            int j = 0;
            // 逐个字符比较
            while (j < m && text.charAt(i + j) == pattern.charAt(j)) {
                j++;
            }
            // 如果j == m，说明完全匹配
            if (j == m) {
                return i;
            }
        }
        
        return -1;  // 未找到
    }
    
    /**
     * BF算法：查找所有匹配位置
     * @param text 主串
     * @param pattern 模式串
     * @return 所有匹配位置的列表
     */
    public static List<Integer> findAll(String text, String pattern) {
        List<Integer> positions = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        for (int i = 0; i <= n - m; i++) {
            int j = 0;
            while (j < m && text.charAt(i + j) == pattern.charAt(j)) {
                j++;
            }
            if (j == m) {
                positions.add(i);
            }
        }
        
        return positions;
    }
    
    /**
     * 示例
     */
    public static void main(String[] args) {
        String text = "ababcababa";
        String pattern = "ababa";
        
        int pos = bruteForce(text, pattern);
        System.out.println("匹配位置: " + pos);
        
        List<Integer> allPos = findAll(text, "aba");
        System.out.println("所有匹配位置: " + allPos);
    }
}
```

### 2.3 时间复杂度分析

**最坏情况：** O(n × m)
- 主串：`aaaaab`
- 模式串：`aaab`
- 每次都要比较到模式串末尾才发现不匹配

**最好情况：** O(n)
- 第一次比较就找到匹配

**平均情况：** O(n + m)

**空间复杂度：** O(1)

---

## 三、KMP算法

### 3.1 算法思想

**KMP算法（Knuth-Morris-Pratt算法）**：利用已匹配的信息，避免主串指针回退，提高匹配效率。

**核心思想：**
- 当发生不匹配时，利用模式串本身的信息（最长公共前后缀），将模式串向右移动尽可能多的位置
- **主串指针不回退**，只移动模式串指针

**关键观察：**
```
主串：  a b a b c a b a b a
模式串： a b a b a
        ↑ ↑ ↑ ↑ ✗
        0 1 2 3 4

在位置4发生不匹配，但前4个字符"abab"已经匹配。
"abab"的最长公共前后缀是"ab"（长度为2），
所以可以直接将模式串向右移动2位，继续比较：

主串：  a b a b c a b a b a
模式串：     a b a b a
            ↑ ↑
            0 1

从模式串的位置2开始比较（因为前2个字符"ab"已经匹配）
```

### 3.2 核心概念：next数组

**next数组（失效函数）**：next[i]表示模式串的前i个字符（即P[0...i-1]）的最长公共前后缀的长度。

**定义：**
- next[0] = -1（特殊标记，表示模式串第一个字符就不匹配时，主串指针后移）
- next[i] = max{k | 0 ≤ k < i 且 P[0...k-1] = P[i-k...i-1]}
  - 即：P[0...i-1]的最长公共前后缀的长度

**示例：**
```
模式串：a b a b a
索引：  0 1 2 3 4

next[0] = -1（第一个字符，无前缀）
next[1] = 0（"a"无公共前后缀）
next[2] = 1（"ab"的最长公共前后缀是"a"，长度为1）
next[3] = 2（"aba"的最长公共前后缀是"ab"，长度为2）
next[4] = 3（"abab"的最长公共前后缀是"aba"，长度为3）

next数组：[-1, 0, 1, 2, 3]
```

**next数组的含义：**
- 当在位置i发生不匹配时，模式串应该向右移动多少位
- 移动后，模式串的前next[i]个字符已经匹配，可以直接从next[i]位置继续比较

### 3.3 next数组的构建

**构建思路：**
- 利用动态规划的思想
- 已知next[0...i-1]，求next[i]
- 如果P[i-1] == P[next[i-1]]，则next[i] = next[i-1] + 1
- 否则，继续向前查找：k = next[next[i-1]]，重复直到找到或k == -1

**算法步骤：**
1. next[0] = -1
2. 设j = 0（表示已匹配的前缀长度）
3. 对于i从1到m-1：
   - 如果P[i] == P[j]，则next[i+1] = j + 1，j++
   - 否则，j = next[j]，重复直到j == -1或P[i] == P[j]
   - 如果j == -1，则next[i+1] = 0

**代码实现：**

```java
/**
 * 构建next数组
 * @param pattern 模式串
 * @return next数组
 */
public static int[] buildNext(String pattern) {
    int m = pattern.length();
    int[] next = new int[m];
    
    next[0] = -1;  // 第一个字符的特殊标记
    int j = 0;     // 已匹配的前缀长度
    int i = 1;     // 当前处理的字符位置
    
    while (i < m) {
        if (j == -1 || pattern.charAt(i) == pattern.charAt(j)) {
            // 匹配成功，最长公共前后缀长度+1
            i++;
            j++;
            next[i] = j;
        } else {
            // 不匹配，回溯到前一个可能的位置
            j = next[j];
        }
    }
    
    return next;
}
```

**构建过程示例：**

```
模式串：a b a b a
索引：  0 1 2 3 4

初始化：next[0] = -1, j = 0, i = 1

i=1, j=0:
  P[1]='b', P[0]='a', 不匹配
  j = next[0] = -1
  j == -1, 所以 next[1] = 0, j = 0, i = 2

i=2, j=0:
  P[2]='a', P[0]='a', 匹配
  next[2] = 1, j = 1, i = 3

i=3, j=1:
  P[3]='b', P[1]='b', 匹配
  next[3] = 2, j = 2, i = 4

i=4, j=2:
  P[4]='a', P[2]='a', 匹配
  next[4] = 3, j = 3, i = 5（结束）

最终next数组：[-1, 0, 1, 2, 3]
```

### 3.4 KMP算法实现

```java
import java.util.*;

public class KMP {
    /**
     * KMP算法：字符串匹配
     * @param text 主串
     * @param pattern 模式串
     * @return 第一次匹配的位置，未找到返回-1
     */
    public static int kmp(String text, String pattern) {
        int n = text.length();
        int m = pattern.length();
        
        if (m == 0) return 0;  // 空模式串
        if (n < m) return -1;  // 主串长度小于模式串
        
        // 构建next数组
        int[] next = buildNext(pattern);
        
        int i = 0;  // 主串指针
        int j = 0;  // 模式串指针
        
        while (i < n && j < m) {
            if (j == -1 || text.charAt(i) == pattern.charAt(j)) {
                // 匹配成功，继续比较下一个字符
                i++;
                j++;
            } else {
                // 不匹配，利用next数组移动模式串
                j = next[j];
            }
        }
        
        // 如果j == m，说明完全匹配
        if (j == m) {
            return i - m;  // 返回匹配的起始位置
        }
        
        return -1;  // 未找到
    }
    
    /**
     * 构建next数组
     * @param pattern 模式串
     * @return next数组
     */
    private static int[] buildNext(String pattern) {
        int m = pattern.length();
        int[] next = new int[m];
        
        next[0] = -1;
        int j = 0;
        int i = 1;
        
        while (i < m) {
            if (j == -1 || pattern.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
                if (i < m) {
                    next[i] = j;
                }
            } else {
                j = next[j];
            }
        }
        
        return next;
    }
    
    /**
     * KMP算法：查找所有匹配位置
     * @param text 主串
     * @param pattern 模式串
     * @return 所有匹配位置的列表
     */
    public static List<Integer> findAll(String text, String pattern) {
        List<Integer> positions = new ArrayList<>();
        int n = text.length();
        int m = pattern.length();
        
        if (m == 0) {
            for (int i = 0; i <= n; i++) {
                positions.add(i);
            }
            return positions;
        }
        
        if (n < m) return positions;
        
        int[] next = buildNext(pattern);
        int i = 0;
        int j = 0;
        
        while (i < n) {
            if (j == -1 || text.charAt(i) == pattern.charAt(j)) {
                i++;
                j++;
            } else {
                j = next[j];
            }
            
            // 找到匹配
            if (j == m) {
                positions.add(i - m);
                // 继续查找下一个匹配（不重置i，利用next数组）
                // 此时j=m，需要回退到next[m-1]继续匹配
                j = next[m - 1];
            }
        }
        
        return positions;
    }
    
    /**
     * 打印next数组（用于调试）
     */
    public static void printNext(String pattern) {
        int[] next = buildNext(pattern);
        System.out.print("模式串: ");
        for (int i = 0; i < pattern.length(); i++) {
            System.out.print(pattern.charAt(i) + " ");
        }
        System.out.println();
        System.out.print("next:   ");
        for (int i = 0; i < next.length; i++) {
            System.out.print(next[i] + " ");
        }
        System.out.println();
    }
    
    /**
     * 示例
     */
    public static void main(String[] args) {
        String text = "ababcababa";
        String pattern = "ababa";
        
        System.out.println("主串: " + text);
        System.out.println("模式串: " + pattern);
        System.out.println();
        
        printNext(pattern);
        System.out.println();
        
        int pos = kmp(text, pattern);
        System.out.println("匹配位置: " + pos);
        
        List<Integer> allPos = findAll(text, "aba");
        System.out.println("所有匹配位置: " + allPos);
    }
}
```

### 3.5 算法示例详解

**示例：**
```
主串：  a b a b c a b a b a
模式串： a b a b a
```

**步骤1：构建next数组**
```
模式串：a b a b a
next:  [-1, 0, 1, 2, 3]
```

**步骤2：匹配过程**

```
初始状态：
主串：  a b a b c a b a b a
        ↑
        i=0
模式串： a b a b a
        ↑
        j=0

第1步：text[0]='a' == pattern[0]='a'，匹配
主串：  a b a b c a b a b a
          ↑
          i=1
模式串： a b a b a
          ↑
          j=1

第2步：text[1]='b' == pattern[1]='b'，匹配
主串：  a b a b c a b a b a
            ↑
            i=2
模式串： a b a b a
            ↑
            j=2

第3步：text[2]='a' == pattern[2]='a'，匹配
主串：  a b a b c a b a b a
              ↑
              i=3
模式串： a b a b a
              ↑
              j=3

第4步：text[3]='b' == pattern[3]='b'，匹配
主串：  a b a b c a b a b a
                ↑
                i=4
模式串： a b a b a
                ↑
                j=4

第5步：text[4]='c' != pattern[4]='a'，不匹配
       此时j=4，next[4]=3
       模式串向右移动，j = next[4] = 3
       前3个字符"aba"已经匹配，从j=3继续比较

主串：  a b a b c a b a b a
                ↑
                i=4（主串指针不回退）
模式串：     a b a b a
                  ↑
                  j=3

第6步：text[4]='c' != pattern[3]='b'，不匹配
       此时j=3，next[3]=2
       j = next[3] = 2

主串：  a b a b c a b a b a
                ↑
                i=4
模式串：       a b a b a
                    ↑
                    j=2

第7步：text[4]='c' != pattern[2]='a'，不匹配
       此时j=2，next[2]=1
       j = next[2] = 1

主串：  a b a b c a b a b a
                ↑
                i=4
模式串：         a b a b a
                      ↑
                      j=1

第8步：text[4]='c' != pattern[1]='b'，不匹配
       此时j=1，next[1]=0
       j = next[1] = 0

主串：  a b a b c a b a b a
                ↑
                i=4
模式串：           a b a b a
                        ↑
                        j=0

第9步：text[4]='c' != pattern[0]='a'，不匹配
       此时j=0，next[0]=-1
       j = next[0] = -1

第10步：j == -1，特殊处理
        i++，j++（j变为0）
        主串指针后移，模式串从头开始

主串：  a b a b c a b a b a
                  ↑
                  i=5
模式串：           a b a b a
                  ↑
                  j=0

第11步：text[5]='a' == pattern[0]='a'，匹配
        i++, j++

主串：  a b a b c a b a b a
                    ↑
                    i=6
模式串：           a b a b a
                    ↑
                    j=1

第12步：text[6]='b' == pattern[1]='b'，匹配
        i++, j++

主串：  a b a b c a b a b a
                      ↑
                      i=7
模式串：           a b a b a
                      ↑
                      j=2

第13步：text[7]='a' == pattern[2]='a'，匹配
        i++, j++

主串：  a b a b c a b a b a
                        ↑
                        i=8
模式串：           a b a b a
                        ↑
                        j=3

第14步：text[8]='b' == pattern[3]='b'，匹配
        i++, j++

主串：  a b a b c a b a b a
                          ↑
                          i=9
模式串：           a b a b a
                          ↑
                          j=4

第15步：text[9]='a' == pattern[4]='a'，匹配
        i++, j++
        i=10, j=5

此时j == m (5)，完全匹配！
退出循环。

匹配结果：
- 匹配的字符：text[5...9] = "ababa"
- 起始位置：i - m = 10 - 5 = 5
- 返回位置：5

验证：主串位置5-9确实是"ababa"，与模式串完全匹配。
```

### 3.6 时间复杂度分析

**构建next数组：** O(m)
- 虽然有两层循环，但j的回退次数有限
- 总的时间复杂度是O(m)

**匹配过程：** O(n)
- 主串指针i只前进，不回退
- 模式串指针j最多回退m次
- 总的时间复杂度是O(n)

**总时间复杂度：** O(n + m)

**空间复杂度：** O(m)（存储next数组）

### 3.7 空间复杂度分析

- **next数组**：O(m)
- **其他变量**：O(1)
- **总空间复杂度**：O(m)

### 3.8 优化：nextval数组

**问题：**
在某些情况下，next数组还可以进一步优化。

**示例：**
```
模式串：a a a a b
next:  [-1, 0, 1, 2, 3]

当在位置4不匹配时：
- next[4] = 3，移动到位置3
- 但pattern[3] = pattern[4] = 'a'，还是会不匹配
- 需要继续回退到next[3] = 2
- 但pattern[2] = 'a'，还是不匹配
- 需要继续回退...

可以优化：如果pattern[i] == pattern[next[i]]，则nextval[i] = nextval[next[i]]
```

**nextval数组构建：**

```java
/**
 * 构建优化的nextval数组
 * @param pattern 模式串
 * @return nextval数组
 */
public static int[] buildNextval(String pattern) {
    int m = pattern.length();
    int[] nextval = new int[m];
    
    nextval[0] = -1;
    int j = 0;
    int i = 1;
    
    while (i < m) {
        if (j == -1 || pattern.charAt(i) == pattern.charAt(j)) {
            i++;
            j++;
            if (i < m) {
                // 优化：如果pattern[i] == pattern[j]，则nextval[i] = nextval[j]
                if (pattern.charAt(i) == pattern.charAt(j)) {
                    nextval[i] = nextval[j];
                } else {
                    nextval[i] = j;
                }
            }
        } else {
            j = nextval[j];
        }
    }
    
    return nextval;
}
```

**使用nextval的KMP算法：**

```java
public static int kmpOptimized(String text, String pattern) {
    int n = text.length();
    int m = pattern.length();
    
    if (m == 0) return 0;
    if (n < m) return -1;
    
    int[] nextval = buildNextval(pattern);
    int i = 0;
    int j = 0;
    
    while (i < n && j < m) {
        if (j == -1 || text.charAt(i) == pattern.charAt(j)) {
            i++;
            j++;
        } else {
            j = nextval[j];
        }
    }
    
    if (j == m) {
        return i - m;
    }
    
    return -1;
}
```

---

## 四、算法对比

| 算法 | 时间复杂度 | 空间复杂度 | 主串指针回退 | 特点 |
|------|----------|----------|------------|------|
| **BF算法** | O(n × m) | O(1) | ✅ 需要回退 | 简单直观，效率低 |
| **KMP算法** | O(n + m) | O(m) | ❌ 不回退 | 高效，利用已匹配信息 |

**性能对比示例：**
```
主串：  aaaaaaaaaab（10个a + 1个b）
模式串： aaab

BF算法：
- 每次比较到模式串末尾才发现不匹配
- 主串指针需要回退
- 时间复杂度：O(n × m)

KMP算法：
- 利用next数组，快速跳过已匹配的部分
- 主串指针不回退
- 时间复杂度：O(n + m)
```

---

## 五、应用场景

1. **文本编辑器**：查找和替换功能
2. **搜索引擎**：关键词匹配
3. **DNA序列匹配**：生物信息学
4. **代码编辑器**：语法高亮、代码搜索
5. **网络安全**：入侵检测系统中的模式匹配
6. **数据压缩**：LZ77等压缩算法的基础

---

## 六、常见考点

1. **next数组的构建**：
   - 理解next数组的含义
   - 掌握构建next数组的算法
   - 能够手工计算next数组

2. **KMP算法的匹配过程**：
   - 理解主串指针不回退的原理
   - 掌握如何利用next数组移动模式串
   - 能够手工模拟匹配过程

3. **时间复杂度分析**：
   - 为什么是O(n + m)而不是O(n × m)
   - next数组构建的时间复杂度

4. **nextval数组优化**：
   - 理解优化的原理
   - 掌握nextval数组的构建方法

5. **与BF算法的区别**：
   - 时间复杂度对比
   - 主串指针是否回退
   - 适用场景

6. **实际应用**：
   - 字符串匹配问题的识别
   - 选择合适的算法

---

## 七、学习要点总结

✅ **核心思想**：
- 利用已匹配的信息，避免主串指针回退
- 通过next数组快速移动模式串

✅ **关键概念**：
- next数组：最长公共前后缀的长度
- 主串指针不回退：提高效率的关键

✅ **算法步骤**：
1. 构建next数组
2. 利用next数组进行匹配

✅ **时间复杂度**：
- 构建next数组：O(m)
- 匹配过程：O(n)
- 总时间复杂度：O(n + m)

✅ **优化方向**：
- nextval数组：进一步减少不必要的比较

---

## 八、代码参考

完整的KMP算法实现请参考：
- `KMP.java`：基础KMP算法
- `KMPOptimized.java`：使用nextval优化的版本

---

**参考资料：**
- 《算法导论》
- 《数据结构（C语言版）》
- Knuth-Morris-Pratt算法原始论文

