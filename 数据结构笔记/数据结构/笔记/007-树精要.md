# 树精要

> 树形结构的核心知识  
> 最后更新：2025年1月

## 📚 相关：[思维导图](./数据结构思维导图.md) | [代码练习](../代码练习/05-树和二叉树/) | [栈](./005-栈精要.md) | [队列](./006-队列精要.md)

### 📝 代码文件说明
- **[Tree.c](../代码练习/05-树和二叉树/Tree.c)** - 一般树（多叉树）完整实现
- **[BinaryTree.c](../代码练习/05-树和二叉树/BinaryTree.c)** - 二叉树完整实现
- **[TreeToBinaryTree.c](../代码练习/05-树和二叉树/TreeToBinaryTree.c)** - 树与二叉树转换实现
- **[BinarySearchTree.c](../代码练习/05-树和二叉树/BinarySearchTree.c)** - 二叉排序树（BST）完整实现
- **[AVLTree.c](../代码练习/05-树和二叉树/AVLTree.c)** - AVL树（平衡二叉树）完整实现

---

## 📑 目录

### 第一部分：树的基础知识
- [一、树的基本概念](#一树的基本概念)
- [二、基本术语](#二基本术语)
- [三、树的性质](#三树的性质)

### 第二部分：二叉树
- [四、二叉树（Binary Tree）](#四二叉树binary-tree)
- [五、二叉树的性质](#五二叉树的性质)
- [六、特殊二叉树](#六特殊二叉树)

### 第三部分：存储结构
- [七、存储结构](#七存储结构)
  - [7.1 一般树的存储结构](#一般树的存储结构)
  - [7.2 二叉树的存储结构](#二叉树的存储结构)

### 第四部分：遍历
- [八、树的遍历](#八树的遍历)
  - [8.1 一般树的遍历](#一般树的遍历)
  - [8.2 二叉树的遍历](#九二叉树的遍历)

### 第五部分：基本操作
- [九、树的基本操作](#十树的基本操作)
  - [9.1 一般树的基本操作](#一般树的基本操作)
  - [9.2 二叉树的基本操作](#十一二叉树的基本操作)

### 第六部分：应用与扩展
- [十、时间复杂度总结](#十时间复杂度总结)
- [十一、常见考点](#十一常见考点)
- [十二、树与二叉树的转换](#十二树与二叉树的转换)
- [十三、树的应用](#十三树的应用) - 详见[树的应用精要](./008-树的应用精要.md)

### 第七部分：特殊树结构
- [十四、二叉排序树（BST）](#十四二叉排序树bst)
- [十五、AVL树（平衡二叉树）](#十五avl树平衡二叉树)
- [十六、红黑树（Red-Black Tree）](#十六红黑树red-black-tree) - 详见[红黑树精要](./014-红黑树精要.md)
- [十七、B树和B+树](#十七b树和b树) - 详见[B树和B+树精要](./015-B树和B+树精要.md)
- [十八、学习要点总结](#十八学习要点总结)

---

## 一、树的基本概念

### 什么是树？

**通俗理解：** 树就像"家族谱系图"或"公司组织架构图"，是一种**层次结构**的数据结构。它由节点和连接节点的边组成，表示一种"一对多"的关系。

### 树的定义

**树（Tree）** 是n（n≥0）个节点的有限集合，当n=0时称为空树。非空树满足：
1. 有且仅有一个特定的节点称为**根节点**
2. 其余节点可分为m（m≥0）个互不相交的有限集合T₁, T₂, ..., Tₘ，每个集合本身又是一棵树，称为根的**子树**

### 树的结构示意

```
┌─────────────────────────────────────────────────────────┐
│                   树的层次结构                           │
└─────────────────────────────────────────────────────────┘

              A（根节点，第1层）
             /│\
            / │ \
           B  C  D（第2层，A的子节点）
          /│  │
         / │  │
        E  F  G（第3层）
       /│
      H I（第4层）

特点：
- A是根节点，没有父节点
- B、C、D是A的子节点，A是它们的父节点
- E、F是B的子节点，B是它们的父节点
- H、I、F、G是叶子节点，没有子节点
- 层次结构：从上到下分层排列
```

---

## 二、基本术语

### 节点相关术语

1. **节点（Node）**：树中的基本元素，包含数据和指向子节点的指针
2. **根节点（Root）**：没有父节点的节点（树的起点）
3. **叶子节点（Leaf）/终端节点**：没有子节点的节点（度为0的节点）
4. **分支节点/内部节点**：至少有一个子节点的节点（度不为0的节点）
5. **父节点（Parent）**：有子节点的节点
6. **子节点（Child）**：某节点的直接下层节点
7. **兄弟节点（Sibling）**：同一父节点的子节点
8. **祖先节点（Ancestor）**：从根到该节点路径上的所有节点
9. **子孙节点（Descendant）**：以某节点为根的子树中的所有节点

### 树相关术语

1. **度（Degree）**：
   - 节点的度：节点的子树个数（子节点个数）
   - 树的度：树中所有节点度的最大值

2. **层次（Level）**：
   - 根节点为第1层
   - 根的子节点为第2层
   - 依此类推

3. **深度/高度（Depth/Height）**：
   - 树的深度：树中节点的最大层次数
   - 节点的深度：从根到该节点的路径长度

4. **路径（Path）**：从一个节点到另一个节点经过的节点序列

5. **路径长度（Path Length）**：路径上经过的边的数量

6. **森林（Forest）**：m（m≥0）棵互不相交的树的集合

---

## 三、树的性质

### 重要性质

1. **节点数 = 边数 + 1**
   - n个节点的树有n-1条边

2. **度为m的树中，节点总数n与各度节点数的关系**
   - n = n₀ + n₁ + n₂ + ... + nₘ
   - n₀为度为0的节点数（叶子节点）
   - n₁为度为1的节点数
   - n₂为度为2的节点数
   - 以此类推

3. **度为m的树中，边数与节点数的关系**
   - 边数 = 1·n₁ + 2·n₂ + 3·n₃ + ... + m·nₘ
   - 边数 = n - 1

---

## 四、二叉树（Binary Tree）

### 4.1 二叉树的定义

**二叉树** 是一种特殊的树，每个节点**最多有两个子节点**（左子节点和右子节点）。

### 4.2 二叉树的特点

```
二叉树结构：

              A（根节点）
             / \
            /   \
           B     C
          / \   /
         D   E F

特点：
- 每个节点最多有两个子节点
- 左子树和右子树是有序的（左右不能颠倒）
- 即使某个节点只有一个子节点，也要区分是左子节点还是右子节点
```

### 4.3 二叉树 vs 度为2的树

| 特性 | 二叉树 | 度为2的树 |
|------|--------|----------|
| **子节点数** | 最多2个 | 最多2个 |
| **子节点顺序** | 有序（区分左右） | 无序 |
| **空树** | 可以为空 | 至少有一个节点 |
| **某节点只有一个子节点** | 需要区分左右 | 不需要区分 |

---

## 五、二叉树的性质

### 重要性质

1. **性质1：** 第i层最多有 **2^(i-1)** 个节点（i ≥ 1）
   ```
   第1层最多：2^0 = 1个节点
   第2层最多：2^1 = 2个节点
   第3层最多：2^2 = 4个节点
   ```

2. **性质2：** 深度为k的二叉树最多有 **2^k - 1** 个节点（k ≥ 1）
   ```
   深度为1：最多1个节点
   深度为2：最多3个节点
   深度为3：最多7个节点
   ```

3. **性质3（重要）：** 对于任何二叉树，**叶子节点数（n₀）= 度为2的节点数（n₂）+ 1**
   ```
   n₀ = n₂ + 1
   
   证明：
   n = n₀ + n₁ + n₂（节点总数）
   n = n₁ + 2n₂ + 1（从边数角度：边数 = n-1 = n₁ + 2n₂）
   推导得：n₀ = n₂ + 1
   ```

4. **性质4：** 具有n个节点的完全二叉树的深度为 **⌊log₂n⌋ + 1**

5. **性质5：** 对于完全二叉树，如果从上到下、从左到右编号（从1开始），则：
   - 节点i的左子节点编号为 **2i**
   - 节点i的右子节点编号为 **2i + 1**
   - 节点i的父节点编号为 **⌊i/2⌋**（i > 1）

---

## 六、特殊二叉树

### 1. 满二叉树（Full Binary Tree）

**定义：** 深度为k且有2^k - 1个节点的二叉树

```
深度为3的满二叉树：

        A（第1层）
       / \
      /   \
     B     C（第2层）
    / \   / \
   D   E F   G（第3层）

节点总数：2^3 - 1 = 7个节点
特点：
- 每层都是满的
- 所有叶子节点都在最后一层
- 除叶子节点外，每个节点都有两个子节点
```

### 2. 完全二叉树（Complete Binary Tree）

**定义：** 深度为k的二叉树，前k-1层都是满的，第k层的节点都集中在左边

```
完全二叉树示例：

        A
       / \
      B   C
     / \  /
    D  E F

特点：
- 除最后一层外，其他层都是满的
- 最后一层的节点从左到右连续排列
- 适合用数组存储（顺序存储）

非完全二叉树示例：

        A
       / \
      B   C
       \  /
        E F

不是完全二叉树，因为B的右子节点E不是最左边
```

### 3. 二叉搜索树（Binary Search Tree, BST）

**定义：** 对于任意节点，左子树的所有节点值 < 根节点值 < 右子树的所有节点值

```
二叉搜索树示例：

        5
       / \
      3   7
     / \ / \
    1  4 6  9

特点：
- 左子树 < 根 < 右子树（递归定义）
- 中序遍历可以得到有序序列：1 3 4 5 6 7 9
- 查找、插入、删除效率高（平均O(log n)）
```

### 4. 平衡二叉树（Balanced Binary Tree）

**定义：** 任意节点的左右子树高度差不超过1

```
平衡二叉树：
        5
       / \
      3   7
     /   / \
    1   6   9

左右子树高度差 ≤ 1

非平衡二叉树：
        5
       /
      3
     /
    1

右子树高度为0，左子树高度为2，差值>1
```

---

## 七、存储结构

### 一般树的存储结构

一般树（多叉树）的存储方法主要有三种：

#### 1. 双亲表示法（Parent Representation）

**适用场景：** 需要频繁查找父节点的场景

**存储方式：** 使用数组存储节点，每个节点记录其父节点的索引

**节点结构：**

```c
#define MAX_TREE_SIZE 100

// 双亲表示法节点
typedef struct {
    int data;        // 数据域
    int parent;      // 父节点索引（-1表示根节点）
} PTNode;

// 树结构
typedef struct {
    PTNode nodes[MAX_TREE_SIZE];  // 节点数组
    int r, n;                     // 根的位置和节点数
} PTree;
```

**示例：**

```
一般树：
      A(0)
    / | \
   B(1) C(2) D(3)
  /|
 E(4) F(5)

数组存储：
索引：  0   1   2   3   4   5
data： A   B   C   D   E   F
parent：-1  0   0   0   1   1

特点：
- 根节点的parent为-1
- 每个节点都能快速找到父节点（O(1)）
- 查找子节点需要遍历整个数组（O(n)）
```

**优点：**
- 查找父节点快速（O(1)）
- 存储结构简单
- 节省空间（每个节点只需一个指针）

**缺点：**
- 查找子节点需要遍历（O(n)）
- 插入删除节点不方便

#### 2. 孩子表示法（Child Representation）

**适用场景：** 需要频繁查找子节点的场景

**存储方式：** 使用数组存储节点，每个节点维护一个子节点链表

**节点结构：**

```c
// 孩子链表节点
typedef struct CTNode {
    int child;           // 子节点在数组中的索引
    struct CTNode *next; // 下一个子节点
} *ChildPtr;

// 表头节点
typedef struct {
    int data;            // 数据域
    ChildPtr firstChild; // 第一个子节点指针
} CTBox;

// 树结构
typedef struct {
    CTBox nodes[MAX_TREE_SIZE]; // 节点数组
    int r, n;                   // 根的位置和节点数
} CTree;
```

**示例：**

```
一般树：
      A(0)
    / | \
   B(1) C(2) D(3)
  /|
 E(4) F(5)

数组存储：
索引：  0   1   2   3   4   5
data： A   B   C   D   E   F
child：→1  →4  null null null null
       ↓   ↓
       2   5
       ↓
       3

特点：
- 每个节点都有指向子节点链表的指针
- 查找子节点快速（O(度)）
- 查找父节点需要遍历（O(n)）
```

**优点：**
- 查找子节点快速（O(度)）
- 插入删除子节点方便
- 空间利用率高

**缺点：**
- 查找父节点需要遍历
- 需要额外的链表空间

#### 3. 孩子兄弟表示法（Child-Sibling Representation，左子右兄表示法）

**适用场景：** 将一般树转换为二叉树存储，利用二叉树算法

**存储方式：** 每个节点有两个指针：左指针指向第一个子节点，右指针指向右兄弟节点

**节点结构：**

```c
// 孩子兄弟表示法节点（实际就是二叉树节点）
typedef struct CSNode {
    int data;               // 数据域
    struct CSNode *firstchild;  // 左指针：指向第一个子节点
    struct CSNode *nextsibling; // 右指针：指向右兄弟节点
} CSNode, *CSTree;
```

**示例：**

```
一般树：
      A
    / | \
   B  C  D
  /|
 E F

孩子兄弟表示法（二叉树）：
      A
     /
    B
   / \
  E   C
   \   \
    F   D

规则：
- A的左子节点：B（A的第一个子节点）
- B的右子节点：C（B的右兄弟）
- C的右子节点：D（C的右兄弟）
- B的左子节点：E（B的第一个子节点）
- E的右子节点：F（E的右兄弟）
```

**优点：**
- 可以将一般树转换为二叉树
- 可以利用二叉树的算法和操作
- 节省空间（每个节点只有两个指针）
- 结构统一，便于处理

**缺点：**
- 结构不够直观
- 需要理解转换规则

**详细说明见"树与二叉树的转换"部分**

#### 4. 子节点列表法（现代常用方法）

**适用场景：** 任何类型的一般树（多叉树），现代编程语言常用

**节点结构：**

```c
// 一般树节点结构 (C语言通常使用孩子兄弟表示法来通用表示，或者使用动态数组)
// 这里展示使用动态数组（类似C++ vector）的思路，C语言需手动管理
typedef struct TreeNode {
    int data;
    struct TreeNode **children; // 子节点指针数组
    int childCount;             // 子节点数量
    int capacity;               // 容量
} TreeNode;

TreeNode* CreateNode(int data) {
    TreeNode *node = (TreeNode*)malloc(sizeof(TreeNode));
    node->data = data;
    node->childCount = 0;
    node->capacity = 4; // 初始容量
    node->children = (TreeNode**)malloc(sizeof(TreeNode*) * node->capacity);
    return node;
}

void AddChild(TreeNode *parent, TreeNode *child) {
    if (parent->childCount >= parent->capacity) {
        parent->capacity *= 2;
        parent->children = (TreeNode**)realloc(parent->children, sizeof(TreeNode*) * parent->capacity);
    }
    parent->children[parent->childCount++] = child;
}
```

**结构说明：**
- `data`：数据域，存储节点数据
- `children`：子节点列表，存储该节点的所有子节点（动态数组）

**优点：**
- 适用于任何度数的树
- 插入删除子节点方便
- 实现简单直观
- 现代编程语言支持良好

**缺点：**
- 需要额外的列表空间
- 查找某个子节点需要遍历列表

**示例：**

```
一般树：
      A
    / | \
   B  C  D
  /|
 E F

存储结构：
A: data=1, children=[B, C, D]
B: data=2, children=[E, F]
C: data=3, children=[]
D: data=4, children=[]
E: data=5, children=[]
F: data=6, children=[]
```

### 存储方法对比总结

| 存储方法 | 查找父节点 | 查找子节点 | 插入删除 | 空间复杂度 | 适用场景 |
|---------|----------|----------|---------|-----------|---------|
| **双亲表示法** | O(1) | O(n) | 困难 | O(n) | 频繁查找父节点 |
| **孩子表示法** | O(n) | O(度) | 方便 | O(n+边数) | 频繁查找子节点 |
| **孩子兄弟表示法** | O(n) | O(1) | 方便 | O(n) | 转换为二叉树 |
| **子节点列表法** | O(n) | O(度) | 方便 | O(n+边数) | 通用场景（推荐） |

**选择建议：**
- **一般情况**：使用子节点列表法（最简单直观）
- **需要频繁查找父节点**：使用双亲表示法
- **需要转换为二叉树**：使用孩子兄弟表示法
- **需要频繁查找子节点**：使用孩子表示法或子节点列表法

---

### 二叉树的存储结构

二叉树的存储方法主要有以下几种：

#### 1. 链式存储（二叉链表，最常用）

**适用场景：** 任何类型的二叉树

**节点结构：**

```c
// 二叉树节点结构（二叉链表）
typedef struct BiTNode {
    int data;                   // 数据域
    struct BiTNode *lchild;     // 左指针
    struct BiTNode *rchild;     // 右指针
} BiTNode, *BiTree;

// 创建新节点
BiTree CreateBiNode(int data) {
    BiTree node = (BiTree)malloc(sizeof(BiTNode));
    node->data = data;
    node->lchild = NULL;
    node->rchild = NULL;
    return node;
}
```

**结构说明：**
- `data`：数据域，存储节点数据
- `left`：左指针，指向左子节点（如果没有左子节点则为null）
- `right`：右指针，指向右子节点（如果没有右子节点则为null）

**示例：**

```
二叉树：
        A
       / \
      B   C
     / \
    D   E

链式存储：
A: data=A, left→B, right→C
B: data=B, left→D, right→E
C: data=C, left=null, right=null
D: data=D, left=null, right=null
E: data=E, left=null, right=null
```

**优点：**
- 适用于任何二叉树
- 空间利用率高（只为实际存在的节点分配空间）
- 插入删除方便
- 结构灵活

**缺点：**
- 需要额外的指针空间（每个节点2个指针）
- 不能快速定位父节点（需要遍历）
- n个节点需要2n个指针，但只有n-1条边，浪费n+1个指针

**空间分析：**
- n个节点：需要n个数据域 + 2n个指针域 = 3n个存储单元
- 实际使用：n-1个指针（边数）
- 浪费：n+1个空指针

#### 2. 三叉链表（带父指针的链式存储）

**适用场景：** 需要频繁查找父节点的二叉树

**节点结构：**

```c
// 三叉链表节点结构
typedef struct TriTNode {
    int data;                   // 数据域
    struct TriTNode *lchild;    // 左指针
    struct TriTNode *rchild;    // 右指针
    struct TriTNode *parent;    // 父指针
} TriTNode, *TriTree;
```

**结构说明：**
- `data`：数据域
- `left`：左指针
- `right`：右指针
- `parent`：父指针，指向父节点

**示例：**

```
二叉树：
        A
       / \
      B   C
     / \
    D   E

三叉链表存储：
A: data=A, left→B, right→C, parent=null
B: data=B, left→D, right→E, parent→A
C: data=C, left=null, right=null, parent→A
D: data=D, left=null, right=null, parent→B
E: data=E, left=null, right=null, parent→B
```

**优点：**
- 可以快速查找父节点（O(1)）
- 适用于需要向上遍历的场景
- 删除节点时方便找到父节点

**缺点：**
- 需要额外的父指针空间
- 插入节点时需要更新父指针
- 空间开销更大（每个节点3个指针）

**空间分析：**
- n个节点：需要n个数据域 + 3n个指针域 = 4n个存储单元
- 实际使用：n-1个左/右指针 + n-1个父指针 = 2n-2个指针
- 浪费：n+2个空指针

#### 3. 顺序存储（数组）

**适用场景：** 完全二叉树或满二叉树

**存储方式：** 使用数组按层次顺序存储节点

**存储规则：**
- 根节点存储在索引1（或0）
- 节点i的左子节点存储在索引2i
- 节点i的右子节点存储在索引2i+1
- 节点i的父节点存储在索引⌊i/2⌋（i > 1）

**示例（从索引1开始）：**

```
完全二叉树：
        A(1)
       /    \
      B(2)   C(3)
     / \    /
   D(4) E(5) F(6)

数组存储：
索引：  0   1   2   3   4   5   6
值：   -   A   B   C   D   E   F

节点关系：
- 节点1（A）的左子节点：2（B）
- 节点1（A）的右子节点：3（C）
- 节点2（B）的父节点：1（A）
- 节点4（D）的父节点：2（B）
```

**示例（从索引0开始）：**

```
完全二叉树：
        A(0)
       /    \
      B(1)   C(2)
     / \    /
   D(3) E(4) F(5)

数组存储：
索引：  0   1   2   3   4   5
值：   A   B   C   D   E   F

节点关系：
- 节点i的左子节点：2i+1
- 节点i的右子节点：2i+2
- 节点i的父节点：⌊(i-1)/2⌋
```

**优点：**
- 不需要指针，节省空间
- 快速定位父子节点（通过索引计算，O(1)）
- 适合完全二叉树和满二叉树
- 存储密度高

**缺点：**
- 只适合完全二叉树和满二叉树
- 一般二叉树会浪费大量空间
- 插入删除困难（需要移动大量元素）
- 需要预分配数组大小

**一般二叉树的顺序存储问题：**

```
一般二叉树：
        A
       /
      B
       \
        C

数组存储（按满二叉树方式，从索引1开始）：
索引：  1   2   3   4   5   6   7
值：   A   B   -   -   C   -   -

浪费了3、4、6、7位置的空间！
空间利用率：3/7 ≈ 43%
```

**空间分析：**
- 完全二叉树：n个节点需要n个存储单元（空间利用率100%）
- 一般二叉树：n个节点可能需要2^h-1个存储单元（h为树的高度）
- 最坏情况：单支树，n个节点需要2^n-1个存储单元（空间利用率极低）

#### 4. 线索二叉树（Threaded Binary Tree）

**适用场景：** 需要频繁遍历二叉树，且希望利用空指针

**基本思想：** 利用二叉链表中的n+1个空指针，存储遍历序列中的前驱和后继信息

**节点结构：**

```c
// 线索二叉树节点结构
typedef enum { Link, Thread } PointerTag; // Link==0:指针, Thread==1:线索

typedef struct ThreadNode {
    int data;                       // 数据域
    struct ThreadNode *lchild;      // 左指针
    struct ThreadNode *rchild;      // 右指针
    PointerTag ltag;                // 左标志
    PointerTag rtag;                // 右标志
} ThreadNode, *ThreadTree;
```

**线索化类型：**
- **前序线索二叉树**：按前序遍历顺序线索化
- **中序线索二叉树**：按中序遍历顺序线索化（最常用）
- **后序线索二叉树**：按后序遍历顺序线索化

**中序线索二叉树示例：**

```
原二叉树：
        A
       / \
      B   C
     / \
    D   E

中序遍历：D → B → E → A → C

中序线索二叉树：
        A
       / \
      B   C
     / \
    D   E

线索关系（虚线表示线索）：
D.right → B（D的后继是B）
E.left → B（E的前驱是B）
E.right → A（E的后继是A）
C.left → A（C的前驱是A）
```

**优点：**
- 利用空指针，不浪费空间
- 遍历速度快（不需要栈或递归）
- 可以快速找到前驱和后继节点

**缺点：**
- 线索化过程需要额外时间
- 插入删除节点时需要更新线索
- 实现较复杂

**应用场景：**
- 需要频繁遍历二叉树
- 需要快速查找前驱和后继
- 内存受限的环境

### 二叉树存储方法对比总结

| 存储方法 | 查找父节点 | 查找子节点 | 插入删除 | 空间复杂度 | 适用场景 |
|---------|----------|----------|---------|-----------|---------|
| **二叉链表** | O(n) | O(1) | 方便 | O(n) | 通用场景（推荐） |
| **三叉链表** | O(1) | O(1) | 方便（需更新父指针） | O(n) | 需要频繁查找父节点 |
| **顺序存储** | O(1) | O(1) | 困难 | O(2^h) | 完全二叉树/满二叉树 |
| **线索二叉树** | O(n) | O(1) | 复杂（需更新线索） | O(n) | 频繁遍历，利用空指针 |

**选择建议：**
- **一般情况**：使用二叉链表（最简单，最常用）
- **需要频繁查找父节点**：使用三叉链表
- **完全二叉树或满二叉树**：使用顺序存储（空间效率高）
- **需要频繁遍历且内存受限**：使用线索二叉树
- **需要快速定位父子节点且是完全二叉树**：使用顺序存储

**空间效率对比（n个节点）：**
- **二叉链表**：3n个存储单元（n个数据 + 2n个指针）
- **三叉链表**：4n个存储单元（n个数据 + 3n个指针）
- **顺序存储（完全二叉树）**：n个存储单元（最优）
- **顺序存储（一般二叉树）**：最多2^h-1个存储单元（h为高度，可能浪费）
- **线索二叉树**：3n个存储单元（与二叉链表相同，但利用空指针）

---

## 八、树的遍历

### 一般树的遍历

#### 1. 先根遍历（前序遍历）

**遍历顺序：** 先访问根节点，再依次遍历各子树

```
        A
      / | \
     B  C  D
    /|   |
   E F   G

先根遍历：A → B → E → F → C → G → D

步骤：
1. 访问根节点 A
2. 先根遍历子树B：B → E → F
3. 先根遍历子树C：C → G
4. 先根遍历子树D：D
```

**递归实现：**

```c
void PreOrder(TreeNode *node) {
    if (node == NULL) {
        return;
    }
    printf("%d ", node->data);  // 访问根节点
    
    // 依次遍历各子树
    for (int i = 0; i < node->childCount; i++) {
        PreOrder(node->children[i]);
    }
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

#### 2. 后根遍历（后序遍历）

**遍历顺序：** 先依次遍历各子树，再访问根节点

```
        A
      / | \
     B  C  D
    /|   |
   E F   G

后根遍历：E → F → B → G → C → D → A

步骤：
1. 后根遍历子树B：E → F → B
2. 后根遍历子树C：G → C
3. 后根遍历子树D：D
4. 访问根节点 A
```

**递归实现：**

```c
void PostOrder(TreeNode *node) {
    if (node == NULL) {
        return;
    }
    
    // 先依次遍历各子树
    for (int i = 0; i < node->childCount; i++) {
        PostOrder(node->children[i]);
    }
    
    printf("%d ", node->data);  // 访问根节点
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

#### 3. 层次遍历

**遍历顺序：** 从上到下，从左到右，按层次访问

```
        A
      / | \
     B  C  D
    /|   |
   E F   G

层次遍历：A → B → C → D → E → F → G

步骤：
第1层：A
第2层：B → C → D
第3层：E → F → G
```

**实现方法：** 使用队列（FIFO）

```c
void LevelOrder(TreeNode *root) {
    if (root == NULL) return;
    
    // 假设有一个简单的队列实现
    TreeNode* queue[100];
    int front = 0, rear = 0;
    
    queue[rear++] = root;
    
    while (front < rear) {
        TreeNode *node = queue[front++];
        printf("%d ", node->data);
        
        // 将所有子节点加入队列
        for (int i = 0; i < node->childCount; i++) {
            queue[rear++] = node->children[i];
        }
    }
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(w) - w为树的最大宽度

---

## 九、二叉树的遍历

### 遍历概述

**遍历（Traversal）** 是按某种规则访问树中所有节点，且每个节点恰好访问一次。

### 遍历分类

1. **深度优先遍历（DFS）**：沿着树的深度遍历
   - 前序遍历（Pre-order）：根 → 左 → 右
   - 中序遍历（In-order）：左 → 根 → 右
   - 后序遍历（Post-order）：左 → 右 → 根

2. **广度优先遍历（BFS）**：逐层遍历
   - 层次遍历（Level-order）：从上到下，从左到右

### 1. 前序遍历（Pre-order）

**遍历顺序：** 根 → 左 → 右

```
        A
       / \
      B   C
     / \
    D   E

前序遍历：A → B → D → E → C

步骤：
1. 访问根节点 A
2. 前序遍历左子树：B → D → E
3. 前序遍历右子树：C
```

**递归实现：**

```c
void PreOrderBi(BiTree T) {
    if (T == NULL) {
        return;
    }
    printf("%d ", T->data);     // 1. 访问根节点
    PreOrderBi(T->lchild);      // 2. 前序遍历左子树
    PreOrderBi(T->rchild);      // 3. 前序遍历右子树
}
```

**应用场景：**
- 复制树（克隆树）
- 打印表达式树的前缀表达式
- 序列化二叉树

**时间复杂度：** O(n)  
**空间复杂度：** O(h) - 递归栈深度

### 2. 中序遍历（In-order）

**遍历顺序：** 左 → 根 → 右

```
        A
       / \
      B   C
     / \
    D   E

中序遍历：D → B → E → A → C

步骤：
1. 中序遍历左子树：D → B → E
2. 访问根节点 A
3. 中序遍历右子树：C
```

**递归实现：**

```c
void InOrderBi(BiTree T) {
    if (T == NULL) {
        return;
    }
    InOrderBi(T->lchild);       // 1. 中序遍历左子树
    printf("%d ", T->data);     // 2. 访问根节点
    InOrderBi(T->rchild);       // 3. 中序遍历右子树
}
```

**应用场景：**
- **二叉搜索树（BST）的中序遍历得到有序序列**（重要）
- 打印表达式树的中缀表达式

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

### 3. 后序遍历（Post-order）

**遍历顺序：** 左 → 右 → 根

```
        A
       / \
      B   C
     / \
    D   E

后序遍历：D → E → B → C → A

步骤：
1. 后序遍历左子树：D → E → B
2. 后序遍历右子树：C
3. 访问根节点 A
```

**递归实现：**

```c
void PostOrderBi(BiTree T) {
    if (T == NULL) {
        return;
    }
    PostOrderBi(T->lchild);     // 1. 后序遍历左子树
    PostOrderBi(T->rchild);     // 2. 后序遍历右子树
    printf("%d ", T->data);     // 3. 访问根节点
}
```

**应用场景：**
- 删除树（需要先删除子节点）
- 计算表达式树的值
- 打印表达式树的后缀表达式

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

### 4. 层次遍历（Level-order）

**遍历顺序：** 从上到下，从左到右，按层次访问

```
        A
       / \
      B   C
     / \
    D   E

层次遍历：A → B → C → D → E

步骤：
第1层：A
第2层：B → C
第3层：D → E
```

**实现方法：** 使用队列（FIFO）

```c
void LevelOrderBi(BiTree T) {
    if (T == NULL) return;
    
    BiTree queue[100];
    int front = 0, rear = 0;
    
    queue[rear++] = T;
    
    while (front < rear) {
        BiTree node = queue[front++];
        printf("%d ", node->data);
        
        if (node->lchild != NULL) queue[rear++] = node->lchild;
        if (node->rchild != NULL) queue[rear++] = node->rchild;
    }
}
```

**应用场景：**
- 打印树的层次结构
- 广度优先搜索（BFS）
- 求树的宽度

**时间复杂度：** O(n)  
**空间复杂度：** O(w) - w为树的最大宽度

### 遍历总结

| 遍历方式 | 顺序 | 递归公式 | 应用场景 |
|---------|-----|---------|---------|
| **前序遍历** | 根 → 左 → 右 | 根 + 左子树前序 + 右子树前序 | 复制树、前缀表达式 |
| **中序遍历** | 左 → 根 → 右 | 左子树中序 + 根 + 右子树中序 | BST排序、中缀表达式 |
| **后序遍历** | 左 → 右 → 根 | 左子树后序 + 右子树后序 + 根 | 删除树、后缀表达式 |
| **层次遍历** | 逐层访问 | 使用队列 | 打印结构、BFS |

**记忆技巧：**
- 前序：**根**在前（根 → 左 → 右）
- 中序：**根**在中（左 → 根 → 右）
- 后序：**根**在后（左 → 右 → 根）

---

## 十、树的基本操作

### 一般树的基本操作

#### 1. 创建树

**手动创建：**

```c
// 创建示例树
TreeNode *tree = CreateNode(1);  // A
TreeNode *nodeB = CreateNode(2); // B
TreeNode *nodeC = CreateNode(3); // C
TreeNode *nodeD = CreateNode(4); // D

// 构建树结构
AddChild(tree, nodeB);
AddChild(tree, nodeC);
AddChild(tree, nodeD);
```

#### 2. 求树的节点数

```c
int CountNodes(TreeNode *node) {
    if (node == NULL) {
        return 0;
    }
    
    int count = 1;  // 当前节点
    
    // 累加所有子树的节点数
    for (int i = 0; i < node->childCount; i++) {
        count += CountNodes(node->children[i]);
    }
    
    return count;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

#### 3. 求树的深度/高度

```c
int TreeHeight(TreeNode *node) {
    if (node == NULL) {
        return 0;
    }
    
    if (node->childCount == 0) {
        return 1;  // 叶子节点深度为1
    }
    
    int maxChildHeight = 0;
    // 找出所有子树的最大深度
    for (int i = 0; i < node->childCount; i++) {
        int childHeight = TreeHeight(node->children[i]);
        if (childHeight > maxChildHeight) {
            maxChildHeight = childHeight;
        }
    }
    
    return maxChildHeight + 1;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

#### 4. 求叶子节点数

```c
int CountLeaves(TreeNode *node) {
    if (node == NULL) {
        return 0;
    }
    
    if (node->childCount == 0) {
        return 1;  // 叶子节点
    }
    
    int count = 0;
    // 累加所有子树的叶子节点数
    for (int i = 0; i < node->childCount; i++) {
        count += CountLeaves(node->children[i]);
    }
    
    return count;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

#### 5. 查找节点

```c
TreeNode* Search(TreeNode *node, int value) {
    if (node == NULL) {
        return NULL;
    }
    
    if (node->data == value) {
        return node;  // 找到节点
    }
    
    // 在所有子树中查找
    for (int i = 0; i < node->childCount; i++) {
        TreeNode *found = Search(node->children[i], value);
        if (found != NULL) {
            return found;
        }
    }
    
    return NULL;  // 未找到
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

#### 6. 求树的度

```c
int GetTreeDegree(TreeNode *node) {
    if (node == NULL) {
        return 0;
    }
    
    int maxDegree = node->childCount;  // 当前节点的度
    
    // 递归求所有子树的度
    for (int i = 0; i < node->childCount; i++) {
        int childDegree = GetTreeDegree(node->children[i]);
        if (childDegree > maxDegree) {
            maxDegree = childDegree;
        }
    }
    
    return maxDegree;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

---

## 十一、二叉树的基本操作

### 1. 创建二叉树

**手动创建：**

```c
// 创建示例二叉树
BiTree root = CreateBiNode(1);
root->lchild = CreateBiNode(2);
root->rchild = CreateBiNode(3);
root->lchild->lchild = CreateBiNode(4);
root->lchild->rchild = CreateBiNode(5);
```
/*
        1
       / \
      2   3
     / \
    4   5
*/
```

### 2. 求二叉树的节点数

```c
int CountNodesBi(BiTree T) {
    if (T == NULL) {
        return 0;
    }
    return 1 + CountNodesBi(T->lchild) + CountNodesBi(T->rchild);
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

### 3. 求二叉树的深度/高度

```c
int BiTreeHeight(BiTree T) {
    if (T == NULL) {
        return 0;
    }
    int leftHeight = BiTreeHeight(T->lchild);
    int rightHeight = BiTreeHeight(T->rchild);
    return (leftHeight > rightHeight ? leftHeight : rightHeight) + 1;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

### 4. 求叶子节点数

```c
int CountLeavesBi(BiTree T) {
    if (T == NULL) {
        return 0;
    }
    // 叶子节点：左右子树都为空
    if (T->lchild == NULL && T->rchild == NULL) {
        return 1;
    }
    return CountLeavesBi(T->lchild) + CountLeavesBi(T->rchild);
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

### 5. 查找节点

```c
BiTree SearchBi(BiTree T, int value) {
    if (T == NULL) {
        return NULL;
    }
    if (T->data == value) {
        return T;  // 找到节点
    }
    
    // 在左子树中查找
    BiTree left = SearchBi(T->lchild, value);
    if (left != NULL) {
        return left;
    }
    
    // 在右子树中查找
    return SearchBi(T->rchild, value);
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

### 6. 求二叉树的宽度

```c
int BiTreeWidth(BiTree T) {
    if (T == NULL) {
        return 0;
    }
    
    BiTree queue[100];
    int front = 0, rear = 0;
    queue[rear++] = T;
    int maxWidth = 0;
    
    while (front < rear) {
        int levelSize = rear - front;  // 当前层的节点数
        if (levelSize > maxWidth) maxWidth = levelSize;
        
        // 处理当前层的所有节点
        for (int i = 0; i < levelSize; i++) {
            BiTree node = queue[front++];
            if (node->lchild != NULL) queue[rear++] = node->lchild;
            if (node->rchild != NULL) queue[rear++] = node->rchild;
        }
    }
    
    return maxWidth;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(w)

---

## 十、时间复杂度总结

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| **前序遍历** | O(n) | 访问所有节点 |
| **中序遍历** | O(n) | 访问所有节点 |
| **后序遍历** | O(n) | 访问所有节点 |
| **层次遍历** | O(n) | 访问所有节点 |
| **求节点数** | O(n) | 访问所有节点 |
| **求深度** | O(n) | 访问所有节点 |
| **求叶子节点数** | O(n) | 访问所有节点 |
| **查找节点** | O(n) | 最坏情况访问所有节点 |

**说明：** n为节点数，h为树的高度

---

## 十二、常见考点

### 1. 已知两种遍历求第三种遍历

**问题：** 已知前序遍历：A B D E C F，中序遍历：D B E A C F，求后序遍历

**思路：**
1. 前序的第一个是根（A）
2. 在中序中找到根A，左边是左子树（D B E），右边是右子树（C F）
3. 递归构造左右子树

```
根：A
左子树前序：B D E  中序：D B E  → 根B，左D，右E
右子树前序：C F    中序：C F    → 根C，左空，右F

构造出的树：
        A
       / \
      B   C
     / \   \
    D   E   F

后序遍历：D → E → B → F → C → A
```

**答案：** D E B F C A

### 2. 性质3的应用

**问题：** 某二叉树有5个度为2的节点，3个度为1的节点，求叶子节点数

**解答：**
```
已知：n₂ = 5，n₁ = 3
根据性质3：n₀ = n₂ + 1
所以：n₀ = 5 + 1 = 6

答案：叶子节点数为6
```

### 3. 判断是否是完全二叉树

```java
public boolean isComplete(TreeNode root) {
    if (root == null) {
        return true;
    }
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    boolean flag = false;  // 标记是否遇到了空节点
    
    while (!queue.isEmpty()) {
        TreeNode node = queue.poll();
        
        if (node == null) {
            flag = true;  // 遇到空节点
        } else {
            if (flag) {
                return false;  // 空节点后不应该有非空节点
            }
            queue.offer(node.left);
            queue.offer(node.right);
        }
    }
    
    return true;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(w)

### 4. 根据遍历序列构造二叉树

**问题：** 根据前序和中序遍历构造二叉树

```java
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder == null || inorder == null || 
        preorder.length == 0 || preorder.length != inorder.length) {
        return null;
    }
    return buildTreeHelper(preorder, 0, preorder.length - 1, 
                          inorder, 0, inorder.length - 1);
}

```c
BiTree BuildTreeHelper(int *preorder, int preStart, int preEnd,
                       int *inorder, int inStart, int inEnd) {
    if (preStart > preEnd || inStart > inEnd) {
        return NULL;
    }
    
    // 前序的第一个是根节点
    int rootVal = preorder[preStart];
    BiTree root = CreateBiNode(rootVal);
    
    // 在中序中找到根节点的位置
    int rootIndex = inStart;
    for (int i = inStart; i <= inEnd; i++) {
        if (inorder[i] == rootVal) {
            rootIndex = i;
            break;
        }
    }
    
    // 计算左子树的节点数
    int leftSize = rootIndex - inStart;
    
    // 递归构造左右子树
    root->lchild = BuildTreeHelper(preorder, preStart + 1, preStart + leftSize,
                                   inorder, inStart, rootIndex - 1);
    root->rchild = BuildTreeHelper(preorder, preStart + leftSize + 1, preEnd,
                                   inorder, rootIndex + 1, inEnd);
    
    return root;
}
```

**时间复杂度：** O(n²)（可以优化到O(n)使用HashMap）  
**空间复杂度：** O(n)

---

## 十三、树与二叉树的转换

### 树转二叉树

**规则：** 左子右兄（左孩子右兄弟表示法）

```
原树：
      A
    / | \
   B  C  D
  /|
 E F

转换步骤：
1. 每个节点只保留最左边的子节点作为左子节点
2. 其他子节点作为左子节点的右兄弟

转换后的二叉树：
      A
     /
    B
   / \
  E   C
   \   \
    F   D

规则：
- A的左子节点：B（最左子节点）
- B的右子节点：C（B的右兄弟）
- C的右子节点：D（C的右兄弟）
- B的左子节点：E（B的最左子节点）
- E的右子节点：F（E的右兄弟）
```

**转换算法：**

```c
BiTree TreeToBinaryTree(TreeNode *multiRoot) {
    if (multiRoot == NULL) {
        return NULL;
    }
    
    // 创建二叉树节点
    BiTree binaryRoot = CreateBiNode(multiRoot->data);
    
    // 如果有子节点
    if (multiRoot->childCount > 0) {
        // 第一个子节点作为左子节点（最左子节点）
        binaryRoot->lchild = TreeToBinaryTree(multiRoot->children[0]);
        
        // 将其他子节点作为右兄弟链
        BiTree current = binaryRoot->lchild;
        for (int i = 1; i < multiRoot->childCount; i++) {
            current->rchild = TreeToBinaryTree(multiRoot->children[i]);
            current = current->rchild;
        }
    }
    
    return binaryRoot;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

### 二叉树转树

**转换规则：** 左子右兄表示法的逆过程

```c
TreeNode* BinaryTreeToTree(BiTree binaryRoot) {
    if (binaryRoot == NULL) {
        return NULL;
    }
    
    // 创建一般树节点
    TreeNode *multiRoot = CreateNode(binaryRoot->data);
    
    // 处理左子节点（最左子节点）
    if (binaryRoot->lchild != NULL) {
        TreeNode *leftChild = BinaryTreeToTree(binaryRoot->lchild);
        AddChild(multiRoot, leftChild);
        
        // 处理右兄弟链（左子节点的所有右兄弟）
        BiTree rightSibling = binaryRoot->lchild->rchild;
        while (rightSibling != NULL) {
            TreeNode *sibling = BinaryTreeToTree(rightSibling);
            AddChild(multiRoot, sibling);
            rightSibling = rightSibling->rchild;
        }
    }
    
    return multiRoot;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(h)

**代码参考：** [树与二叉树转换完整实现](../代码练习/05-树和二叉树/TreeToBinaryTree.c)

---

## 十三、树的应用

树的应用非常广泛，主要包括：

1. **并查集（Union-Find）**：图的连通性判断、最小生成树算法
2. **哈夫曼树和哈夫曼编码**：数据压缩、文件压缩
3. **表达式树**：编译器、计算器、表达式求值
4. **文件系统**：操作系统文件目录管理
5. **组织架构**：企业管理、权限管理
6. **决策树**：机器学习、数据挖掘
7. **语法分析树**：编译器、解释器

**详细内容请参考：** [树的应用精要](./008-树的应用精要.md)

---

## 十四、二叉排序树（BST）

### 14.1 二叉排序树的定义

**二叉排序树（Binary Search Tree, BST）** 是一种特殊的二叉树，满足以下性质：
1. 对于任意节点，**左子树的所有节点值 < 根节点值 < 右子树的所有节点值**
2. 左子树和右子树也分别是二叉排序树（递归定义）

### 14.2 二叉排序树的特点

```
二叉排序树示例：

        5
       / \
      3   7
     / \ / \
    1  4 6  9

特点：
- 左子树 < 根 < 右子树（递归定义）
- 中序遍历可以得到有序序列：1 3 4 5 6 7 9
- 查找、插入、删除效率高（平均O(log n)）
- 最坏情况下退化为单支树，时间复杂度为O(n)
```

### 14.3 二叉排序树的性质

1. **中序遍历有序性**：中序遍历BST得到的是有序序列（从小到大）
2. **查找效率**：平均时间复杂度O(log n)，最坏O(n)
3. **插入效率**：平均时间复杂度O(log n)，最坏O(n)
4. **删除效率**：平均时间复杂度O(log n)，最坏O(n)

### 14.4 基本操作

#### 1. 查找操作

**查找思路：**
- 从根节点开始
- 如果查找值 < 当前节点值，在左子树中查找
- 如果查找值 > 当前节点值，在右子树中查找
- 如果查找值 = 当前节点值，找到节点

**递归实现：**

```c
BiTree SearchBST(BiTree node, int data) {
    if (node == NULL || node->data == data) {
        return node;
    }
    
    if (data < node->data) {
        return SearchBST(node->lchild, data);  // 在左子树中查找
    } else {
        return SearchBST(node->rchild, data); // 在右子树中查找
    }
}
```

**非递归实现：**

```c
BiTree SearchBSTIterative(BiTree root, int data) {
    BiTree current = root;
    
    while (current != NULL) {
        if (data == current->data) {
            return current;  // 找到节点
        } else if (data < current->data) {
            current = current->lchild;   // 在左子树中查找
        } else {
            current = current->rchild;  // 在右子树中查找
        }
    }
    
    return NULL;  // 未找到
}
```

**时间复杂度：**
- 最好情况（平衡树）：O(log n)
- 最坏情况（单支树）：O(n)
- 平均情况：O(log n)

**空间复杂度：**
- 递归：O(h)，h为树的高度
- 非递归：O(1)

#### 2. 插入操作

**插入思路：**
- 从根节点开始
- 如果插入值 < 当前节点值，在左子树中插入
- 如果插入值 > 当前节点值，在右子树中插入
- 如果插入值 = 当前节点值，不插入（值已存在）
- 找到空位置后插入新节点

**递归实现：**

```c
int InsertBST(BiTree *node, int data) {
    if (*node == NULL) {
        *node = CreateBiNode(data);
        return 1; // 插入成功
    }
    
    if (data < (*node)->data) {
        return InsertBST(&((*node)->lchild), data);
    } else if (data > (*node)->data) {
        return InsertBST(&((*node)->rchild), data);
    } else {
        return 0;  // 值已存在，不插入
    }
}
```

**时间复杂度：** O(h)，h为树的高度

#### 3. 删除操作

**删除思路：**
删除节点有三种情况：

1. **叶子节点**：直接删除
2. **只有一个子节点**：用子节点替换当前节点
3. **有两个子节点**：
   - 找到右子树中的最小节点（中序后继）
   - 用最小节点的值替换当前节点
   - 删除右子树中的最小节点

**删除示例：**

```
删除节点30（有一个子节点）：
        50
       /  \
      30   70
       \   / \
       40 60 80

删除后：
        50
       /  \
      40   70
          / \
         60 80

删除节点50（有两个子节点）：
        50
       /  \
      30   70
     / \  / \
   20 40 60 80

找到右子树最小节点60，替换50：
        60
       /  \
      30   70
     / \    \
   20 40    80
```

**递归实现：**

```c
BiTree FindMin(BiTree node) {
    while (node->lchild != NULL) {
        node = node->lchild;
    }
    return node;
}

BiTree DeleteBST(BiTree node, int data) {
    if (node == NULL) {
        return NULL;  // 节点不存在
    }
    
    if (data < node->data) {
        // 在左子树中删除
        node->lchild = DeleteBST(node->lchild, data);
    } else if (data > node->data) {
        // 在右子树中删除
        node->rchild = DeleteBST(node->rchild, data);
    } else {
        // 找到要删除的节点
        if (node->lchild == NULL) {
            // 情况1：只有右子树或没有子树
            BiTree temp = node->rchild;
            free(node);
            return temp;
        } else if (node->rchild == NULL) {
            // 情况2：只有左子树
            BiTree temp = node->lchild;
            free(node);
            return temp;
        } else {
            // 情况3：有两个子树
            // 找到右子树中的最小节点（中序后继）
            BiTree minNode = FindMin(node->rchild);
            // 用最小节点的值替换当前节点
            node->data = minNode->data;
            // 删除右子树中的最小节点
            node->rchild = DeleteBST(node->rchild, minNode->data);
        }
    }
    
    return node;
}
```

**时间复杂度：** O(h)，h为树的高度

### 14.5 性能分析

| 操作 | 最好情况 | 平均情况 | 最坏情况 | 说明 |
|------|---------|---------|---------|------|
| **查找** | O(log n) | O(log n) | O(n) | 平衡树 vs 单支树 |
| **插入** | O(log n) | O(log n) | O(n) | 平衡树 vs 单支树 |
| **删除** | O(log n) | O(log n) | O(n) | 平衡树 vs 单支树 |
| **中序遍历** | O(n) | O(n) | O(n) | 访问所有节点 |

**最坏情况：** 当插入的序列是有序的（升序或降序）时，BST退化为单支树，高度为n，所有操作的时间复杂度变为O(n)

**示例：**
```
插入序列：1, 2, 3, 4, 5

退化为单支树：
1
 \
  2
   \
    3
     \
      4
       \
        5

高度 = n = 5，查找时间复杂度 = O(5) = O(n)
```

### 14.6 BST vs 普通二叉树

| 特性 | BST | 普通二叉树 |
|------|-----|-----------|
| **节点值关系** | 左 < 根 < 右 | 无限制 |
| **中序遍历** | 有序序列 | 无序序列 |
| **查找效率** | O(log n)（平均） | O(n) |
| **插入效率** | O(log n)（平均） | O(1)（在末尾） |
| **应用场景** | 查找、排序 | 一般树形结构 |

### 14.7 BST的优缺点

**优点：**
- 查找效率高（平均O(log n)）
- 插入删除方便
- 中序遍历得到有序序列
- 实现简单

**缺点：**
- 最坏情况下退化为单支树，效率降为O(n)
- 不保证平衡，高度可能很大
- 需要额外的平衡机制（如AVL树、红黑树）

### 14.8 应用场景

1. **查找表**：快速查找、插入、删除
2. **排序**：中序遍历得到有序序列
3. **范围查询**：查找某个范围内的所有值
4. **数据库索引**：详见[B树和B+树精要](./015-B树和B+树精要.md)

**代码参考：** [二叉排序树完整实现](../代码练习/05-树和二叉树/BinarySearchTree.c)

---

## 十五、AVL树（平衡二叉树）

### 15.1 AVL树的定义

**AVL树（Adelson-Velsky and Landis Tree）** 是一种自平衡的二叉排序树，满足以下性质：
1. 是二叉排序树（BST）
2. **任意节点的左右子树高度差不超过1**（平衡因子：|左子树高度 - 右子树高度| ≤ 1）

### 15.2 AVL树的特点

```
AVL树示例：

        5
       / \
      3   7
     /   / \
    1   6   9

平衡因子：
- 节点5：|2-2| = 0 ✓
- 节点3：|1-0| = 1 ✓
- 节点7：|1-1| = 0 ✓
- 所有节点的平衡因子 ≤ 1

非AVL树示例：

        5
       /
      3
     /
    1

节点5的平衡因子：|2-0| = 2 > 1 ✗
```

### 15.3 平衡因子

**平衡因子（Balance Factor）** = 左子树高度 - 右子树高度

- **平衡因子 = -1, 0, 1**：节点平衡
- **平衡因子 > 1**：左子树过高，需要右旋转
- **平衡因子 < -1**：右子树过高，需要左旋转

### 15.4 旋转操作

AVL树通过旋转操作保持平衡，有四种旋转情况：

#### 1. 右旋转（RR旋转）

**适用情况：** 左子树高度 > 右子树高度，且左子树的左子树更高

```
        y                x
       / \              / \
      x   T3    -->    T1  y
     / \                  / \
    T1  T2              T2  T3

操作：将x提升为根，y成为x的右子节点
```

#### 2. 左旋转（LL旋转）

**适用情况：** 右子树高度 > 左子树高度，且右子树的右子树更高

```
      x                    y
     / \                  / \
    T1  y        -->      x  T3
       / \              / \
      T2  T3           T1  T2

操作：将y提升为根，x成为y的左子节点
```

#### 3. 左右旋转（LR旋转）

**适用情况：** 左子树高度 > 右子树高度，但左子树的右子树更高

```
        z                z                y
       / \              / \              / \
      x   T4    -->    y   T4    -->    x   z
     / \              / \              / \ / \
    T1  y            x  T3            T1 T2 T3 T4
       / \          / \
      T2  T3       T1 T2

步骤：
1. 先对x进行左旋转
2. 再对z进行右旋转
```

#### 4. 右左旋转（RL旋转）

**适用情况：** 右子树高度 > 左子树高度，但右子树的左子树更高

```
      z                z                y
     / \              / \              / \
    T1  x    -->    T1  y    -->      z   x
       / \              / \          / \ / \
      y  T4            T2  x        T1 T2 T3 T4
     / \                  / \
    T2  T3               T3 T4

步骤：
1. 先对x进行右旋转
2. 再对z进行左旋转
```

### 15.5 插入操作

**插入步骤：**
1. 按照BST的方式插入节点
2. 更新节点高度
3. 计算平衡因子
4. 如果平衡因子 > 1 或 < -1，进行相应的旋转

**时间复杂度：** O(log n)

### 15.6 删除操作

**删除步骤：**
1. 按照BST的方式删除节点
2. 更新节点高度
3. 计算平衡因子
4. 如果平衡因子 > 1 或 < -1，进行相应的旋转

**时间复杂度：** O(log n)

### 15.7 性能分析

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| **查找** | O(log n) | O(log n) | 保证平衡，高度为log n |
| **插入** | O(log n) | O(log n) | 需要旋转操作 |
| **删除** | O(log n) | O(log n) | 需要旋转操作 |
| **旋转** | O(1) | O(1) | 常数时间操作 |

**优势：**
- 保证树的高度为O(log n)
- 所有操作的时间复杂度都是O(log n)
- 不会退化为单支树

### 15.8 AVL树 vs BST

| 特性 | AVL树 | BST |
|------|-------|-----|
| **平衡性** | 严格平衡（高度差≤1） | 不保证平衡 |
| **查找效率** | O(log n)（保证） | O(log n)（平均），O(n)（最坏） |
| **插入效率** | O(log n)（需要旋转） | O(log n)（平均），O(n)（最坏） |
| **删除效率** | O(log n)（需要旋转） | O(log n)（平均），O(n)（最坏） |
| **实现复杂度** | 较复杂（需要旋转） | 简单 |
| **适用场景** | 需要保证性能的场景 | 一般查找场景 |

### 15.9 应用场景

1. **数据库索引**：需要保证查找性能
2. **内存数据库**：需要快速查找
3. **编译器**：符号表管理
4. **操作系统**：文件系统索引

**代码参考：** [AVL树完整实现](../代码练习/05-树和二叉树/AVLTree.c)

---

## 十六、红黑树（Red-Black Tree）

> 详见：[红黑树精要](./014-红黑树精要.md)

红黑树是一种自平衡的二叉排序树，通过颜色约束来保持树的平衡。相比AVL树，红黑树在插入删除时旋转次数更少，适合插入删除频繁的场景。

**核心特点：**
- 5条性质：节点颜色、根节点、叶子节点、红色节点约束、黑高相同
- 近似平衡：最长路径 ≤ 2×最短路径
- 时间复杂度：所有操作都是O(log n)

**应用场景：**
- Java TreeMap/TreeSet
- C++ std::map/std::set
- Linux内核进程调度器
- 数据库索引结构

---

## 十七、B树和B+树

> 详见：[B树和B+树精要](./015-B树和B+树精要.md)

B树和B+树是多路平衡搜索树，主要用于外部存储设备和数据库索引。

**B树特点：**
- 多路平衡搜索树
- 关键字存储在内部节点和叶子节点
- 适合文件系统索引

**B+树特点：**
- B树的变体
- 关键字只存储在叶子节点，内部节点只存储索引
- 叶子节点链接成有序链表
- 适合数据库索引，支持高效的范围查询

**应用场景：**
- MySQL InnoDB存储引擎（B+树）
- Linux ext文件系统（B树）
- 数据库索引（B+树）
- 文件系统索引（B树）

---

## 十八、学习要点总结

### ⭐⭐⭐ 必须掌握

1. **树的基本概念和术语**（节点、根、叶子、度、深度等）
2. **二叉树的定义和性质**（5个重要性质）
3. **四种遍历方式**（前序、中序、后序、层次遍历）
4. **递归遍历的实现**
5. **二叉树的基本操作**（求节点数、求深度、求叶子节点数）

### ⭐⭐ 重要理解

1. **特殊二叉树**（满二叉树、完全二叉树、二叉搜索树）
2. **链式存储和顺序存储的选择**
3. **已知两种遍历求第三种遍历**（前序+中序、中序+后序）
4. **树与二叉树的转换**
5. **非递归遍历的实现**（使用栈或队列）
6. **二叉排序树（BST）**：查找、插入、删除操作
7. **AVL树**：旋转操作、平衡维护
8. **红黑树**：详见[红黑树精要](./014-红黑树精要.md)

### ⭐ 了解内容

1. **线索二叉树**：利用空指针存储遍历信息
2. **哈夫曼树**：带权路径长度最小的树
3. **B树和B+树**：详见[B树和B+树精要](./015-B树和B+树精要.md)
4. **并查集**：树形结构的应用

---

## 总结

```
✅ 树 = 层次结构 + 一对多关系 + 递归定义
✅ 二叉树 = 每个节点最多两个子节点 + 左右有序
✅ 适合：需要层次结构、搜索、排序的场景
❌ 不适合：需要线性访问、简单数据存储

📌 核心特点：
   - 树是非线性结构，表示层次关系
   - 二叉树每个节点最多有两个子节点（左、右）
   - 重要性质：n₀ = n₂ + 1（叶子节点数 = 度为2的节点数 + 1）

💡 遍历方式：
   - 前序：根 → 左 → 右（复制树）
   - 中序：左 → 根 → 右（BST排序）
   - 后序：左 → 右 → 根（删除树）
   - 层次：逐层访问（BFS）

⚠️ 注意事项：
   - 所有遍历时间复杂度都是O(n)
   - 递归空间复杂度为O(h)，h为树的高度
   - 层次遍历需要使用队列
   - 已知前序+中序 或 中序+后序 可以唯一确定二叉树
   - 前序+后序无法唯一确定二叉树（缺少中序信息）
```

---

**精简要点**: 树是一种层次结构的非线性数据结构，二叉树是其中最重要的特例。掌握二叉树的四种遍历方式（前序、中序、后序、层次）和基本性质是学习树的基础 🌲✨

**代码参考**：
- [一般树（多叉树）完整实现](../代码练习/05-树和二叉树/Tree.c)
- [二叉树完整实现](../代码练习/05-树和二叉树/BinaryTree.c)
- [树与二叉树转换实现](../代码练习/05-树和二叉树/TreeToBinaryTree.c)
- [二叉排序树（BST）完整实现](../代码练习/05-树和二叉树/BinarySearchTree.c)
- [AVL树（平衡二叉树）完整实现](../代码练习/05-树和二叉树/AVLTree.c)
- [红黑树完整实现](../代码练习/05-树和二叉树/RedBlackTree.c)

