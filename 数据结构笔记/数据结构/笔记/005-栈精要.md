# 栈精要

> 栈的存储实现核心知识  
> 最后更新：2025年1月

## 📚 相关：[思维导图](./数据结构思维导图.md) | [代码练习](../代码练习/03-栈和队列/) | [顺序表](./001-顺序表精要.md) | [链表](./002-单链表精要.md)

### 📝 代码文件说明
- **[SeqStack.c](../代码练习/03-栈和队列/SeqStack.c)** - 顺序栈完整实现
- **[LinkStack.c](../代码练习/03-栈和队列/LinkStack.c)** - 链栈完整实现

---

## 一、基本概念

### 什么是栈？

**通俗理解：** 栈就像"一摞盘子"，只能从顶部（栈顶）放入和取出。后放入的盘子要先取出来，先放入的盘子要后取出来。这是一种**后进先出（LIFO：Last In First Out）**的数据结构。

### 核心特点

```
┌─────────────────────────────────────────────────────────┐
│                   栈的存储结构                           │
└─────────────────────────────────────────────────────────┘

        栈顶（Top）← 唯一允许操作的位置
          ↓
    ┌─────────┐
    │    30   │ ← 最后入栈的元素（后进先出）
    ├─────────┤
    │    20   │
    ├─────────┤
    │    10   │ ← 最先入栈的元素
    └─────────┘
         ↑
      栈底（Bottom）
```

**关键特性：**
- ✅ **后进先出（LIFO）**：后放入的元素先取出
- ✅ **操作受限**：只能在栈顶进行插入和删除操作
- ✅ **操作高效**：入栈和出栈操作时间复杂度都是 O(1)
- ⚠️ **访问受限**：只能访问栈顶元素，不能随机访问
- ⚠️ **大小限制**：顺序栈有容量限制，链栈受内存限制

### 栈的基本操作

栈的基本操作只有两种：
1. **入栈（Push）**：在栈顶插入新元素
2. **出栈（Pop）**：删除栈顶元素并返回

其他常用操作：
3. **取栈顶（Peek/Top）**：获取栈顶元素但不删除
4. **判空（isEmpty）**：判断栈是否为空
5. **获取大小（size）**：获取栈中元素个数

---

## 二、存储结构

栈有两种实现方式：
1. **顺序栈**：使用数组实现
2. **链栈**：使用链表实现

### 顺序栈

#### 存储结构

```c
#define MAXSIZE 100

// 顺序栈结构体
typedef struct {
    int data[MAXSIZE]; // 存储栈元素的数组
    int top;           // 栈顶指针
} SqStack;
```

**结构说明：**
- `data`：数组，存储栈元素
- `top`：栈顶指针，指向栈顶元素的下一个位置（也可以指向栈顶元素，实现方式不同）
- `capacity`：栈的最大容量

#### 内存布局

```
顺序栈在内存中的布局：

┌────────────────────────────────────┐
│  SeqStack 对象（堆内存）            │
│  ┌──────────────────────────────┐ │
│  │ data (引用) → 数组            │ │  8字节（引用）
│  └──────────────────────────────┘ │
│  ┌──────────────────────────────┐ │
│  │ top: 3                       │ │  4字节
│  └──────────────────────────────┘ │
│  ┌──────────────────────────────┐ │
│  │ data: [10, 20, 30, ...]      │ │  MAXSIZE*4字节
│  └──────────────────────────────┘ │
└────────────────────────────────────┘
         │
         ↓
┌────────────────────────────────────┐
│  数组（堆内存）                      │
│  ┌──────┬──────┬──────┬──────┐   │
│  │  10  │  20  │  30  │  ... │   │  每个元素4字节
│  └──────┴──────┴──────┴──────┘   │
│   [0]    [1]    [2]    [3]       │
│                              ↑   │
│                            top=3 │
└────────────────────────────────────┘
```

**指针约定：**
- `top = 0`：空栈
- `top = 1`：栈中有1个元素（在data[0]）
- `top = n`：栈中有n个元素（在data[0]到data[n-1]）

### 链栈

#### 存储结构

```c
// 链栈节点结构体
typedef struct StackNode {
    int data;
    struct StackNode *next;
} StackNode, *LinkStackPtr;

// 链栈结构体
typedef struct {
    LinkStackPtr top;
    int count;
} LinkStack;
```

**结构说明：**
- `top`：栈顶指针，指向栈顶节点（如果栈为空则为null）
- `size`：栈中元素个数（可选，用于快速获取大小）

#### 内存布局

```
链栈在内存中的布局：

┌────────────────────────────────────┐
│  LinkStack 对象（堆内存）           │
│  ┌──────────────────────────────┐ │
│  │ top (指针) → 栈顶节点         │ │  8字节（指针）
│  └──────────────────────────────┘ │
│  ┌──────────────────────────────┐ │
│  │ count: 3                     │ │  4字节
│  └──────────────────────────────┘ │
└────────────────────────────────────┘
         │
         ↓
┌────────────────────────────────────┐
│  栈顶节点（堆内存）                 │
│  ┌──────┬──────┐                  │
│  │  30  │ next │→ ...             │  12字节
│  └──────┴──────┘                  │
└────────────────────────────────────┘
         │
         ↓
┌────────────────────────────────────┐
│  节点2（堆内存）                    │
│  ┌──────┬──────┐                  │
│  │  20  │ next │→ ...             │  12字节
│  └──────┴──────┘                  │
└────────────────────────────────────┘
         │
         ↓
┌────────────────────────────────────┐
│  节点3（堆内存）                    │
│  ┌──────┬──────┐                  │
│  │  10  │ next │→ null           │  12字节
│  └──────┴──────┘                  │
└────────────────────────────────────┘
         ↑
       栈底
```

**特点：**
- 栈顶元素在链表的第一个节点
- 栈底元素在链表的最后一个节点
- 链栈没有容量限制（受内存限制）

---

## 三、基本操作

### 顺序栈操作

#### 1. 初始化

**功能：** 创建一个空的顺序栈

```c
// 初始化顺序栈
Status InitStack(SqStack *S) {
    S->top = 0;  // 栈顶指针初始为0，表示空栈
    return OK;
}
```

**时间复杂度：** O(1)  
**空间复杂度：** O(n)

#### 2. 入栈（Push）

**功能：** 在栈顶插入新元素

```c
Status Push(SqStack *S, int e) {
    // 检查栈是否已满
    if (S->top >= MAXSIZE) {
        return ERROR;  // 栈满
    }
    
    // 将元素放入栈顶，然后栈顶指针加1
    S->data[S->top] = e;
    S->top++;
    return OK;
}
```

**入栈过程图示：**

```
入栈前：栈中有2个元素
┌─────┐
│  20 │ ← top=2
├─────┤
│  10 │
└─────┘

执行 push(30)：

步骤1：将30放入data[top]
data[2] = 30

步骤2：top指针加1
top = 3

入栈后：
┌─────┐
│  30 │ ← top=3
├─────┤
│  20 │
├─────┤
│  10 │
└─────┘
```

**时间复杂度：** O(1)

#### 3. 出栈（Pop）

**功能：** 删除栈顶元素并返回

```c
Status Pop(SqStack *S, int *e) {
    // 检查栈是否为空
    if (S->top == 0) {
        return ERROR;  // 栈空
    }
    
    // 栈顶指针减1，然后返回栈顶元素
    S->top--;
    *e = S->data[S->top];
    return OK;
}
```

**出栈过程图示：**

```
出栈前：栈中有3个元素
┌─────┐
│  30 │ ← top=3
├─────┤
│  20 │
├─────┤
│  10 │
└─────┘

执行 pop()：

步骤1：top指针减1
top = 2

步骤2：返回data[top]
return data[2] = 30

出栈后：
┌─────┐
│  20 │ ← top=2
├─────┤
│  10 │
└─────┘
```

**时间复杂度：** O(1)

#### 4. 取栈顶（Peek）

**功能：** 获取栈顶元素但不删除

```c
Status GetTop(SqStack S, int *e) {
    if (S.top == 0) {
        return ERROR;
    }
    *e = S.data[S.top - 1];  // 返回栈顶元素，top不变
    return OK;
}
```

**时间复杂度：** O(1)

#### 5. 判空

**功能：** 判断栈是否为空

```c
Status StackEmpty(SqStack S) {
    if (S.top == 0) return TRUE;
    else return FALSE;
}
```

**时间复杂度：** O(1)

#### 6. 判满

**功能：** 判断栈是否已满

```c
Status StackFull(SqStack S) {
    if (S.top >= MAXSIZE) return TRUE;
    else return FALSE;
}
```

**时间复杂度：** O(1)

#### 7. 获取大小

**功能：** 获取栈中元素个数

```c
int StackLength(SqStack S) {
    return S.top;
}
```

**时间复杂度：** O(1)

---

### 链栈操作

#### 1. 初始化

**功能：** 创建一个空的链栈

```c
// 初始化链栈
Status InitLinkStack(LinkStack *S) {
    S->top = NULL;
    S->count = 0;
    return OK;
}
```

**时间复杂度：** O(1)  
**空间复杂度：** O(1)

#### 2. 入栈（Push）

**功能：** 在栈顶插入新元素

```c
Status PushLink(LinkStack *S, int e) {
    StackNode *p = (StackNode *)malloc(sizeof(StackNode));
    p->data = e;
    p->next = S->top;
    S->top = p;
    S->count++;
    return OK;
}
```

**入栈过程图示：**

```
入栈前：
top → [20] → [10] → null

执行 push(30)：

步骤1：创建新节点
newNode → [30]

步骤2：新节点指向原栈顶
newNode.next = top  // [30].next → [20]

步骤3：栈顶指针指向新节点
top = newNode       // top → [30]

入栈后：
top → [30] → [20] → [10] → null
```

**时间复杂度：** O(1)

#### 3. 出栈（Pop）

**功能：** 删除栈顶元素并返回

```c
Status PopLink(LinkStack *S, int *e) {
    if (S->top == NULL) return ERROR;
    
    StackNode *p = S->top;
    *e = p->data;
    S->top = p->next;
    free(p);
    S->count--;
    return OK;
}
```

**出栈过程图示：**

```
出栈前：
top → [30] → [20] → [10] → null

执行 pop()：

步骤1：保存栈顶元素的值
value = top.data = 30

步骤2：栈顶指针指向下一个节点
top = top.next  // top → [20]

步骤3：返回保存的值
return 30

出栈后：
top → [20] → [10] → null
```

**时间复杂度：** O(1)

#### 4. 取栈顶（Peek）

**功能：** 获取栈顶元素但不删除

```c
Status GetTopLink(LinkStack S, int *e) {
    if (S.top == NULL) return ERROR;
    *e = S.top->data;
    return OK;
}
```

**时间复杂度：** O(1)

#### 5. 判空

**功能：** 判断栈是否为空

```c
Status LinkStackEmpty(LinkStack S) {
    if (S.top == NULL) return TRUE;
    else return FALSE;
}
```

**时间复杂度：** O(1)

#### 6. 获取大小

**功能：** 获取栈中元素个数

```c
int LinkStackLength(LinkStack S) {
    return S.count;
}
```

**时间复杂度：** O(1)

---

## 四、顺序栈 vs 链栈

### 对比表

| 特性 | 顺序栈 | 链栈 |
|------|--------|------|
| **存储方式** | 数组 | 链表 |
| **容量限制** | 有（固定容量） | 无（受内存限制） |
| **空间效率** | 高（无额外指针） | 低（需要指针空间） |
| **内存分配** | 静态分配（需预分配） | 动态分配（按需分配） |
| **入栈操作** | O(1) | O(1) |
| **出栈操作** | O(1) | O(1) |
| **取栈顶操作** | O(1) | O(1) |
| **访问速度** | 快（数组访问） | 较慢（指针访问） |
| **适用场景** | 元素个数可估计、空间固定 | 元素个数变化大、空间灵活 |

### 选择建议

**选择顺序栈的情况：**
- 元素个数可以估计
- 需要较高的访问速度
- 空间使用效率要求高

**选择链栈的情况：**
- 元素个数变化很大
- 无法估计栈的最大容量
- 需要动态分配内存

---

## 五、时间复杂度总结

| 操作 | 顺序栈 | 链栈 | 说明 |
|------|--------|------|------|
| **初始化** | O(1) | O(1) | 常数时间 |
| **入栈（Push）** | O(1) | O(1) | 常数时间 |
| **出栈（Pop）** | O(1) | O(1) | 常数时间 |
| **取栈顶（Peek）** | O(1) | O(1) | 常数时间 |
| **判空** | O(1) | O(1) | 常数时间 |
| **获取大小** | O(1) | O(1) | 常数时间 |
| **判满** | O(1) | - | 链栈无此操作 |

**总结：** 栈的所有基本操作都是 O(1) 时间复杂度，这是栈的最大优势。

---

## 六、空间复杂度

### 顺序栈

**总空间复杂度：** O(n)

**空间组成：**
- 数据存储：O(n) - 数组存储 n 个元素
- 辅助空间：O(1) - 只需几个变量（top、capacity）

**空间开销：**
- 每个元素：4字节（int类型）
- 总开销：4n + 固定开销（约12字节）

### 链栈

**总空间复杂度：** O(n)

**空间组成：**
- 数据存储：O(n) - 存储 n 个节点
- 指针存储：O(n) - 每个节点需要一个next指针
- 辅助空间：O(1) - 只需几个变量（top、size）

**空间开销：**
- 每个节点：4字节（data）+ 8字节（next指针）= 12字节
- 总开销：12n + 固定开销（约12字节）

**对比：**
- 顺序栈：4n 字节
- 链栈：12n 字节
- **链栈比顺序栈多3倍空间开销**

---

## 七、优缺点分析

### 顺序栈

#### ✅ 优点

1. **访问速度快**：数组访问效率高
2. **空间效率高**：不需要额外的指针空间
3. **实现简单**：代码简单易懂
4. **缓存友好**：数据连续存储，缓存命中率高

#### ❌ 缺点

1. **容量固定**：需要预先分配固定大小的数组
2. **空间浪费**：如果实际使用量远小于容量，会有空间浪费
3. **扩容困难**：如果栈满，需要重新分配更大的数组并复制数据

### 链栈

#### ✅ 优点

1. **动态分配**：不需要预先分配固定大小
2. **空间灵活**：按需分配，不会浪费空间
3. **无容量限制**：只要内存足够，可以无限增长

#### ❌ 缺点

1. **空间开销大**：每个节点需要额外的指针空间
2. **访问速度慢**：需要通过指针访问，不如数组直接访问快
3. **内存碎片**：动态分配可能导致内存碎片
4. **缓存不友好**：节点分散存储，缓存命中率低

---

## 八、应用场景

### 栈的典型应用

1. **函数调用**
   - 保存函数调用的返回地址
   - 保存局部变量和参数
   - 函数调用栈（Call Stack）

2. **表达式求值**
   - 中缀表达式转后缀表达式
   - 后缀表达式求值
   - 括号匹配

3. **递归实现**
   - 递归函数的非递归实现
   - 保存递归过程中的中间状态

4. **括号匹配**
   - 检查表达式中的括号是否匹配
   - HTML/XML标签匹配

5. **进制转换**
   - 十进制转其他进制
   - 利用栈的LIFO特性

6. **迷宫求解**
   - 保存搜索路径
   - 回溯算法

7. **撤销操作（Undo）**
   - 编辑器中的撤销功能
   - 操作历史记录

8. **浏览器前进后退**
   - 保存访问历史
   - 实现前进和后退功能

---

## 九、常见考点

### 1. 括号匹配

**问题：** 检查表达式中的括号是否匹配

**算法：** 使用栈，遇到左括号入栈，遇到右括号出栈并检查是否匹配

```c
int IsValidParentheses(char *s) {
    SqStack S;
    InitStack(&S);
    int e;
    
    for (int i = 0; s[i] != '\0'; i++) {
        char c = s[i];
        if (c == '(' || c == '[' || c == '{') {
            Push(&S, c);  // 左括号入栈
        } else if (c == ')' || c == ']' || c == '}') {
            if (StackEmpty(S)) {
                return FALSE;  // 右括号多余
            }
            Pop(&S, &e);
            char top = (char)e;
            // 检查是否匹配
            if ((c == ')' && top != '(') ||
                (c == ']' && top != '[') ||
                (c == '}' && top != '{')) {
                return FALSE;  // 不匹配
            }
        }
    }
    
    return StackEmpty(S);  // 栈空表示匹配
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(n)

### 2. 后缀表达式求值

**问题：** 计算后缀表达式的值（如：3 4 + 5 *）

**算法：** 遇到数字入栈，遇到运算符出栈两个数字计算后入栈

```c
// 假设 tokens 是字符串数组，count 是数组长度
int EvaluatePostfix(char **tokens, int count) {
    SqStack S;
    InitStack(&S);
    int a, b, result;
    
    for (int i = 0; i < count; i++) {
        char *token = tokens[i];
        if (isdigit(token[0]) || (token[0] == '-' && isdigit(token[1]))) {
            Push(&S, atoi(token));  // 数字入栈
        } else {
            // 运算符：出栈两个数字
            Pop(&S, &b);
            Pop(&S, &a);
            
            switch (token[0]) {
                case '+': result = a + b; break;
                case '-': result = a - b; break;
                case '*': result = a * b; break;
                case '/': result = a / b; break;
            }
            Push(&S, result);  // 计算结果入栈
        }
    }
    
    int finalResult;
    Pop(&S, &finalResult);
    return finalResult;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(n)

### 3. 中缀转后缀表达式

**问题：** 将中缀表达式转换为后缀表达式（如：a+b*c → abc*+）

**算法：** 使用栈保存运算符，根据优先级决定出栈时机

```c
void InfixToPostfix(char *infix, char *postfix) {
    SqStack S;
    InitStack(&S);
    int k = 0; // postfix index
    int e;
    
    for (int i = 0; infix[i] != '\0'; i++) {
        char c = infix[i];
        if (isalnum(c)) {
            postfix[k++] = c;  // 操作数直接输出
        } else if (c == '(') {
            Push(&S, c);  // 左括号入栈
        } else if (c == ')') {
            // 右括号：弹出直到左括号
            int topElem;
            GetTop(S, &topElem);
            while (!StackEmpty(S) && topElem != '(') {
                Pop(&S, &e);
                postfix[k++] = (char)e;
                GetTop(S, &topElem);
            }
            Pop(&S, &e);  // 弹出左括号
        } else {
            // 运算符：比较优先级
            int topElem;
            if (!StackEmpty(S)) GetTop(S, &topElem);
            
            while (!StackEmpty(S) && Precedence(c) <= Precedence((char)topElem)) {
                Pop(&S, &e);
                postfix[k++] = (char)e;
                if (!StackEmpty(S)) GetTop(S, &topElem);
            }
            Push(&S, c);
        }
    }
    
    // 弹出剩余运算符
    while (!StackEmpty(S)) {
        Pop(&S, &e);
        postfix[k++] = (char)e;
    }
    postfix[k] = '\0';
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(n)

---

## 十、学习要点总结

### ⭐⭐⭐ 必须掌握

1. **栈的定义和特点**（LIFO：后进先出）
2. **顺序栈和链栈的实现**（数组和链表）
3. **基本操作**（入栈、出栈、取栈顶、判空）
4. **时间复杂度分析**（所有操作都是O(1)）

### ⭐⭐ 重要理解

1. **顺序栈 vs 链栈的选择**
2. **栈的应用场景**（函数调用、表达式求值、括号匹配等）
3. **栈在递归中的作用**
4. **栈的空间开销对比**

### ⭐ 了解内容

1. **栈的变体应用**（双栈、最小栈等）
2. **栈相关的算法题**（括号匹配、表达式求值等）
3. **栈在系统中的应用**（函数调用栈、内存管理）

---

## 总结

```
✅ 栈 = 后进先出（LIFO）+ 只能在栈顶操作
✅ 适合：需要后进先出的场景、函数调用、表达式求值、括号匹配
❌ 不适合：需要随机访问、需要先进先出的场景

📌 核心特点：
   - 后进先出（LIFO：Last In First Out）
   - 操作受限：只能在栈顶进行插入和删除
   - 操作高效：所有基本操作都是O(1)

💡 实现方式：
   - 顺序栈：使用数组，空间效率高，但容量固定
   - 链栈：使用链表，动态分配，但空间开销大

⚠️ 注意事项：
   - 顺序栈需要检查栈满
   - 链栈需要检查栈空
   - 所有操作都要注意边界条件
```

---

**精简要点**: 栈是一种后进先出（LIFO）的线性数据结构，只能在栈顶进行操作。顺序栈和链栈各有优缺点，所有基本操作都是O(1)时间复杂度。栈广泛应用于函数调用、表达式求值、括号匹配等场景 📚✨

**代码参考**：
- [顺序栈完整实现](../代码练习/03-栈和队列/SeqStack.c)
- [链栈完整实现](../代码练习/03-栈和队列/LinkStack.c)

