# 时间复杂度精要

> 算法复杂度分析核心知识  
> 最后更新：2025年1月

## 📚 相关：[思维导图](./数据结构思维导图.md) | [顺序表](./001-顺序表精要.md) | [单链表](./002-单链表精要.md)

---

## 一、基本概念

### 什么是时间复杂度？

**通俗理解：** 时间复杂度是衡量算法执行时间随输入规模增长而变化的度量。就像"做100道题需要多长时间"一样，时间复杂度告诉我们"处理n个数据需要多少步操作"。

### 为什么需要时间复杂度？

1. **预测性能**：在不知道具体数据的情况下，预估算法性能
2. **算法比较**：比较不同算法的效率，选择最优方案
3. **性能优化**：找出性能瓶颈，指导优化方向
4. **资源规划**：评估算法对计算资源的需求

### 核心思想

```
时间复杂度关注的是：当输入规模 n 增大时，算法执行时间如何变化

例如：
- O(1)：无论 n 多大，执行时间都是常数
- O(n)：n 增大一倍，执行时间也增大一倍
- O(n²)：n 增大一倍，执行时间增大四倍
```

---

## 二、大O表示法

### 2.1 定义

**大O表示法（Big-O Notation）**：描述算法在最坏情况下的时间复杂度上限。

**数学定义：**
```
如果存在正常数 c 和 n₀，使得当 n ≥ n₀ 时，
T(n) ≤ c·f(n)，则称 T(n) = O(f(n))
```

**通俗理解：**
- 大O表示"不超过"或"最多是"
- 关注的是增长趋势，忽略常数和低阶项
- 描述的是最坏情况下的性能

### 2.2 常见时间复杂度

```
┌─────────────────────────────────────────────────────────┐
│                   常见时间复杂度                         │
└─────────────────────────────────────────────────────────┘

O(1)        < O(log n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

常数时间    对数时间   线性时间  线性对数   平方时间  立方时间  指数时间  阶乘时间
```

### 2.3 时间复杂度分类

| 复杂度 | 名称 | 说明 | 示例 |
|--------|------|------|------|
| **O(1)** | 常数时间 | 执行时间与输入规模无关 | 数组随机访问 |
| **O(log n)** | 对数时间 | 执行时间随输入规模对数增长 | 二分查找 |
| **O(n)** | 线性时间 | 执行时间与输入规模成正比 | 遍历数组 |
| **O(n log n)** | 线性对数时间 | 执行时间介于线性和平方之间 | 归并排序、快速排序 |
| **O(n²)** | 平方时间 | 执行时间与输入规模的平方成正比 | 冒泡排序、选择排序 |
| **O(n³)** | 立方时间 | 执行时间与输入规模的立方成正比 | 矩阵乘法（朴素算法） |
| **O(2ⁿ)** | 指数时间 | 执行时间呈指数增长 | 汉诺塔、斐波那契（递归） |
| **O(n!)** | 阶乘时间 | 执行时间呈阶乘增长 | 全排列 |

---

## 三、时间复杂度分析方法

### 3.1 基本规则

#### 规则1：只保留最高阶项

```
T(n) = 3n² + 5n + 2  →  O(n²)
T(n) = 2n³ + 3n² + n →  O(n³)
```

**原因：** 当 n 很大时，最高阶项占主导地位。

#### 规则2：忽略常数系数

```
T(n) = 5n  →  O(n)
T(n) = 100n  →  O(n)
T(n) = n/2  →  O(n)
```

**原因：** 常数系数不影响增长趋势。

#### 规则3：忽略低阶项

```
T(n) = n² + n  →  O(n²)
T(n) = n³ + n² + n  →  O(n³)
```

**原因：** 当 n 很大时，低阶项的影响可以忽略。

### 3.2 分析方法

#### 方法1：数循环次数

**单层循环：**
```c
for (int i = 0; i < n; i++) {
    // O(1) 操作
}
// 时间复杂度：O(n)
```

**嵌套循环：**
```c
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // O(1) 操作
    }
}
// 时间复杂度：O(n²)
```

**不同规模嵌套：**
```c
for (int i = 0; i < n; i++) {
    for (int j = 0; j < m; j++) {
        // O(1) 操作
    }
}
// 时间复杂度：O(n·m)
```

#### 方法2：分析递归

**递归树方法：**
```
递归函数：T(n) = T(n/2) + O(1)

递归树：
        T(n)
       /    \
   T(n/2)  T(n/2)
   /  \     /  \
T(n/4) ... ... ...

深度：log n
每层：O(1)
总时间：O(log n)
```

**主定理（Master Theorem）：**
```
如果 T(n) = a·T(n/b) + f(n)，其中 a ≥ 1, b > 1

则：
- 如果 f(n) = O(n^(log_b a - ε))，则 T(n) = Θ(n^(log_b a))
- 如果 f(n) = Θ(n^(log_b a))，则 T(n) = Θ(n^(log_b a) · log n)
- 如果 f(n) = Ω(n^(log_b a + ε))，则 T(n) = Θ(f(n))
```

#### 方法3：最坏情况分析

```c
int Find(int *arr, int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;  // 可能在这里返回
        }
    }
    return -1;  // 最坏情况：遍历完整个数组
}
// 时间复杂度：O(n) - 分析最坏情况
```

---

## 四、常见算法的时间复杂度

### 4.1 线性表操作

#### 顺序表

| 操作 | 最好情况 | 平均情况 | 最坏情况 | 说明 |
|------|---------|---------|---------|------|
| **按位置访问** | O(1) | O(1) | O(1) | 随机存取 |
| **按值查找** | O(1) | O(n) | O(n) | 需要遍历 |
| **插入** | O(1) | O(n) | O(n) | 表尾插入最快 |
| **删除** | O(1) | O(n) | O(n) | 表尾删除最快 |

**插入操作分析：**
```c
// 在位置 i 插入元素
for (int j = length; j >= i; j--) {  // 移动 n-i+1 个元素
    data[j] = data[j - 1];
}
// 最好情况：i = length+1，移动 0 个元素 → O(1)
// 最坏情况：i = 1，移动 n 个元素 → O(n)
// 平均情况：移动 n/2 个元素 → O(n)
```

#### 链表

| 操作 | 最好情况 | 平均情况 | 最坏情况 | 说明 |
|------|---------|---------|---------|------|
| **按位置访问** | O(1) | O(n) | O(n) | 需要遍历 |
| **按值查找** | O(1) | O(n) | O(n) | 需要遍历 |
| **插入（已知位置）** | O(1) | O(1) | O(1) | 指针操作 |
| **插入（未知位置）** | O(1) | O(n) | O(n) | 需要先查找 |
| **删除（已知位置）** | O(1) | O(1) | O(1) | 指针操作 |
| **删除（未知位置）** | O(1) | O(n) | O(n) | 需要先查找 |

**插入操作分析：**
```c
// 在已知节点后插入
newNode->next = current->next;  // O(1)
current->next = newNode;        // O(1)
// 时间复杂度：O(1)

// 在位置 i 插入（需要先找到位置）
Node *current = head;
for (int j = 0; j < i - 1; j++) {  // O(n)
    current = current->next;
}
newNode->next = current->next;  // O(1)
current->next = newNode;        // O(1)
// 时间复杂度：O(n)
```

### 4.2 栈和队列操作

| 数据结构 | 操作 | 时间复杂度 | 说明 |
|---------|------|----------|------|
| **顺序栈** | 入栈 | O(1) | 栈顶操作 |
| **顺序栈** | 出栈 | O(1) | 栈顶操作 |
| **链栈** | 入栈 | O(1) | 头插法 |
| **链栈** | 出栈 | O(1) | 头删法 |
| **循环队列** | 入队 | O(1) | 队尾操作 |
| **循环队列** | 出队 | O(1) | 队头操作 |
| **链队列** | 入队 | O(1) | 队尾操作 |
| **链队列** | 出队 | O(1) | 队头操作 |

**特点：** 栈和队列的基本操作都是 O(1)，因为它们只在固定位置（栈顶、队头、队尾）操作。

### 4.3 查找算法

| 算法 | 数据结构 | 最好情况 | 平均情况 | 最坏情况 | 说明 |
|------|---------|---------|---------|---------|------|
| **顺序查找** | 无序表 | O(1) | O(n) | O(n) | 线性查找 |
| **折半查找** | 有序表 | O(1) | O(log n) | O(log n) | 二分查找 |
| **分块查找** | 分块表 | O(1) | O(√n) | O(√n) | 块间折半+块内顺序 |
| **BST查找** | 二叉排序树 | O(1) | O(log n) | O(n) | 可能退化为链表 |
| **AVL查找** | 平衡二叉树 | O(log n) | O(log n) | O(log n) | 始终平衡 |
| **散列查找** | 哈希表 | O(1) | O(1) | O(n) | 冲突时退化 |

**折半查找分析：**
```c
int BinarySearch(int *arr, int n, int target) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (arr[mid] == target) return mid;
        else if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1;
}
// 每次循环将搜索范围缩小一半
// 时间复杂度：O(log n)
```

**递归分析：**
```
T(n) = T(n/2) + O(1)
T(n) = T(n/4) + O(1) + O(1)
...
T(n) = T(1) + log n · O(1)
T(n) = O(log n)
```

### 4.4 排序算法

| 算法 | 最好情况 | 平均情况 | 最坏情况 | 稳定性 | 说明 |
|------|---------|---------|---------|--------|------|
| **直接插入排序** | O(n) | O(n²) | O(n²) | ✅ 稳定 | 基本有序时很快 |
| **折半插入排序** | O(n log n) | O(n²) | O(n²) | ✅ 稳定 | 查找用折半，移动仍O(n) |
| **希尔排序** | O(n) | O(n^1.3) | O(n²) | ❌ 不稳定 | 分组插入排序 |
| **冒泡排序** | O(n) | O(n²) | O(n²) | ✅ 稳定 | 相邻元素比较交换 |
| **快速排序** | O(n log n) | O(n log n) | O(n²) | ❌ 不稳定 | 分治法，最坏情况退化 |
| **简单选择排序** | O(n²) | O(n²) | O(n²) | ❌ 不稳定 | 每次选最小 |
| **堆排序** | O(n log n) | O(n log n) | O(n log n) | ❌ 不稳定 | 利用堆的性质 |
| **归并排序** | O(n log n) | O(n log n) | O(n log n) | ✅ 稳定 | 分治法，稳定 |
| **基数排序** | O(d(n+r)) | O(d(n+r)) | O(d(n+r)) | ✅ 稳定 | d为位数，r为基数 |

**快速排序分析：**
```c
void QuickSort(int *arr, int left, int right) {
    if (left >= right) return;  // O(1)
    
    int pivot = Partition(arr, left, right);  // O(n)
    QuickSort(arr, left, pivot - 1);   // T(n/2)
    QuickSort(arr, pivot + 1, right);  // T(n/2)
}

// 最好情况：每次划分均匀
// T(n) = 2T(n/2) + O(n) = O(n log n)
// 
// 最坏情况：每次划分极不均匀（已排序）
// T(n) = T(n-1) + O(n) = O(n²)
```

**归并排序分析：**
```c
void MergeSort(int *arr, int left, int right) {
    if (left >= right) return;  // O(1)
    
    int mid = (left + right) / 2;
    MergeSort(arr, left, mid);      // T(n/2)
    MergeSort(arr, mid + 1, right); // T(n/2)
    Merge(arr, left, mid, right);   // O(n)
}

// T(n) = 2T(n/2) + O(n)
// 根据主定理：T(n) = O(n log n)
// 最好、平均、最坏情况都是 O(n log n)
```

### 4.5 树的操作

| 操作 | 普通二叉树 | 平衡二叉树（AVL） | 说明 |
|------|-----------|-----------------|------|
| **查找** | O(n) | O(log n) | 普通树可能退化为链表 |
| **插入** | O(n) | O(log n) | AVL需要旋转保持平衡 |
| **删除** | O(n) | O(log n) | AVL需要旋转保持平衡 |
| **遍历** | O(n) | O(n) | 必须访问所有节点 |

**二叉树遍历分析：**
```c
void PreOrder(TreeNode *root) {
    if (root == NULL) return;  // O(1)
    Visit(root);               // O(1)
    PreOrder(root->lchild);    // T(n/2)
    PreOrder(root->rchild);    // T(n/2)
}
// T(n) = 2T(n/2) + O(1) = O(n)
// 每个节点访问一次，时间复杂度 O(n)
```

### 4.6 图的操作

| 操作 | 邻接矩阵 | 邻接表 | 说明 |
|------|---------|--------|------|
| **DFS遍历** | O(V²) | O(V+E) | V为顶点数，E为边数 |
| **BFS遍历** | O(V²) | O(V+E) | V为顶点数，E为边数 |
| **Prim算法** | O(V²) | O(E log V) | 最小生成树 |
| **Kruskal算法** | O(E log E) | O(E log E) | 最小生成树 |
| **Dijkstra算法** | O(V²) | O(E log V) | 单源最短路径 |
| **Floyd算法** | O(V³) | O(V³) | 所有顶点对最短路径 |

**DFS分析（邻接表）：**
```c
void DFS(int v, int *visited) {
    visited[v] = 1;  // O(1)
    // 遍历所有邻接点
    // for (int w = FirstNeighbor(v); w >= 0; w = NextNeighbor(v, w)) {
    //     if (!visited[w]) {
    //         DFS(w, visited);  // 递归
    //     }
    // }
}
// 每个顶点访问一次：O(V)
// 每条边检查一次：O(E)
// 总时间复杂度：O(V + E)
```

---

## 五、时间复杂度计算技巧

### 5.1 循环嵌套

**规则：** 嵌套循环的时间复杂度 = 各层循环次数的乘积

```c
// 示例1：两层循环，都是n次
for (int i = 0; i < n; i++) {          // n次
    for (int j = 0; j < n; j++) {      // n次
        // O(1) 操作
    }
}
// 时间复杂度：O(n²)

// 示例2：外层n次，内层m次
for (int i = 0; i < n; i++) {          // n次
    for (int j = 0; j < m; j++) {      // m次
        // O(1) 操作
    }
}
// 时间复杂度：O(n·m)

// 示例3：外层n次，内层i次
for (int i = 0; i < n; i++) {          // n次
    for (int j = 0; j < i; j++) {      // i次（0到n-1）
        // O(1) 操作
    }
}
// 内层总次数：0 + 1 + 2 + ... + (n-1) = n(n-1)/2
// 时间复杂度：O(n²)
```

### 5.2 循环与条件

```c
// 示例：循环中有条件判断
for (int i = 0; i < n; i++) {
    if (condition) {
        // O(1) 操作
    } else {
        // O(n) 操作
    }
}
// 最坏情况：每次都执行else分支
// 时间复杂度：O(n²)
```
//      = ...
//      = 2^k · T(n/2^k) + k·n
//
// 当 n/2^k = 1 时，k = log n
// T(n) = n · T(1) + n·log n = O(n log n)
```

### 5.4 主定理应用

**主定理（Master Theorem）：**

对于递推关系：`T(n) = a·T(n/b) + f(n)`

其中：
- `a ≥ 1`：子问题个数
- `b > 1`：子问题规模缩小比例
- `f(n)`：合并子问题的代价

**判断规则：**

1. **如果** `f(n) = O(n^(log_b a - ε))`（ε > 0）
   - **则** `T(n) = Θ(n^(log_b a))`

2. **如果** `f(n) = Θ(n^(log_b a))`
   - **则** `T(n) = Θ(n^(log_b a) · log n)`

3. **如果** `f(n) = Ω(n^(log_b a + ε))`（ε > 0）且 `a·f(n/b) ≤ c·f(n)`（c < 1）
   - **则** `T(n) = Θ(f(n))`

**示例：**

```
1. T(n) = 2T(n/2) + n
   a=2, b=2, f(n)=n
   log_b a = log_2 2 = 1
   f(n) = n = Θ(n^1) = Θ(n^(log_b a))
   → T(n) = Θ(n log n)

2. T(n) = 8T(n/2) + n²
   a=8, b=2, f(n)=n²
   log_b a = log_2 8 = 3
   f(n) = n² = O(n^(3-1)) = O(n^(log_b a - ε))
   → T(n) = Θ(n³)

3. T(n) = T(n/2) + 1
   a=1, b=2, f(n)=1
   log_b a = log_2 1 = 0
   f(n) = 1 = Θ(n^0) = Θ(n^(log_b a))
   → T(n) = Θ(log n)
```

---

## 六、最好、平均、最坏情况

### 6.1 三种情况

**最好情况（Best Case）：** 算法在最理想输入下的时间复杂度

**平均情况（Average Case）：** 算法在所有可能输入下的平均时间复杂度

**最坏情况（Worst Case）：** 算法在最不理想输入下的时间复杂度

### 6.2 示例分析

#### 示例1：顺序查找

```c
int SequentialSearch(int *arr, int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;  // 找到就返回
        }
    }
    return -1;
}
```

**分析：**
- **最好情况：** 目标元素在第一个位置，比较1次 → **O(1)**
- **平均情况：** 目标元素等概率出现在任意位置，平均比较 n/2 次 → **O(n)**
- **最坏情况：** 目标元素在最后一个位置或不存在，比较 n 次 → **O(n)**

#### 示例2：快速排序

```c
void QuickSort(int *arr, int left, int right) {
    if (left >= right) return;
    int pivot = Partition(arr, left, right);
    QuickSort(arr, left, pivot - 1);
    QuickSort(arr, pivot + 1, right);
}
```

**分析：**
- **最好情况：** 每次划分都均匀，T(n) = 2T(n/2) + O(n) → **O(n log n)**
- **平均情况：** 随机划分，平均也是均匀划分 → **O(n log n)**
- **最坏情况：** 每次划分都极不均匀（已排序），T(n) = T(n-1) + O(n) → **O(n²)**

### 6.3 为什么关注最坏情况？

1. **性能保证**：最坏情况给出性能下界，保证算法不会更慢
2. **实际应用**：某些场景（如实时系统）必须考虑最坏情况
3. **算法比较**：统一标准，便于比较不同算法

**注意：** 大O表示法通常指最坏情况，除非特别说明。

---

## 七、常见时间复杂度对比

### 7.1 增长趋势图

```
执行时间增长趋势（n 增大时）：

O(1)        ████████████████████████████████████████ 常数
O(log n)    ████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░ 对数
O(n)        ████████████████████████████████████████ 线性
O(n log n)  ████████████████████████████████████████ 线性对数
O(n²)       ████████████████████████████████████████ 平方
O(n³)       ████████████████████████████████████████ 立方
O(2ⁿ)       ████████████████████████████████████████ 指数
O(n!)       ████████████████████████████████████████ 阶乘

n = 10      n = 100     n = 1000    n = 10000
```

### 7.2 实际运行时间对比（假设每步1微秒）

| 复杂度 | n=10 | n=100 | n=1000 | n=10000 | 说明 |
|--------|------|-------|--------|---------|------|
| **O(1)** | 1μs | 1μs | 1μs | 1μs | 常数时间 |
| **O(log n)** | 3μs | 7μs | 10μs | 13μs | 对数时间 |
| **O(n)** | 10μs | 100μs | 1ms | 10ms | 线性时间 |
| **O(n log n)** | 30μs | 700μs | 10ms | 130ms | 线性对数 |
| **O(n²)** | 100μs | 10ms | 1s | 100s | 平方时间 |
| **O(n³)** | 1ms | 1s | 16.7min | 11.6天 | 立方时间 |
| **O(2ⁿ)** | 1ms | 10^22年 | - | - | 指数时间 |
| **O(n!)** | 3.6s | - | - | - | 阶乘时间 |

**结论：** 当 n 很大时，O(n²) 以上的算法基本不可用。

---

## 八、时间复杂度优化技巧

### 8.1 减少循环嵌套

**优化前：**
```c
// O(n³)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        for (int k = 0; k < n; k++) {
            // 操作
        }
    }
}
```

**优化后：**
```c
// O(n²)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // 操作
    }
}
```

### 8.2 使用更高效的数据结构

**优化前：**
```c
// 使用链表查找：O(n)
// LinkedList list;
// Contains(&list, target);  // O(n)
```

**优化后：**
```c
// 使用哈希表查找：O(1)
// HashSet set;
// Contains(&set, target);  // O(1)
```

### 8.3 避免重复计算

**优化前：**
```c
// O(n²)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        int sum = 0;
        for (int k = 0; k < n; k++) {  // 重复计算
            sum += arr[k];
        }
    }
}
```

**优化后：**
```c
// O(n²)
int totalSum = 0;
for (int k = 0; k < n; k++) {
    totalSum += arr[k];  // 只计算一次
}
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        // 使用 totalSum
    }
}
```

### 8.4 分治法

**优化前：**
```c
// 暴力查找：O(n)
int max = arr[0];
for (int i = 1; i < n; i++) {
    if (arr[i] > max) max = arr[i];
}
```

**优化后：**
```c
// 分治法：O(n)（虽然复杂度相同，但可以并行化）
int Max(int *arr, int left, int right) {
    if (left == right) return arr[left];
    int mid = (left + right) / 2;
    int maxLeft = Max(arr, left, mid);
    int maxRight = Max(arr, mid+1, right);
    return maxLeft > maxRight ? maxLeft : maxRight;
}
```

---

## 九、常见考点

### 9.1 时间复杂度计算

**题目1：** 计算以下代码的时间复杂度

```c
int sum = 0;
for (int i = 0; i < n; i++) {
    for (int j = i; j < n; j++) {
        sum++;
    }
}
```

**解答：**
```
外层循环：i 从 0 到 n-1，共 n 次
内层循环：j 从 i 到 n-1，共 (n-i) 次

总次数 = (n-0) + (n-1) + (n-2) + ... + (n-(n-1))
       = n + (n-1) + (n-2) + ... + 1
       = n(n+1)/2
       = O(n²)
```

**题目2：** 计算递归函数的时间复杂度

```c
int Func(int n) {
    if (n <= 1) return 1;
    return Func(n-1) + Func(n-2);
}
```

**解答：**
```
这是斐波那契数列的递归实现

递归树：
            func(n)
           /        \
    func(n-1)    func(n-2)
    /      \      /      \
func(n-2) ... func(n-3) ...

树的高度：n
节点数：约 2^n
时间复杂度：O(2^n)
```

### 9.2 时间复杂度比较

**题目：** 按时间复杂度从小到大排序

```
A. O(n log n)
B. O(n²)
C. O(2ⁿ)
D. O(log n)
E. O(n)
```

**解答：**
```
D < E < A < B < C

O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ)
```

### 9.3 时间复杂度优化

**题目：** 优化以下代码，使其时间复杂度从 O(n²) 降到 O(n)

```c
// 原代码：O(n²)
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        if (arr[i] == arr[j] && i != j) {
            return 1;  // 查找重复元素
        }
    }
}
```

**解答：**
```c
// 优化后：O(n)
// 使用哈希表（伪代码）
// HashSet set;
// for (int i = 0; i < n; i++) {
//     if (Contains(&set, arr[i])) {
//         return 1;
//     }
//     Add(&set, arr[i]);
// }
```

---

## 十、时间复杂度总结表

### 10.1 数据结构操作复杂度

| 数据结构 | 查找 | 插入 | 删除 | 访问 |
|---------|------|------|------|------|
| **数组** | O(n) | O(n) | O(n) | O(1) |
| **有序数组** | O(log n) | O(n) | O(n) | O(1) |
| **链表** | O(n) | O(1) | O(1) | O(n) |
| **栈** | - | O(1) | O(1) | O(1) |
| **队列** | - | O(1) | O(1) | O(1) |
| **哈希表** | O(1) | O(1) | O(1) | O(1) |
| **二叉搜索树** | O(log n) | O(log n) | O(log n) | O(log n) |
| **平衡二叉树** | O(log n) | O(log n) | O(log n) | O(log n) |
| **堆** | O(n) | O(log n) | O(log n) | O(1) |

### 10.2 排序算法复杂度

| 算法 | 最好 | 平均 | 最坏 | 空间 | 稳定性 |
|------|------|------|------|------|--------|
| **冒泡排序** | O(n) | O(n²) | O(n²) | O(1) | ✅ |
| **选择排序** | O(n²) | O(n²) | O(n²) | O(1) | ❌ |
| **插入排序** | O(n) | O(n²) | O(n²) | O(1) | ✅ |
| **希尔排序** | O(n) | O(n^1.3) | O(n²) | O(1) | ❌ |
| **归并排序** | O(n log n) | O(n log n) | O(n log n) | O(n) | ✅ |
| **快速排序** | O(n log n) | O(n log n) | O(n²) | O(log n) | ❌ |
| **堆排序** | O(n log n) | O(n log n) | O(n log n) | O(1) | ❌ |
| **计数排序** | O(n+k) | O(n+k) | O(n+k) | O(k) | ✅ |
| **基数排序** | O(d(n+r)) | O(d(n+r)) | O(d(n+r)) | O(r) | ✅ |

### 10.3 图算法复杂度

| 算法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|----------|----------|------|
| **DFS** | O(V+E) | O(V) | 邻接表 |
| **BFS** | O(V+E) | O(V) | 邻接表 |
| **Dijkstra** | O(E log V) | O(V) | 单源最短路径 |
| **Floyd** | O(V³) | O(V²) | 所有顶点对最短路径 |
| **Prim** | O(E log V) | O(V) | 最小生成树 |
| **Kruskal** | O(E log E) | O(V) | 最小生成树 |
| **拓扑排序** | O(V+E) | O(V) | DAG排序 |

---

## 十一、学习要点总结

### ⭐⭐⭐ 必须掌握

1. **大O表示法的定义和规则**
2. **常见时间复杂度：O(1), O(log n), O(n), O(n log n), O(n²), O(2ⁿ)**
3. **循环嵌套的时间复杂度计算**
4. **递归函数的时间复杂度分析**
5. **最好、平均、最坏情况的区别**

### ⭐⭐ 重要理解

1. **主定理的应用**
2. **各种数据结构和算法的时间复杂度**
3. **时间复杂度优化技巧**
4. **时间复杂度与空间复杂度的权衡**

### ⭐ 了解内容

1. **大Ω和大Θ表示法**
2. **平摊分析（Amortized Analysis）**
3. **概率分析**

---

## 总结

```
✅ 时间复杂度 = 算法执行时间随输入规模的增长趋势
✅ 大O表示法 = 描述最坏情况下的时间复杂度上限
✅ 常见复杂度：O(1) < O(log n) < O(n) < O(n log n) < O(n²) < O(2ⁿ)
✅ 分析方法：数循环、递归树、主定理
✅ 优化方向：减少嵌套、使用高效数据结构、避免重复计算
```

---

**精简要点**: 时间复杂度是算法分析的核心，掌握大O表示法和常见复杂度是学习数据结构的基础 ⚙️✨













