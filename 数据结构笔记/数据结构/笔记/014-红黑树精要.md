# 红黑树精要

> 红黑树（Red-Black Tree）核心知识  
> 最后更新：2025年1月

## 📚 相关：[树精要](./007-树精要.md) | [AVL树](./007-树精要.md#十五avl树平衡二叉树) | [代码练习](../代码练习/05-树和二叉树/) | [思维导图](./数据结构思维导图.md)

---

## 📑 目录

- [一、红黑树的定义](#一红黑树的定义)
- [二、红黑树的特点](#二红黑树的特点)
- [三、黑高（Black Height）](#三黑高black-height)
- [四、红黑树 vs AVL树](#四红黑树-vs-avl树)
- [五、旋转操作](#五旋转操作)
- [六、插入操作](#六插入操作)
- [七、删除操作](#七删除操作)
- [八、算法实现](#八算法实现)
- [九、性能分析](#九性能分析)
- [十、应用场景](#十应用场景)
- [十一、红黑树的性质证明](#十一红黑树的性质证明)

---

## 一、红黑树的定义

**红黑树（Red-Black Tree）** 是一种自平衡的二叉排序树，在二叉排序树的基础上增加了颜色属性，通过颜色约束来保持树的平衡。

**红黑树必须满足以下5条性质：**

1. **每个节点要么是红色，要么是黑色**
2. **根节点必须是黑色**
3. **每个叶子节点（NIL节点）都是黑色**
4. **如果一个节点是红色，那么它的两个子节点都是黑色**（不能有两个连续的红色节点）
5. **从任意节点到其每个叶子节点的所有路径上，黑色节点的数量相同**（黑高相同）

---

## 二、红黑树的特点

```
红黑树示例：

         13(黑)
        /    \
      8(红)   17(红)
     /  \     /  \
  1(黑) 11(黑) 15(黑) 25(黑)
   /\   /\   /\   /\
  N N  N N  N N  N N

性质验证：
✓ 每个节点都是红色或黑色
✓ 根节点13是黑色
✓ 所有NIL节点（叶子）都是黑色
✓ 红色节点的子节点都是黑色（8和17是红色，子节点都是黑色）
✓ 从根到任意叶子的路径上黑色节点数相同（都是2个）
```

**关键理解：**
- 红黑树不是严格的平衡树（不像AVL树要求高度差≤1）
- 红黑树是**近似平衡**的，最长路径不超过最短路径的2倍
- 通过颜色约束，保证树的高度为O(log n)

---

## 三、黑高（Black Height）

**黑高（Black Height）**：从某个节点到其任意叶子节点的路径上黑色节点的数量（不包括该节点本身）。

**性质：**
- 所有叶子节点的黑高为0
- 根节点的黑高等于整棵树的黑高
- 红黑树的黑高至少为h/2，其中h是树的高度

---

## 四、红黑树 vs AVL树

| 特性 | 红黑树 | AVL树 |
|------|--------|-------|
| **平衡要求** | 近似平衡（最长路径≤2×最短路径） | 严格平衡（高度差≤1） |
| **查找效率** | O(log n) | O(log n) |
| **插入效率** | O(log n)，最多2次旋转 | O(log n)，可能需要多次旋转 |
| **删除效率** | O(log n)，最多3次旋转 | O(log n)，可能需要多次旋转 |
| **旋转次数** | 较少 | 较多 |
| **适用场景** | 插入删除频繁的场景（如STL map/set） | 查找频繁、插入删除较少的场景 |
| **实现复杂度** | 中等 | 较复杂 |

**选择建议：**
- **插入删除频繁** → 红黑树（旋转次数少）
- **查找为主** → AVL树（更平衡，查找更快）
- **Java TreeMap/TreeSet** → 红黑树
- **C++ std::map/std::set** → 红黑树

---

## 五、旋转操作

红黑树的旋转操作与AVL树相同，包括左旋转和右旋转。

### 5.1 左旋转（Left Rotation）

```
      x                y
     / \              / \
    a   y    -->     x   c
       / \          / \
      b   c        a   b

操作步骤：
1. 将y的左子树b作为x的右子树
2. 将x作为y的左子节点
3. 更新父节点指针
```

### 5.2 右旋转（Right Rotation）

```
      y                x
     / \              / \
    x   c    -->     a   y
   / \                  / \
  a   b                b   c

操作步骤：
1. 将x的右子树b作为y的左子树
2. 将y作为x的右子节点
3. 更新父节点指针
```

---

## 六、插入操作

**插入步骤：**

1. **按照BST的方式插入节点**（新节点初始为红色）
2. **修复红黑树性质**（如果违反性质）

**插入后的修复情况：**

### 情况1：新节点是根节点
- **处理**：将根节点改为黑色

### 情况2：父节点是黑色
- **处理**：不需要修复，树仍然满足性质

### 情况3：父节点是红色（需要修复）
- **情况3.1：叔叔节点是红色**
  - 将父节点和叔叔节点改为黑色
  - 将祖父节点改为红色
  - 将祖父节点作为当前节点，继续向上修复

- **情况3.2：叔叔节点是黑色（或NIL），当前节点是父节点的右子节点**
  - 将父节点作为当前节点
  - 对当前节点进行左旋转
  - 进入情况3.3

- **情况3.3：叔叔节点是黑色（或NIL），当前节点是父节点的左子节点**
  - 将父节点改为黑色
  - 将祖父节点改为红色
  - 对祖父节点进行右旋转

**示例：插入节点10**

```
初始树：
         13(黑)
        /    \
      8(红)   17(红)
     /  \     /  \
  1(黑) 11(黑) 15(黑) 25(黑)

插入10（红色）：
         13(黑)
        /    \
      8(红)   17(红)
     /  \     /  \
  1(黑) 11(黑) 15(黑) 25(黑)
         /
      10(红)  ← 新插入

情况分析：
- 10的父节点11是黑色 → 情况2，不需要修复 ✓
```

---

## 七、删除操作

**删除步骤：**

1. **按照BST的方式删除节点**
2. **如果删除的是红色节点**：不需要修复
3. **如果删除的是黑色节点**：需要修复（因为破坏了黑高）

**删除后的修复情况：**

### 情况1：删除节点是红色
- **处理**：直接删除，不需要修复

### 情况2：删除节点是黑色，替代节点是红色
- **处理**：将替代节点改为黑色

### 情况3：删除节点是黑色，替代节点也是黑色（需要修复）
- **情况3.1：兄弟节点是红色**
  - 将兄弟节点改为黑色
  - 将父节点改为红色
  - 对父节点进行左旋转（或右旋转）
  - 进入情况3.2、3.3或3.4

- **情况3.2：兄弟节点是黑色，兄弟节点的两个子节点都是黑色**
  - 将兄弟节点改为红色
  - 将父节点作为当前节点，继续向上修复

- **情况3.3：兄弟节点是黑色，兄弟节点的左子节点是红色，右子节点是黑色**
  - 将兄弟节点的左子节点改为黑色
  - 将兄弟节点改为红色
  - 对兄弟节点进行右旋转
  - 进入情况3.4

- **情况3.4：兄弟节点是黑色，兄弟节点的右子节点是红色**
  - 将兄弟节点的颜色改为父节点的颜色
  - 将父节点改为黑色
  - 将兄弟节点的右子节点改为黑色
  - 对父节点进行左旋转（或右旋转）

---

## 八、算法实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#define RED true
#define BLACK false

typedef struct Node {
    int key;
    int value;
    struct Node *left, *right;
    bool color;  // 颜色：true=红色，false=黑色
} Node;

typedef struct {
    Node *root;
} RedBlackTree;

// 创建新节点
Node* CreateNode(int key, int value) {
    Node *node = (Node *)malloc(sizeof(Node));
    node->key = key;
    node->value = value;
    node->left = NULL;
    node->right = NULL;
    node->color = RED;  // 新节点默认为红色
    return node;
}

// 初始化红黑树
void InitRedBlackTree(RedBlackTree *tree) {
    tree->root = NULL;
}

// 判断节点是否为红色
bool IsRed(Node *node) {
    if (node == NULL) return false;  // NIL节点是黑色
    return node->color == RED;
}

// 左旋转
Node* RotateLeft(Node *h) {
    Node *x = h->right;
    h->right = x->left;
    x->left = h;
    x->color = h->color;
    h->color = RED;
    return x;
}

// 右旋转
Node* RotateRight(Node *h) {
    Node *x = h->left;
    h->left = x->right;
    x->right = h;
    x->color = h->color;
    h->color = RED;
    return x;
}

// 颜色翻转
void FlipColors(Node *h) {
    h->color = RED;
    h->left->color = BLACK;
    h->right->color = BLACK;
}

// 插入操作递归函数
Node* PutRecursive(Node *h, int key, int value) {
    // 插入新节点
    if (h == NULL) {
        return CreateNode(key, value);
    }
    
    // BST插入
    if (key < h->key) {
        h->left = PutRecursive(h->left, key, value);
    } else if (key > h->key) {
        h->right = PutRecursive(h->right, key, value);
    } else {
        h->value = value;  // 更新值
    }
    
    // 修复红黑树性质
    // 情况1：右子节点是红色，左子节点是黑色 → 左旋转
    if (IsRed(h->right) && !IsRed(h->left)) {
        h = RotateLeft(h);
    }
    
    // 情况2：左子节点是红色，左子节点的左子节点也是红色 → 右旋转
    if (IsRed(h->left) && IsRed(h->left->left)) {
        h = RotateRight(h);
    }
    
    // 情况3：左右子节点都是红色 → 颜色翻转
    if (IsRed(h->left) && IsRed(h->right)) {
        FlipColors(h);
    }
    
    return h;
}

// 插入操作
void Put(RedBlackTree *tree, int key, int value) {
    tree->root = PutRecursive(tree->root, key, value);
    tree->root->color = BLACK;  // 根节点始终为黑色
}

// 查找操作递归函数
int* GetRecursive(Node *node, int key) {
    if (node == NULL) return NULL;
    
    if (key < node->key) {
        return GetRecursive(node->left, key);
    } else if (key > node->key) {
        return GetRecursive(node->right, key);
    } else {
        return &(node->value);
    }
}

// 查找操作
int* Get(RedBlackTree *tree, int key) {
    return GetRecursive(tree->root, key);
}

// 辅助方法：颜色翻转（用于删除）
void FlipColorsDelete(Node *h) {
    h->color = !h->color;
    h->left->color = !h->left->color;
    h->right->color = !h->right->color;
}

// 辅助方法：移动红色节点到左子节点
Node* MoveRedLeft(Node *h) {
    FlipColorsDelete(h);
    if (IsRed(h->right->left)) {
        h->right = RotateRight(h->right);
        h = RotateLeft(h);
        FlipColorsDelete(h);
    }
    return h;
}

// 辅助方法：移动红色节点到右子节点
Node* MoveRedRight(Node *h) {
    FlipColorsDelete(h);
    if (IsRed(h->left->left)) {
        h = RotateRight(h);
        FlipColorsDelete(h);
    }
    return h;
}

// 辅助方法：平衡修复
Node* Balance(Node *h) {
    if (IsRed(h->right)) {
        h = RotateLeft(h);
    }
    if (IsRed(h->left) && IsRed(h->left->left)) {
        h = RotateRight(h);
    }
    if (IsRed(h->left) && IsRed(h->right)) {
        FlipColors(h);
    }
    return h;
}

// 辅助方法：查找最小节点
Node* Min(Node *h) {
    if (h->left == NULL) return h;
    return Min(h->left);
}

// 辅助方法：删除最小节点
Node* DeleteMin(Node *h) {
    if (h->left == NULL) {
        free(h);
        return NULL;
    }
    if (!IsRed(h->left) && !IsRed(h->left->left)) {
        h = MoveRedLeft(h);
    }
    h->left = DeleteMin(h->left);
    return Balance(h);
}

// 删除操作递归函数
Node* DeleteRecursive(Node *h, int key) {
    if (key < h->key) {
        if (!IsRed(h->left) && !IsRed(h->left->left)) {
            h = MoveRedLeft(h);
        }
        h->left = DeleteRecursive(h->left, key);
    } else {
        if (IsRed(h->left)) {
            h = RotateRight(h);
        }
        if (key == h->key && h->right == NULL) {
            free(h);
            return NULL;
        }
        if (!IsRed(h->right) && !IsRed(h->right->left)) {
            h = MoveRedRight(h);
        }
        if (key == h->key) {
            Node *x = Min(h->right);
            h->key = x->key;
            h->value = x->value;
            h->right = DeleteMin(h->right);
        } else {
            h->right = DeleteRecursive(h->right, key);
        }
    }
    return Balance(h);
}

// 删除操作
void Delete(RedBlackTree *tree, int key) {
    if (tree->root == NULL) return;
    
    if (!IsRed(tree->root->left) && !IsRed(tree->root->right)) {
        tree->root->color = RED;
    }
    
    tree->root = DeleteRecursive(tree->root, key);
    
    if (tree->root != NULL) {
        tree->root->color = BLACK;
    }
}

// 中序遍历递归函数
void InOrderRecursive(Node *node) {
    if (node == NULL) return;
    InOrderRecursive(node->left);
    printf("%d(%s) ", node->key, node->color ? "红" : "黑");
    InOrderRecursive(node->right);
}

// 中序遍历
void InOrder(RedBlackTree *tree) {
    InOrderRecursive(tree->root);
    printf("\n");
}

// 获取黑高递归函数
int GetBlackHeightRecursive(Node *node) {
    if (node == NULL) return 0;
    int leftBH = GetBlackHeightRecursive(node->left);
    int rightBH = GetBlackHeightRecursive(node->right);
    int currentBH = (node->color == BLACK) ? 1 : 0;
    // 简单的取最大值，实际上左右黑高应该相等
    return currentBH + (leftBH > rightBH ? leftBH : rightBH);
}

// 获取黑高
int GetBlackHeight(RedBlackTree *tree) {
    return GetBlackHeightRecursive(tree->root);
}
```

---

## 九、性能分析

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| **查找** | O(log n) | O(log n) | 保证平衡，高度为O(log n) |
| **插入** | O(log n) | O(log n) | 最多2次旋转 |
| **删除** | O(log n) | O(log n) | 最多3次旋转 |
| **旋转** | O(1) | O(1) | 常数时间操作 |

**优势：**
- 保证树的高度为O(log n)
- 所有操作的时间复杂度都是O(log n)
- 插入删除时旋转次数少（相比AVL树）
- 适合插入删除频繁的场景

**劣势：**
- 实现较复杂
- 不如AVL树严格平衡（查找效率略低）

---

## 十、应用场景

1. **Java集合类**
   - `TreeMap`：基于红黑树实现的有序映射
   - `TreeSet`：基于红黑树实现的有序集合

2. **C++标准库**
   - `std::map`：基于红黑树实现的有序映射
   - `std::set`：基于红黑树实现的有序集合

3. **Linux内核**
   - 进程调度器
   - 虚拟内存管理

4. **数据库系统**
   - 索引结构
   - 内存数据库

5. **其他应用**
   - 事件调度器
   - 区间树
   - 线段树

---

## 十一、红黑树的性质证明

**性质5的证明（黑高相同）：**

假设从根节点到任意叶子节点的路径上黑色节点数为k（黑高）。

- 最短路径：全部是黑色节点，长度为k
- 最长路径：红色和黑色交替，但红色节点不能连续，所以最多有k个红色节点
- 最长路径长度 ≤ 2k

因此，最长路径不超过最短路径的2倍，树的高度为O(log n)。

---

## 总结

```
✅ 红黑树 = 自平衡二叉排序树 + 颜色约束
✅ 5条性质：节点颜色、根节点、叶子节点、红色节点约束、黑高相同
✅ 近似平衡：最长路径 ≤ 2×最短路径
✅ 时间复杂度：所有操作都是O(log n)

📌 核心特点：
   - 不是严格平衡，但保证O(log n)高度
   - 插入删除时旋转次数少（相比AVL树）
   - 适合插入删除频繁的场景

💡 选择建议：
   - 插入删除频繁 → 红黑树
   - 查找为主 → AVL树
   - Java TreeMap/TreeSet → 红黑树
   - C++ std::map/std::set → 红黑树
```

---

**精简要点**: 红黑树是一种近似平衡的自平衡二叉排序树，通过5条颜色约束保证树的高度为O(log n)。相比AVL树，红黑树在插入删除时旋转次数更少，适合插入删除频繁的场景 🔴⚫✨

**代码参考**：[红黑树完整实现](../代码练习/05-树和二叉树/RedBlackTree.c)













