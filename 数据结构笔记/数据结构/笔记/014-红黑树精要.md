# 红黑树精要

> 红黑树（Red-Black Tree）核心知识  
> 最后更新：2025年1月

## 📚 相关：[树精要](./007-树精要.md) | [AVL树](./007-树精要.md#十五avl树平衡二叉树) | [代码练习](../代码练习/05-树和二叉树/) | [思维导图](./数据结构思维导图.md)

---

## 📑 目录

- [一、红黑树的定义](#一红黑树的定义)
- [二、红黑树的特点](#二红黑树的特点)
- [三、黑高（Black Height）](#三黑高black-height)
- [四、红黑树 vs AVL树](#四红黑树-vs-avl树)
- [五、旋转操作](#五旋转操作)
- [六、插入操作](#六插入操作)
- [七、删除操作](#七删除操作)
- [八、算法实现](#八算法实现)
- [九、性能分析](#九性能分析)
- [十、应用场景](#十应用场景)
- [十一、红黑树的性质证明](#十一红黑树的性质证明)

---

## 一、红黑树的定义

**红黑树（Red-Black Tree）** 是一种自平衡的二叉排序树，在二叉排序树的基础上增加了颜色属性，通过颜色约束来保持树的平衡。

**红黑树必须满足以下5条性质：**

1. **每个节点要么是红色，要么是黑色**
2. **根节点必须是黑色**
3. **每个叶子节点（NIL节点）都是黑色**
4. **如果一个节点是红色，那么它的两个子节点都是黑色**（不能有两个连续的红色节点）
5. **从任意节点到其每个叶子节点的所有路径上，黑色节点的数量相同**（黑高相同）

---

## 二、红黑树的特点

```
红黑树示例：

         13(黑)
        /    \
      8(红)   17(红)
     /  \     /  \
  1(黑) 11(黑) 15(黑) 25(黑)
   /\   /\   /\   /\
  N N  N N  N N  N N

性质验证：
✓ 每个节点都是红色或黑色
✓ 根节点13是黑色
✓ 所有NIL节点（叶子）都是黑色
✓ 红色节点的子节点都是黑色（8和17是红色，子节点都是黑色）
✓ 从根到任意叶子的路径上黑色节点数相同（都是2个）
```

**关键理解：**
- 红黑树不是严格的平衡树（不像AVL树要求高度差≤1）
- 红黑树是**近似平衡**的，最长路径不超过最短路径的2倍
- 通过颜色约束，保证树的高度为O(log n)

---

## 三、黑高（Black Height）

**黑高（Black Height）**：从某个节点到其任意叶子节点的路径上黑色节点的数量（不包括该节点本身）。

**性质：**
- 所有叶子节点的黑高为0
- 根节点的黑高等于整棵树的黑高
- 红黑树的黑高至少为h/2，其中h是树的高度

---

## 四、红黑树 vs AVL树

| 特性 | 红黑树 | AVL树 |
|------|--------|-------|
| **平衡要求** | 近似平衡（最长路径≤2×最短路径） | 严格平衡（高度差≤1） |
| **查找效率** | O(log n) | O(log n) |
| **插入效率** | O(log n)，最多2次旋转 | O(log n)，可能需要多次旋转 |
| **删除效率** | O(log n)，最多3次旋转 | O(log n)，可能需要多次旋转 |
| **旋转次数** | 较少 | 较多 |
| **适用场景** | 插入删除频繁的场景（如STL map/set） | 查找频繁、插入删除较少的场景 |
| **实现复杂度** | 中等 | 较复杂 |

**选择建议：**
- **插入删除频繁** → 红黑树（旋转次数少）
- **查找为主** → AVL树（更平衡，查找更快）
- **Java TreeMap/TreeSet** → 红黑树
- **C++ std::map/std::set** → 红黑树

---

## 五、旋转操作

红黑树的旋转操作与AVL树相同，包括左旋转和右旋转。

### 5.1 左旋转（Left Rotation）

```
      x                y
     / \              / \
    a   y    -->     x   c
       / \          / \
      b   c        a   b

操作步骤：
1. 将y的左子树b作为x的右子树
2. 将x作为y的左子节点
3. 更新父节点指针
```

### 5.2 右旋转（Right Rotation）

```
      y                x
     / \              / \
    x   c    -->     a   y
   / \                  / \
  a   b                b   c

操作步骤：
1. 将x的右子树b作为y的左子树
2. 将y作为x的右子节点
3. 更新父节点指针
```

---

## 六、插入操作

**插入步骤：**

1. **按照BST的方式插入节点**（新节点初始为红色）
2. **修复红黑树性质**（如果违反性质）

**插入后的修复情况：**

### 情况1：新节点是根节点
- **处理**：将根节点改为黑色

### 情况2：父节点是黑色
- **处理**：不需要修复，树仍然满足性质

### 情况3：父节点是红色（需要修复）
- **情况3.1：叔叔节点是红色**
  - 将父节点和叔叔节点改为黑色
  - 将祖父节点改为红色
  - 将祖父节点作为当前节点，继续向上修复

- **情况3.2：叔叔节点是黑色（或NIL），当前节点是父节点的右子节点**
  - 将父节点作为当前节点
  - 对当前节点进行左旋转
  - 进入情况3.3

- **情况3.3：叔叔节点是黑色（或NIL），当前节点是父节点的左子节点**
  - 将父节点改为黑色
  - 将祖父节点改为红色
  - 对祖父节点进行右旋转

**示例：插入节点10**

```
初始树：
         13(黑)
        /    \
      8(红)   17(红)
     /  \     /  \
  1(黑) 11(黑) 15(黑) 25(黑)

插入10（红色）：
         13(黑)
        /    \
      8(红)   17(红)
     /  \     /  \
  1(黑) 11(黑) 15(黑) 25(黑)
         /
      10(红)  ← 新插入

情况分析：
- 10的父节点11是黑色 → 情况2，不需要修复 ✓
```

---

## 七、删除操作

**删除步骤：**

1. **按照BST的方式删除节点**
2. **如果删除的是红色节点**：不需要修复
3. **如果删除的是黑色节点**：需要修复（因为破坏了黑高）

**删除后的修复情况：**

### 情况1：删除节点是红色
- **处理**：直接删除，不需要修复

### 情况2：删除节点是黑色，替代节点是红色
- **处理**：将替代节点改为黑色

### 情况3：删除节点是黑色，替代节点也是黑色（需要修复）
- **情况3.1：兄弟节点是红色**
  - 将兄弟节点改为黑色
  - 将父节点改为红色
  - 对父节点进行左旋转（或右旋转）
  - 进入情况3.2、3.3或3.4

- **情况3.2：兄弟节点是黑色，兄弟节点的两个子节点都是黑色**
  - 将兄弟节点改为红色
  - 将父节点作为当前节点，继续向上修复

- **情况3.3：兄弟节点是黑色，兄弟节点的左子节点是红色，右子节点是黑色**
  - 将兄弟节点的左子节点改为黑色
  - 将兄弟节点改为红色
  - 对兄弟节点进行右旋转
  - 进入情况3.4

- **情况3.4：兄弟节点是黑色，兄弟节点的右子节点是红色**
  - 将兄弟节点的颜色改为父节点的颜色
  - 将父节点改为黑色
  - 将兄弟节点的右子节点改为黑色
  - 对父节点进行左旋转（或右旋转）

---

## 八、算法实现

```java
public class RedBlackTree {
    private static final boolean RED = true;
    private static final boolean BLACK = false;
    
    private class Node {
        int key;
        int value;
        Node left, right;
        boolean color;  // 颜色：true=红色，false=黑色
        
        Node(int key, int value) {
            this.key = key;
            this.value = value;
            this.color = RED;  // 新节点默认为红色
        }
    }
    
    private Node root;
    
    // 判断节点是否为红色
    private boolean isRed(Node node) {
        if (node == null) return false;  // NIL节点是黑色
        return node.color == RED;
    }
    
    // 左旋转
    private Node rotateLeft(Node h) {
        Node x = h.right;
        h.right = x.left;
        x.left = h;
        x.color = h.color;
        h.color = RED;
        return x;
    }
    
    // 右旋转
    private Node rotateRight(Node h) {
        Node x = h.left;
        h.left = x.right;
        x.right = h;
        x.color = h.color;
        h.color = RED;
        return x;
    }
    
    // 颜色翻转
    private void flipColors(Node h) {
        h.color = RED;
        h.left.color = BLACK;
        h.right.color = BLACK;
    }
    
    // 插入操作
    public void put(int key, int value) {
        root = put(root, key, value);
        root.color = BLACK;  // 根节点始终为黑色
    }
    
    private Node put(Node h, int key, int value) {
        // 插入新节点
        if (h == null) {
            return new Node(key, value);
        }
        
        // BST插入
        if (key < h.key) {
            h.left = put(h.left, key, value);
        } else if (key > h.key) {
            h.right = put(h.right, key, value);
        } else {
            h.value = value;  // 更新值
        }
        
        // 修复红黑树性质
        // 情况1：右子节点是红色，左子节点是黑色 → 左旋转
        if (isRed(h.right) && !isRed(h.left)) {
            h = rotateLeft(h);
        }
        
        // 情况2：左子节点是红色，左子节点的左子节点也是红色 → 右旋转
        if (isRed(h.left) && isRed(h.left.left)) {
            h = rotateRight(h);
        }
        
        // 情况3：左右子节点都是红色 → 颜色翻转
        if (isRed(h.left) && isRed(h.right)) {
            flipColors(h);
        }
        
        return h;
    }
    
    // 查找操作（与BST相同）
    public Integer get(int key) {
        return get(root, key);
    }
    
    private Integer get(Node node, int key) {
        if (node == null) return null;
        
        if (key < node.key) {
            return get(node.left, key);
        } else if (key > node.key) {
            return get(node.right, key);
        } else {
            return node.value;
        }
    }
    
    // 删除操作（简化版，完整实现较复杂）
    public void delete(int key) {
        if (!isRed(root.left) && !isRed(root.right)) {
            root.color = RED;  // 临时改为红色，便于统一处理
        }
        root = delete(root, key);
        if (root != null) {
            root.color = BLACK;
        }
    }
    
    private Node delete(Node h, int key) {
        if (key < h.key) {
            if (!isRed(h.left) && !isRed(h.left.left)) {
                h = moveRedLeft(h);
            }
            h.left = delete(h.left, key);
        } else {
            if (isRed(h.left)) {
                h = rotateRight(h);
            }
            if (key == h.key && h.right == null) {
                return null;
            }
            if (!isRed(h.right) && !isRed(h.right.left)) {
                h = moveRedRight(h);
            }
            if (key == h.key) {
                Node x = min(h.right);
                h.key = x.key;
                h.value = x.value;
                h.right = deleteMin(h.right);
            } else {
                h.right = delete(h.right, key);
            }
        }
        return balance(h);
    }
    
    // 辅助方法
    private Node moveRedLeft(Node h) {
        flipColors(h);
        if (isRed(h.right.left)) {
            h.right = rotateRight(h.right);
            h = rotateLeft(h);
            flipColors(h);
        }
        return h;
    }
    
    private Node moveRedRight(Node h) {
        flipColors(h);
        if (isRed(h.left.left)) {
            h = rotateRight(h);
            flipColors(h);
        }
        return h;
    }
    
    private Node balance(Node h) {
        if (isRed(h.right)) {
            h = rotateLeft(h);
        }
        if (isRed(h.left) && isRed(h.left.left)) {
            h = rotateRight(h);
        }
        if (isRed(h.left) && isRed(h.right)) {
            flipColors(h);
        }
        return h;
    }
    
    private Node min(Node h) {
        if (h.left == null) return h;
        return min(h.left);
    }
    
    private Node deleteMin(Node h) {
        if (h.left == null) return null;
        if (!isRed(h.left) && !isRed(h.left.left)) {
            h = moveRedLeft(h);
        }
        h.left = deleteMin(h.left);
        return balance(h);
    }
    
    // 中序遍历
    public void inOrder() {
        inOrder(root);
        System.out.println();
    }
    
    private void inOrder(Node node) {
        if (node == null) return;
        inOrder(node.left);
        System.out.print(node.key + "(" + (node.color ? "红" : "黑") + ") ");
        inOrder(node.right);
    }
    
    // 获取黑高
    public int getBlackHeight() {
        return getBlackHeight(root);
    }
    
    private int getBlackHeight(Node node) {
        if (node == null) return 0;
        int leftBH = getBlackHeight(node.left);
        int rightBH = getBlackHeight(node.right);
        int currentBH = (node.color == BLACK) ? 1 : 0;
        return currentBH + Math.max(leftBH, rightBH);
    }
}
```

---

## 九、性能分析

| 操作 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| **查找** | O(log n) | O(log n) | 保证平衡，高度为O(log n) |
| **插入** | O(log n) | O(log n) | 最多2次旋转 |
| **删除** | O(log n) | O(log n) | 最多3次旋转 |
| **旋转** | O(1) | O(1) | 常数时间操作 |

**优势：**
- 保证树的高度为O(log n)
- 所有操作的时间复杂度都是O(log n)
- 插入删除时旋转次数少（相比AVL树）
- 适合插入删除频繁的场景

**劣势：**
- 实现较复杂
- 不如AVL树严格平衡（查找效率略低）

---

## 十、应用场景

1. **Java集合类**
   - `TreeMap`：基于红黑树实现的有序映射
   - `TreeSet`：基于红黑树实现的有序集合

2. **C++标准库**
   - `std::map`：基于红黑树实现的有序映射
   - `std::set`：基于红黑树实现的有序集合

3. **Linux内核**
   - 进程调度器
   - 虚拟内存管理

4. **数据库系统**
   - 索引结构
   - 内存数据库

5. **其他应用**
   - 事件调度器
   - 区间树
   - 线段树

---

## 十一、红黑树的性质证明

**性质5的证明（黑高相同）：**

假设从根节点到任意叶子节点的路径上黑色节点数为k（黑高）。

- 最短路径：全部是黑色节点，长度为k
- 最长路径：红色和黑色交替，但红色节点不能连续，所以最多有k个红色节点
- 最长路径长度 ≤ 2k

因此，最长路径不超过最短路径的2倍，树的高度为O(log n)。

---

## 总结

```
✅ 红黑树 = 自平衡二叉排序树 + 颜色约束
✅ 5条性质：节点颜色、根节点、叶子节点、红色节点约束、黑高相同
✅ 近似平衡：最长路径 ≤ 2×最短路径
✅ 时间复杂度：所有操作都是O(log n)

📌 核心特点：
   - 不是严格平衡，但保证O(log n)高度
   - 插入删除时旋转次数少（相比AVL树）
   - 适合插入删除频繁的场景

💡 选择建议：
   - 插入删除频繁 → 红黑树
   - 查找为主 → AVL树
   - Java TreeMap/TreeSet → 红黑树
   - C++ std::map/std::set → 红黑树
```

---

**精简要点**: 红黑树是一种近似平衡的自平衡二叉排序树，通过5条颜色约束保证树的高度为O(log n)。相比AVL树，红黑树在插入删除时旋转次数更少，适合插入删除频繁的场景 🔴⚫✨

**代码参考**：[红黑树完整实现](../代码练习/05-树和二叉树/RedBlackTree.java)













