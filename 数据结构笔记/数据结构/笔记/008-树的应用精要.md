# 树的应用精要

> 树形结构在实际应用中的典型案例  
> 最后更新：2025年1月

## 📚 相关：[树精要](./007-树精要.md) | [代码练习](../代码练习/05-树和二叉树/) | [思维导图](./数据结构思维导图.md)

### 📝 代码文件说明
- **[UnionFind.c](../代码练习/05-树和二叉树/UnionFind.c)** - 并查集完整实现
- **[HuffmanTree.c](../代码练习/05-树和二叉树/HuffmanTree.c)** - 哈夫曼树和编码完整实现

---

## 📑 目录

- [一、并查集（Union-Find）](#一并查集union-find)
  - [1.1 基本概念](#11-基本概念)
  - [1.2 数据结构](#12-数据结构)
  - [1.3 基本操作](#13-基本操作)
  - [1.4 优化方法](#14-优化方法)
  - [1.5 应用场景](#15-应用场景)
  - [1.6 完整代码实现](#16-完整代码实现)
  - [1.7 时间复杂度分析](#17-时间复杂度分析)
- [二、哈夫曼树和哈夫曼编码](#二哈夫曼树和哈夫曼编码)
  - [2.1 基本概念](#21-基本概念)
  - [2.2 构造算法](#22-构造算法)
  - [2.3 哈夫曼编码](#23-哈夫曼编码)
  - [2.4 应用场景](#24-应用场景)
  - [2.5 完整代码实现](#25-完整代码实现)
  - [2.6 时间复杂度分析](#26-时间复杂度分析)
- [三、对比总结](#三对比总结)

---

## 一、并查集（Union-Find）

### 1.1 基本概念

**并查集（Union-Find）** 是一种树形数据结构，用于处理一些不交集的合并及查询问题。

**核心操作：**
- **Find（查找）**：确定元素属于哪个集合
- **Union（合并）**：将两个集合合并为一个集合

**应用场景：**
- 判断图中两个节点是否连通
- 网络连接问题
- 朋友圈问题
- 最小生成树（Kruskal算法）

**通俗理解：**
并查集就像"朋友圈"的概念：
- 初始时，每个人都是独立的朋友圈
- 当两个人成为朋友时，合并他们的朋友圈
- 查询两个人是否在同一个朋友圈

---

### 1.2 数据结构

**存储方式：** 使用数组表示树，每个元素存储其父节点的索引

```c
typedef struct {
    int *parent;   // parent[i]表示i的父节点
    int *rank;     // rank[i]表示以i为根的树的高度（可选，用于优化）
    int count;     // 连通分量的数量
    int size;      // 数组大小
} UnionFind;

void InitUF(UnionFind *uf, int n) {
    uf->parent = (int *)malloc(sizeof(int) * n);
    uf->rank = (int *)malloc(sizeof(int) * n);
    uf->count = n;
    uf->size = n;
    
    // 初始化：每个元素的父节点是自己
    for (int i = 0; i < n; i++) {
        uf->parent[i] = i;
        uf->rank[i] = 0;
    }
}
```

**数据结构图示：**

```
初始状态（5个元素）：
parent: [0, 1, 2, 3, 4]
rank:   [0, 0, 0, 0, 0]
count:  5

每个元素自成一个集合：
0  1  2  3  4

合并操作 union(0, 1)：
parent: [0, 0, 2, 3, 4]
rank:   [1, 0, 0, 0, 0]
count:  4

集合结构：
  0
 /
1

继续合并 union(2, 3), union(3, 4)：
parent: [0, 0, 2, 2, 2]
rank:   [1, 0, 2, 0, 0]
count:  2

集合结构：
  0        2
 /       / | \
1       3  4  5
```

---

### 1.3 基本操作

#### 1. Find操作（查找根节点）

**功能：** 查找元素所属集合的根节点

**实现：**

```c
// 基础版本（递归）
int Find(UnionFind *uf, int x) {
    if (uf->parent[x] != x) {
        return Find(uf, uf->parent[x]);  // 递归查找根节点
    }
    return x;
}

// 路径压缩优化版本（推荐）
int FindOptimized(UnionFind *uf, int x) {
    if (uf->parent[x] != x) {
        uf->parent[x] = FindOptimized(uf, uf->parent[x]);  // 路径压缩：直接指向根节点
    }
    return uf->parent[x];
}

// 迭代版本
int FindIterative(UnionFind *uf, int x) {
    int root = x;
    while (uf->parent[root] != root) {
        root = uf->parent[root];
    }
    // 路径压缩
    while (x != root) {
        int next = uf->parent[x];
        uf->parent[x] = root;
        x = next;
    }
    return root;
}
```

**查找过程图示：**

```
查找元素4的根节点：

优化前（需要向上遍历）：
    0
   /
  1
 /
2
/
3
/
4

查找路径：4 → 3 → 2 → 1 → 0

优化后（路径压缩）：
    0
   /|\|\
  1 2 3 4

查找路径：4 → 0（直接指向根节点）
```

**时间复杂度：**
- 基础版本：O(h)，h为树的高度
- 路径压缩后：接近O(1)（摊还时间复杂度）

#### 2. Union操作（合并集合）

**功能：** 将两个元素所在的集合合并

**实现：**

```c
// 基础版本
void Union(UnionFind *uf, int x, int y) {
    int rootX = Find(uf, x);
    int rootY = Find(uf, y);
    
    if (rootX != rootY) {
        uf->parent[rootX] = rootY;  // 将x的根节点指向y的根节点
        uf->count--;  // 连通分量减1
    }
}

// 按秩合并优化版本（推荐）
void UnionOptimized(UnionFind *uf, int x, int y) {
    int rootX = FindOptimized(uf, x);
    int rootY = FindOptimized(uf, y);
    
    if (rootX != rootY) {
        // 将高度小的树合并到高度大的树下
        if (uf->rank[rootX] < uf->rank[rootY]) {
            uf->parent[rootX] = rootY;
        } else if (uf->rank[rootX] > uf->rank[rootY]) {
            uf->parent[rootY] = rootX;
        } else {
            uf->parent[rootY] = rootX;
            uf->rank[rootX]++;  // 高度相同，合并后高度+1
        }
        uf->count--;
    }
}
```

**合并过程图示：**

```
合并前：
树A（高度2）    树B（高度1）
   0               4
  / \             /
 1   2           5
/
3

合并后（将B合并到A，因为A高度更大）：
     0
    /|\
   1 2 4
  /    /
 3    5
```

**时间复杂度：** O(h)，使用按秩合并后接近O(1)

#### 3. 判断是否连通

```c
int Connected(UnionFind *uf, int x, int y) {
    return FindOptimized(uf, x) == FindOptimized(uf, y);
}
```

**时间复杂度：** O(h)，使用路径压缩后接近O(1)

#### 4. 获取连通分量数量

```c
int GetCount(UnionFind *uf) {
    return uf->count;
}
```

**时间复杂度：** O(1)

---

### 1.4 优化方法

#### 1. 路径压缩（Path Compression）

**思想：** 在查找过程中，将路径上的所有节点直接连接到根节点

**效果：** 降低树的高度，提高后续查找效率

**优化前后对比：**

```
优化前：
    0
   /
  1
 /
2
/
3

优化后（查找3时）：
  0
 /|\
1 2 3
```

**实现：**
```c
int Find(UnionFind *uf, int x) {
    if (uf->parent[x] != x) {
        uf->parent[x] = Find(uf, uf->parent[x]);  // 递归压缩路径
    }
    return uf->parent[x];
}
```

#### 2. 按秩合并（Union by Rank）

**思想：** 总是将高度小的树合并到高度大的树下

**效果：** 避免树的高度增长过快

**优化前后对比：**

```
按秩合并示例：
树A（高度2）    树B（高度1）
   0               4
  / \             /
 1   2           5
/
3

合并后（将B合并到A）：
     0
    /|\
   1 2 4
  /    /
 3    5

如果不按秩合并，可能变成：
     4
    /
   0
  /|\
 1 2 5
/
3
（高度更大，查找更慢）
```

**实现：**
```c
void Union(UnionFind *uf, int x, int y) {
    int rootX = Find(uf, x);
    int rootY = Find(uf, y);
    
    if (rootX != rootY) {
        if (uf->rank[rootX] < uf->rank[rootY]) {
            uf->parent[rootX] = rootY;
        } else if (uf->rank[rootX] > uf->rank[rootY]) {
            uf->parent[rootY] = rootX;
        } else {
            uf->parent[rootY] = rootX;
            uf->rank[rootX]++;
        }
        uf->count--;
    }
}
```

#### 3. 两种优化结合使用

**同时使用路径压缩和按秩合并：**
- 路径压缩：降低查找时的树高度
- 按秩合并：降低合并时的树高度增长

**效果：** 摊还时间复杂度接近O(1)

---

### 1.5 应用场景

#### 1. 判断图的连通性

**问题：** 给定一个无向图，判断两个节点是否连通

**示例：**
```
图：
0---1   2
|   |   |
3---4   5

判断0和4是否连通：connected(0, 4) = true
判断1和5是否连通：connected(1, 5) = false
```

**代码：**
```c
UnionFind uf;
InitUF(&uf, 6);
UnionOptimized(&uf, 0, 1);
UnionOptimized(&uf, 0, 3);
UnionOptimized(&uf, 1, 4);
UnionOptimized(&uf, 3, 4);
UnionOptimized(&uf, 2, 5);

printf("%d\n", Connected(&uf, 0, 4));  // 1 (true)
printf("%d\n", Connected(&uf, 1, 5));  // 0 (false)
```

#### 2. 朋友圈问题

**问题：** 有n个人，给出m对朋友关系，问有多少个朋友圈

**示例：**
```
朋友关系：(0,1), (2,3), (4,5), (1,4)

初始：6个朋友圈 {0}, {1}, {2}, {3}, {4}, {5}
合并后：2个朋友圈 {0,1,4,5}, {2,3}
```

**代码：**
```c
int friendships[][2] = {{0,1}, {2,3}, {4,5}, {1,4}};
UnionFind uf;
InitUF(&uf, 6);

for (int i = 0; i < 4; i++) {
    UnionOptimized(&uf, friendships[i][0], friendships[i][1]);
}

printf("朋友圈数量：%d\n", GetCount(&uf));  // 2
```

#### 3. 最小生成树（Kruskal算法）

**问题：** 使用Kruskal算法求最小生成树时，需要判断边是否会形成环

**方法：** 使用并查集判断两个顶点是否在同一个连通分量中

**算法步骤：**
1. 将所有边按权值从小到大排序
2. 依次选择边，如果边的两个顶点不在同一连通分量中，则加入最小生成树
3. 使用并查集判断是否形成环

**代码：**
```c
// 边结构
typedef struct {
    int from, to, weight;
} Edge;

// 比较函数
int compareEdges(const void *a, const void *b) {
    return ((Edge *)a)->weight - ((Edge *)b)->weight;
}

// Kruskal算法片段
void Kruskal(Edge *edges, int numEdges, int numVertices) {
    UnionFind uf;
    InitUF(&uf, numVertices);
    
    // 按权值排序
    qsort(edges, numEdges, sizeof(Edge), compareEdges);
    
    for (int i = 0; i < numEdges; i++) {
        if (!Connected(&uf, edges[i].from, edges[i].to)) {
            UnionOptimized(&uf, edges[i].from, edges[i].to);
            // 加入最小生成树
            // AddToMST(edges[i]);
        }
    }
}
```

#### 4. 岛屿数量问题

**问题：** 给定一个二维网格，'1'表示陆地，'0'表示水，计算岛屿数量

**方法：** 使用并查集合并相邻的陆地

**代码：**
```c
int NumIslands(char **grid, int gridSize, int *gridColSize) {
    if (gridSize == 0) return 0;
    
    int m = gridSize;
    int n = gridColSize[0];
    UnionFind uf;
    InitUF(&uf, m * n);
    int count = 0;
    
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            if (grid[i][j] == '1') {
                count++;
                // 合并相邻的陆地
                if (i > 0 && grid[i-1][j] == '1') {
                    UnionOptimized(&uf, i*n+j, (i-1)*n+j);
                }
                if (j > 0 && grid[i][j-1] == '1') {
                    UnionOptimized(&uf, i*n+j, i*n+j-1);
                }
            }
        }
    }
    
    // 注意：这里的计算方式需要根据具体UnionFind实现调整
    // 简单的并查集可能无法直接通过 uf.count 得到岛屿数，因为初始化时所有点都是独立的
    // 正确做法是：遍历所有为'1'的点，看有多少个根节点
    // 或者维护一个专门的岛屿计数
    
    return count; // 这是一个简化示例，实际逻辑需完善
}
```

---

### 1.6 完整代码实现

```c
typedef struct {
    int *parent;
    int *rank;
    int count;
    int size;
} UnionFind;

void InitUF(UnionFind *uf, int n) {
    uf->parent = (int *)malloc(sizeof(int) * n);
    uf->rank = (int *)malloc(sizeof(int) * n);
    uf->count = n;
    uf->size = n;
    for (int i = 0; i < n; i++) {
        uf->parent[i] = i;
        uf->rank[i] = 0;
    }
}

int Find(UnionFind *uf, int x) {
    if (uf->parent[x] != x) {
        uf->parent[x] = Find(uf, uf->parent[x]);
    }
    return uf->parent[x];
}

void Union(UnionFind *uf, int x, int y) {
    int rootX = Find(uf, x);
    int rootY = Find(uf, y);
    
    if (rootX != rootY) {
        if (uf->rank[rootX] < uf->rank[rootY]) {
            uf->parent[rootX] = rootY;
        } else if (uf->rank[rootX] > uf->rank[rootY]) {
            uf->parent[rootY] = rootX;
        } else {
            uf->parent[rootY] = rootX;
            uf->rank[rootX]++;
        }
        uf->count--;
    }
}

int Connected(UnionFind *uf, int x, int y) {
    return Find(uf, x) == Find(uf, y);
}

int GetCount(UnionFind *uf) {
    return uf->count;
}
```

---

### 1.7 时间复杂度分析

| 操作 | 基础版本 | 路径压缩 | 按秩合并 | 两种优化结合 |
|------|---------|---------|---------|------------|
| **Find** | O(h) | O(log n) | O(h) | O(α(n)) ≈ O(1) |
| **Union** | O(h) | O(log n) | O(h) | O(α(n)) ≈ O(1) |
| **Connected** | O(h) | O(log n) | O(h) | O(α(n)) ≈ O(1) |

**说明：**
- h：树的高度
- α(n)：阿克曼函数的反函数，增长极慢，实际应用中可视为常数
- 使用两种优化后，摊还时间复杂度接近O(1)

**空间复杂度：** O(n)

---

## 二、哈夫曼树和哈夫曼编码

### 2.1 基本概念

**哈夫曼树（Huffman Tree）** 是一种带权路径长度最短的二叉树，也称为最优二叉树。

**相关术语：**
- **路径长度**：从根到某节点的路径上经过的边数
- **节点的权**：节点的重要程度或出现频率
- **带权路径长度**：节点的路径长度 × 节点的权
- **树的带权路径长度（WPL）**：所有叶子节点的带权路径长度之和

**示例：**

```
节点权值：A(5), B(3), C(2), D(1)

普通二叉树（WPL = 5×2 + 3×2 + 2×2 + 1×2 = 22）：
        *
       / \
      *   *
     / \ / \
    A  B C  D

哈夫曼树（WPL = 5×1 + 3×2 + 2×3 + 1×3 = 20）：
        *
       / \
      A   *
         / \
        *   C
       / \
      B   D

WPL更小，更优！
```

**通俗理解：**
- 哈夫曼树就像"最短路径树"
- 权值大的节点（出现频率高）放在离根近的地方
- 权值小的节点（出现频率低）放在离根远的地方
- 这样总的带权路径长度最小

---

### 2.2 构造算法

**哈夫曼算法（贪心算法）：**

1. 将n个节点看作n棵只有根节点的二叉树，组成森林F
2. 从F中选择两棵根节点权值最小的树，合并成一棵新树
   - 新树的根节点权值 = 两棵子树根节点权值之和
   - 左子树为权值较小的树，右子树为权值较大的树
3. 将新树加入F，删除原来的两棵树
4. 重复步骤2和3，直到F中只剩一棵树

**构造示例：**

```
初始：A(5), B(3), C(2), D(1)

步骤1：选择C(2)和D(1)，合并
       3
      / \
     C   D
F = {A(5), B(3), 新树(3)}

步骤2：选择B(3)和新树(3)，合并
       6
      / \
     B   3
        / \
       C   D
F = {A(5), 新树(6)}

步骤3：选择A(5)和新树(6)，合并
       11
      /  \
     A    6
         / \
        B   3
           / \
          C   D

完成！这就是哈夫曼树
```

**算法实现：**

```c
// 节点结构
typedef struct HuffmanNode {
    char data;              // 字符
    int weight;             // 权值（频率）
    struct HuffmanNode *left;   // 左子树
    struct HuffmanNode *right;  // 右子树
} HuffmanNode;

// 创建新节点
HuffmanNode* CreateHuffmanNode(char data, int weight) {
    HuffmanNode *node = (HuffmanNode*)malloc(sizeof(HuffmanNode));
    node->data = data;
    node->weight = weight;
    node->left = NULL;
    node->right = NULL;
    return node;
}

// 构造哈夫曼树 (简化版，假设有一个优先队列实现)
HuffmanNode* BuildHuffmanTree(char *data, int *weights, int n) {
    // 1. 创建n个叶子节点，加入优先队列
    // PriorityQueue pq;
    // for (int i = 0; i < n; i++) {
    //     Push(&pq, CreateHuffmanNode(data[i], weights[i]));
    // }
    
    // 2. 合并节点直到只剩一棵树
    // while (Size(&pq) > 1) {
    //     HuffmanNode *left = Pop(&pq);   // 权值最小的节点
    //     HuffmanNode *right = Pop(&pq);  // 权值第二小的节点
    //     
    //     // 创建新节点，权值为两节点权值之和
    //     HuffmanNode *parent = CreateHuffmanNode('\0', left->weight + right->weight);
    //     parent->left = left;
    //     parent->right = right;
    //     
    //     Push(&pq, parent);
    // }
    
    // return Pop(&pq);  // 返回根节点
    return NULL; // 占位
}
```

**时间复杂度：** O(n log n)  
**空间复杂度：** O(n)

**分析：**
- 需要n-1次合并操作
- 每次合并需要从优先队列中取出两个最小元素：O(log n)
- 总时间复杂度：O(n log n)

---

### 2.3 哈夫曼编码

**哈夫曼编码** 是一种可变长度编码，用于数据压缩。

**编码规则：**
- 左分支编码为0，右分支编码为1
- 从根到叶子节点的路径上的编码序列就是该叶子节点的哈夫曼编码

**编码示例：**

```
哈夫曼树：
       11
      /  \
     A    6
         / \
        B   3
           / \
          C   D

哈夫曼编码：
A: 0
B: 10
C: 110
D: 111

编码特点：
- 前缀编码：任何字符的编码都不是另一个字符编码的前缀
- 可变长度：出现频率高的字符编码短，频率低的编码长
- 最优编码：平均编码长度最短
```

**编码过程：**

```c
// 生成哈夫曼编码表
void GenerateCodes(HuffmanNode *node, char *code, int depth) {
    if (node == NULL) {
        return;
    }
    
    // 叶子节点，记录编码
    if (node->left == NULL && node->right == NULL) {
        code[depth] = '\0';
        printf("Character: %c, Code: %s\n", node->data, code);
        return;
    }
    
    // 左分支编码0
    code[depth] = '0';
    GenerateCodes(node->left, code, depth + 1);
    
    // 右分支编码1
    code[depth] = '1';
    GenerateCodes(node->right, code, depth + 1);
}

// 解码过程
void Decode(char *encodedStr, HuffmanNode *root) {
    HuffmanNode *current = root;
    for (int i = 0; encodedStr[i] != '\0'; i++) {
        if (encodedStr[i] == '0') {
            current = current->left;
        } else {
            current = current->right;
        }
        
        // 到达叶子节点，解码一个字符
        if (current->left == NULL && current->right == NULL) {
            printf("%c", current->data);
            current = root;  // 重置到根节点
        }
    }
}
```

**解码过程：**

```java
// 根据编码序列解码
public String decode(String encoded, HuffmanNode root) {
    StringBuilder result = new StringBuilder();
    HuffmanNode current = root;
    
    for (char bit : encoded.toCharArray()) {
        if (bit == '0') {
            current = current.left;
        } else {
            current = current.right;
        }
        
        // 到达叶子节点，解码一个字符
        if (current.left == null && current.right == null) {
            result.append(current.data);
            current = root;  // 重置到根节点
        }
    }
    
    return result.toString();
}
```

**编码解码示例：**

```
原始文本：AABBCDDD
字符频率：A(2), B(2), C(1), D(3)

哈夫曼编码：
A: 0
B: 10
C: 110
D: 111

编码过程：
A → 0
A → 0
B → 10
B → 10
C → 110
D → 111
D → 111
D → 111

编码结果：00101010110111111111

解码过程：
00101010110111111111
0 → A（回到根）
0 → A（回到根）
10 → B（回到根）
10 → B（回到根）
110 → C（回到根）
111 → D（回到根）
111 → D（回到根）
111 → D（回到根）

解码结果：AABBCDDD
```

---

### 2.4 应用场景

#### 1. 数据压缩

**原理：** 使用哈夫曼编码，出现频率高的字符用短编码，频率低的用长编码

**压缩效果：**
```
原始数据：AABBCDDD
字符频率：A(2), B(2), C(1), D(3)

固定长度编码（2位）：
A: 00, B: 01, C: 10, D: 11
编码后：00 00 01 01 10 11 11 11 = 16位

哈夫曼编码：
A: 0, B: 10, C: 110, D: 111
编码后：0 0 10 10 110 111 111 111 = 14位

压缩率：14/16 = 87.5%
```

#### 2. 文件压缩

**应用：** ZIP、GZIP等压缩算法的基础

**优势：**
- 无损压缩
- 压缩率高
- 编码解码速度快

**实现步骤：**
1. 统计文件中每个字符的出现频率
2. 构造哈夫曼树
3. 生成哈夫曼编码表
4. 将文件内容编码并保存
5. 保存编码表和编码后的数据

#### 3. 通信编码

**应用：** 网络传输中的数据编码

**优势：**
- 减少传输数据量
- 提高传输效率

#### 4. 图像压缩

**应用：** JPEG图像压缩的一部分

**原理：** 对图像数据进行哈夫曼编码，减少存储空间

---

### 2.5 完整代码实现

```c
// 完整实现请参考 HuffmanTree.c
```

---

### 2.6 时间复杂度分析

| 操作 | 时间复杂度 | 说明 |
|------|----------|------|
| **构造哈夫曼树** | O(n log n) | n个节点，每次合并O(log n) |
| **生成编码表** | O(n) | 遍历所有叶子节点 |
| **编码** | O(m) | m为文本长度 |
| **解码** | O(m) | m为编码长度 |

**空间复杂度：** O(n)

**分析：**
- 构造树：需要n-1次合并，每次O(log n)
- 编码表：存储n个字符的编码
- 树结构：O(n)个节点

---

## 三、对比总结

### 3.1 并查集 vs 哈夫曼树

| 特性 | 并查集 | 哈夫曼树 |
|------|--------|---------|
| **数据结构** | 树形结构（数组实现） | 二叉树 |
| **主要用途** | 集合合并和查询 | 数据压缩 |
| **核心操作** | Find、Union | 构造、编码、解码 |
| **时间复杂度** | O(α(n)) ≈ O(1) | O(n log n) |
| **应用场景** | 图算法、连通性 | 文件压缩、通信编码 |
| **优化方法** | 路径压缩、按秩合并 | 优先队列 |

### 3.2 学习要点

#### 并查集 ⭐⭐⭐

**必须掌握：**
1. Find和Union操作的实现
2. 路径压缩和按秩合并优化
3. 在Kruskal算法中的应用

**重要理解：**
1. 并查集的树形结构表示
2. 优化后的时间复杂度分析
3. 实际应用场景

#### 哈夫曼树 ⭐⭐⭐

**必须掌握：**
1. 哈夫曼树的构造算法
2. 哈夫曼编码的生成
3. 编码和解码的实现

**重要理解：**
1. 带权路径长度的概念
2. 贪心算法的应用
3. 前缀编码的特性

### 3.3 常见考点

#### 并查集

1. **时间复杂度分析**
   - 基础版本：O(n)
   - 优化后：O(α(n)) ≈ O(1)

2. **应用场景**
   - 图的连通性判断
   - 最小生成树算法
   - 朋友圈问题

3. **优化方法**
   - 路径压缩的实现
   - 按秩合并的实现

#### 哈夫曼树

1. **构造过程**
   - 每次选择两个权值最小的节点
   - 合并成新节点
   - 重复直到只剩一棵树

2. **编码特点**
   - 前缀编码
   - 可变长度
   - 最优编码

3. **应用场景**
   - 数据压缩
   - 文件压缩
   - 通信编码

---

## 总结

```
✅ 并查集 = 树形结构 + 快速查找 + 合并操作
   - 核心：Find、Union操作
   - 优化：路径压缩、按秩合并
   - 应用：图算法、连通性判断

✅ 哈夫曼树 = 最优二叉树 + 数据压缩
   - 核心：带权路径长度最短
   - 算法：贪心算法
   - 应用：文件压缩、通信编码

📌 关键区别：
   - 并查集：解决集合合并查询问题
   - 哈夫曼树：解决数据压缩问题

💡 学习建议：
   - 并查集：重点掌握优化方法
   - 哈夫曼树：重点掌握构造和编码过程
```

---

**精简要点**: 并查集和哈夫曼树都是树形结构的典型应用。并查集解决集合问题，哈夫曼树解决压缩问题。掌握它们的实现和应用是理解树结构的关键 🌲✨

**代码参考**：
- [并查集完整实现](../代码练习/05-树和二叉树/UnionFind.c)
- [哈夫曼树和编码完整实现](../代码练习/05-树和二叉树/HuffmanTree.c)

