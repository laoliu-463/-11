# B树和B+树精要

> B树和B+树核心知识  
> 最后更新：2025年1月

## 📚 相关：[树精要](./007-树精要.md) | [查找精要](./013-查找精要.md) | [代码练习](../代码练习/05-树和二叉树/) | [思维导图](./数据结构思维导图.md)

---

## 📑 目录

- [一、B树的基本概念](#一b树的基本概念)
- [二、B树的性质](#二b树的性质)
- [三、B树的操作](#三b树的操作)
- [四、B+树的基本概念](#四b树的基本概念)
- [五、B+树的性质](#五b树的性质)
- [六、B+树的操作](#六b树的操作)
- [七、B树 vs B+树](#七b树-vs-b树)
- [八、算法实现](#八算法实现)
- [九、性能分析](#九性能分析)
- [十、应用场景](#十应用场景)

---

## 一、B树的基本概念

### 1.1 B树的定义

**B树（B-Tree）** 是一种多路平衡搜索树，用于在磁盘等外部存储设备上组织数据。

**B树的特点：**
- 每个节点可以有多个子节点（多路）
- 所有叶子节点在同一层（平衡）
- 节点中存储多个关键字（有序）
- 适合磁盘等外部存储设备

### 1.2 B树的阶数

**m阶B树**：每个节点最多有m个子节点，最多有m-1个关键字。

**B树必须满足以下性质：**

1. **根节点**：至少有1个关键字（除非树为空）
2. **非根节点**：至少有⌈m/2⌉-1个关键字，最多有m-1个关键字
3. **子节点数**：非根节点至少有⌈m/2⌉个子节点，最多有m个子节点
4. **关键字有序**：节点内的关键字按升序排列
5. **子树分离**：第i个关键字的值大于第i个子树的所有关键字，小于第i+1个子树的所有关键字
6. **叶子节点**：所有叶子节点在同一层

### 1.3 B树示例

```
3阶B树（m=3）示例：

        [50]
       /    \
   [20,30]  [70,80]
   /  |  \   /  |  \
[10] [25] [40] [60] [75] [90]

特点：
- 每个节点最多2个关键字（m-1=2）
- 每个节点最多3个子节点（m=3）
- 非根节点至少有1个关键字（⌈m/2⌉-1=1）
- 所有叶子节点在同一层
```

---

## 二、B树的性质

### 2.1 节点结构

**B树节点包含：**
- **关键字数组**：存储关键字（有序）
- **子节点指针数组**：指向子节点
- **关键字数量**：当前节点包含的关键字个数
- **是否为叶子节点**：标记节点类型

### 2.2 高度分析

**B树的高度：**

对于n个关键字的m阶B树：
- **最小高度**：h ≥ log_m(n+1)
- **最大高度**：h ≤ log_{⌈m/2⌉}((n+1)/2) + 1

**示例：**
- 1000个关键字的3阶B树，高度约为3-4层
- 1000个关键字的5阶B树，高度约为2-3层

### 2.3 关键字数量范围

**对于m阶B树：**
- **根节点**：1 ≤ 关键字数 ≤ m-1
- **非根节点**：⌈m/2⌉-1 ≤ 关键字数 ≤ m-1
- **子节点数**：⌈m/2⌉ ≤ 子节点数 ≤ m

---

## 三、B树的操作

### 3.1 查找操作

**查找步骤：**

1. 从根节点开始
2. 在当前节点中查找关键字（可以使用折半查找）
3. 如果找到，返回节点和位置
4. 如果未找到：
   - 如果关键字 < 第一个关键字，在第一个子树中查找
   - 如果关键字 > 最后一个关键字，在最后一个子树中查找
   - 否则，在第i和i+1个关键字之间的子树中查找
5. 重复步骤2-4，直到找到或到达叶子节点

**时间复杂度：** O(log n)
- 每次查找最多访问h个节点（h为树的高度）
- 每个节点内可以使用折半查找，时间复杂度O(log m)

### 3.2 插入操作

**插入步骤：**

1. **查找插入位置**：找到应该插入的叶子节点
2. **插入关键字**：在叶子节点中插入关键字（保持有序）
3. **检查节点是否溢出**：
   - 如果关键字数 ≤ m-1，插入完成
   - 如果关键字数 > m-1，需要分裂节点

**节点分裂：**

1. 将节点分为两部分：
   - 左部分：前⌈m/2⌉-1个关键字
   - 中间关键字：第⌈m/2⌉个关键字
   - 右部分：后m-⌈m/2⌉个关键字

2. 将中间关键字提升到父节点

3. 将右部分作为新节点，连接到父节点

4. 如果父节点也溢出，递归向上分裂

**示例：3阶B树插入**

```
初始树（3阶）：
        [50]
       /    \
   [20,30]  [70]

插入25：
        [50]
       /    \
   [20,25,30]  [70]  ← 节点溢出

分裂节点：
        [25,50]
       /   |   \
   [20] [30] [70]

中间关键字25提升到父节点
```

### 3.3 删除操作

**删除步骤：**

1. **查找要删除的关键字**
2. **删除关键字**：
   - **情况1：删除的是叶子节点的关键字**
     - 直接删除
     - 如果节点关键字数 < ⌈m/2⌉-1，需要合并或借用
   
   - **情况2：删除的是非叶子节点的关键字**
     - 用前驱或后继关键字替换
     - 前驱：左子树的最大关键字
     - 后继：右子树的最小关键字
     - 删除前驱或后继关键字（递归）

3. **处理节点下溢**：
   - **借用**：从兄弟节点借一个关键字
   - **合并**：与兄弟节点合并

**删除示例：3阶B树删除**

```
初始树：
        [25,50]
       /   |   \
   [20] [30] [70]

删除25：
- 25是非叶子节点关键字
- 用前驱20或后继30替换
- 假设用后继30替换：
        [30,50]
       /   |   \
   [20] [30] [70]  ← 删除叶子节点的30
```

---

## 四、B+树的基本概念

### 4.1 B+树的定义

**B+树（B+ Tree）** 是B树的一种变体，主要用于数据库索引。

**B+树与B树的区别：**

1. **关键字存储**：
   - B树：关键字存储在内部节点和叶子节点
   - B+树：关键字只存储在叶子节点，内部节点只存储索引

2. **叶子节点链接**：
   - B树：叶子节点不链接
   - B+树：叶子节点通过指针链接成有序链表

3. **查找方式**：
   - B树：可以在内部节点找到数据
   - B+树：必须到叶子节点才能找到数据

### 4.2 B+树的结构

```
3阶B+树示例：

        [50]          ← 内部节点（索引）
       /    \
   [20,30]  [70]      ← 内部节点（索引）
   /  |  \   /  |  \
[10,20] [25,30] [40] [60,70] [75,90]  ← 叶子节点（数据）
  ↓      ↓      ↓      ↓      ↓
 链表   链表   链表   链表   链表

特点：
- 内部节点只存储索引（关键字）
- 叶子节点存储实际数据
- 叶子节点通过指针链接成有序链表
```

---

## 五、B+树的性质

### 5.1 B+树的性质

**m阶B+树必须满足：**

1. **根节点**：至少有1个关键字（除非树为空）
2. **非根内部节点**：至少有⌈m/2⌉个关键字，最多有m个关键字
3. **叶子节点**：至少有⌈m/2⌉个关键字，最多有m个关键字
4. **关键字有序**：节点内的关键字按升序排列
5. **子树分离**：第i个关键字的值大于等于第i个子树的所有关键字，小于第i+1个子树的所有关键字
6. **叶子节点链接**：所有叶子节点通过指针链接成有序链表

### 5.2 B+树的优势

**相比B树的优势：**

1. **范围查询高效**：叶子节点链接成链表，范围查询只需遍历链表
2. **内部节点更小**：内部节点只存储索引，可以存储更多关键字
3. **顺序访问高效**：通过叶子节点链表可以顺序访问所有数据
4. **更适合数据库**：数据库索引通常需要范围查询和顺序访问

---

## 六、B+树的操作

### 6.1 查找操作

**查找步骤：**

1. 从根节点开始
2. 在当前节点中查找关键字
3. 根据关键字范围，选择对应的子树
4. 重复步骤2-3，直到到达叶子节点
5. 在叶子节点中查找关键字

**范围查询：**

1. 找到范围的起始关键字所在的叶子节点
2. 从该叶子节点开始，沿着链表向后遍历
3. 直到找到范围的结束关键字

### 6.2 插入操作

**插入步骤：**

1. **查找插入位置**：找到应该插入的叶子节点
2. **插入关键字**：在叶子节点中插入关键字（保持有序）
3. **检查节点是否溢出**：
   - 如果关键字数 ≤ m，插入完成
   - 如果关键字数 > m，需要分裂节点

**节点分裂：**

1. 将节点分为两部分：
   - 左部分：前⌈m/2⌉个关键字
   - 右部分：后m-⌈m/2⌉+1个关键字

2. 将右部分的第一个关键字复制到父节点（作为索引）

3. 将右部分作为新节点，连接到父节点

4. 更新叶子节点链表

5. 如果父节点也溢出，递归向上分裂

### 6.3 删除操作

**删除步骤：**

1. **查找要删除的关键字**：在叶子节点中查找
2. **删除关键字**：从叶子节点中删除
3. **处理节点下溢**：
   - **借用**：从兄弟节点借一个关键字
   - **合并**：与兄弟节点合并
   - 如果合并，需要从父节点删除对应的索引关键字

---

## 七、B树 vs B+树

| 特性 | B树 | B+树 |
|------|-----|------|
| **关键字存储位置** | 内部节点和叶子节点 | 只存储在叶子节点 |
| **内部节点作用** | 存储关键字和数据 | 只存储索引 |
| **叶子节点链接** | 无 | 有（有序链表） |
| **查找方式** | 可以在内部节点找到 | 必须到叶子节点 |
| **范围查询** | 效率较低 | 效率高（链表遍历） |
| **顺序访问** | 效率较低 | 效率高（链表遍历） |
| **空间利用率** | 较低 | 较高（内部节点更小） |
| **适用场景** | 文件系统 | 数据库索引 |

**选择建议：**
- **数据库索引** → B+树（范围查询、顺序访问）
- **文件系统** → B树（可以直接在内部节点找到数据）
- **需要范围查询** → B+树
- **单点查询为主** → B树或B+树都可以

---

## 八、算法实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// B树节点
typedef struct BTreeNode {
    int *keys;              // 关键字数组
    struct BTreeNode **children; // 子节点数组
    int keyCount;           // 关键字数量
    bool isLeaf;            // 是否为叶子节点
    int m;                  // B树的阶数
} BTreeNode;

// B树
typedef struct {
    BTreeNode *root;
    int m;  // B树的阶数
} BTree;

// 创建B树节点
BTreeNode* CreateNode(int m, bool isLeaf) {
    BTreeNode *node = (BTreeNode *)malloc(sizeof(BTreeNode));
    node->m = m;
    node->isLeaf = isLeaf;
    node->keyCount = 0;
    node->keys = (int *)malloc((m - 1) * sizeof(int));
    node->children = (BTreeNode **)malloc(m * sizeof(BTreeNode *));
    return node;
}

// 初始化B树
void InitBTree(BTree *tree, int m) {
    tree->root = NULL;
    tree->m = m;
}

// 查找操作递归函数
BTreeNode* SearchRecursive(BTreeNode *node, int key) {
    if (node == NULL) return NULL;
    
    int i = 0;
    // 在当前节点中查找关键字
    while (i < node->keyCount && key > node->keys[i]) {
        i++;
    }
    
    // 如果找到关键字
    if (i < node->keyCount && key == node->keys[i]) {
        return node;
    }
    
    // 如果是叶子节点且未找到，返回NULL
    if (node->isLeaf) {
        return NULL;
    }
    
    // 在对应的子树中查找
    return SearchRecursive(node->children[i], key);
}

// 查找操作
BTreeNode* Search(BTree *tree, int key) {
    return SearchRecursive(tree->root, key);
}

// 分裂子节点
void SplitChild(BTreeNode *parent, int index, BTreeNode *child) {
    int m = parent->m;
    BTreeNode *newChild = CreateNode(m, child->isLeaf);
    newChild->keyCount = m / 2 - 1;
    
    // 复制后一半关键字到新节点
    for (int j = 0; j < m / 2 - 1; j++) {
        newChild->keys[j] = child->keys[j + m / 2];
    }
    
    // 如果不是叶子节点，复制子节点
    if (!child->isLeaf) {
        for (int j = 0; j < m / 2; j++) {
            newChild->children[j] = child->children[j + m / 2];
        }
    }
    
    child->keyCount = m / 2 - 1;
    
    // 将中间关键字提升到父节点
    for (int j = parent->keyCount; j > index; j--) {
        parent->children[j + 1] = parent->children[j];
    }
    parent->children[index + 1] = newChild;
    
    for (int j = parent->keyCount - 1; j >= index; j--) {
        parent->keys[j + 1] = parent->keys[j];
    }
    parent->keys[index] = child->keys[m / 2 - 1];
    parent->keyCount++;
}

// 在非满节点中插入关键字
void InsertNonFull(BTreeNode *node, int key) {
    int i = node->keyCount - 1;
    int m = node->m;
    
    if (node->isLeaf) {
        // 叶子节点：插入关键字并保持有序
        while (i >= 0 && node->keys[i] > key) {
            node->keys[i + 1] = node->keys[i];
            i--;
        }
        node->keys[i + 1] = key;
        node->keyCount++;
    } else {
        // 内部节点：找到应该插入的子树
        while (i >= 0 && node->keys[i] > key) {
            i--;
        }
        i++;
        
        // 如果子树已满，先分裂
        if (node->children[i]->keyCount == m - 1) {
            SplitChild(node, i, node->children[i]);
            if (node->keys[i] < key) {
                i++;
            }
        }
        InsertNonFull(node->children[i], key);
    }
}

// 插入操作
void Insert(BTree *tree, int key) {
    // 如果树为空，创建根节点
    if (tree->root == NULL) {
        tree->root = CreateNode(tree->m, true);
        tree->root->keys[0] = key;
        tree->root->keyCount = 1;
    } else {
        // 如果根节点已满，需要分裂
        if (tree->root->keyCount == tree->m - 1) {
            BTreeNode *newRoot = CreateNode(tree->m, false);
            newRoot->children[0] = tree->root;
            SplitChild(newRoot, 0, tree->root);
            
            // 确定插入位置
            int i = 0;
            if (newRoot->keys[0] < key) {
                i++;
            }
            InsertNonFull(newRoot->children[i], key);
            tree->root = newRoot;
        } else {
            InsertNonFull(tree->root, key);
        }
    }
}

// 辅助方法：查找关键字索引
int FindKey(BTreeNode *node, int key) {
    int index = 0;
    while (index < node->keyCount && node->keys[index] < key) {
        index++;
    }
    return index;
}

// 辅助方法：从叶子节点删除
void RemoveFromLeaf(BTreeNode *node, int index) {
    for (int i = index + 1; i < node->keyCount; i++) {
        node->keys[i - 1] = node->keys[i];
    }
    node->keyCount--;
}

// 辅助方法：获取前驱
int GetPredecessor(BTreeNode *node, int index) {
    BTreeNode *current = node->children[index];
    while (!current->isLeaf) {
        current = current->children[current->keyCount];
    }
    return current->keys[current->keyCount - 1];
}

// 辅助方法：获取后继
int GetSuccessor(BTreeNode *node, int index) {
    BTreeNode *current = node->children[index + 1];
    while (!current->isLeaf) {
        current = current->children[0];
    }
    return current->keys[0];
}

// 辅助方法：合并节点
void Merge(BTreeNode *node, int index) {
    BTreeNode *child = node->children[index];
    BTreeNode *sibling = node->children[index + 1];
    int m = node->m;
    
    child->keys[m / 2 - 1] = node->keys[index];
    
    for (int i = 0; i < sibling->keyCount; i++) {
        child->keys[i + m / 2] = sibling->keys[i];
    }
    
    if (!child->isLeaf) {
        for (int i = 0; i <= sibling->keyCount; i++) {
            child->children[i + m / 2] = sibling->children[i];
        }
    }
    
    for (int i = index + 1; i < node->keyCount; i++) {
        node->keys[i - 1] = node->keys[i];
    }
    
    for (int i = index + 2; i <= node->keyCount; i++) {
        node->children[i - 1] = node->children[i];
    }
    
    child->keyCount += sibling->keyCount + 1;
    node->keyCount--;
    
    free(sibling->keys);
    free(sibling->children);
    free(sibling);
}

// 辅助方法：从前一个兄弟借用
void BorrowFromPrev(BTreeNode *node, int index) {
    BTreeNode *child = node->children[index];
    BTreeNode *sibling = node->children[index - 1];
    
    for (int i = child->keyCount - 1; i >= 0; i--) {
        child->keys[i + 1] = child->keys[i];
    }
    
    if (!child->isLeaf) {
        for (int i = child->keyCount; i >= 0; i--) {
            child->children[i + 1] = child->children[i];
        }
    }
    
    child->keys[0] = node->keys[index - 1];
    
    if (!child->isLeaf) {
        child->children[0] = sibling->children[sibling->keyCount];
    }
    
    node->keys[index - 1] = sibling->keys[sibling->keyCount - 1];
    child->keyCount++;
    sibling->keyCount--;
}

// 辅助方法：从后一个兄弟借用
void BorrowFromNext(BTreeNode *node, int index) {
    BTreeNode *child = node->children[index];
    BTreeNode *sibling = node->children[index + 1];
    
    child->keys[child->keyCount] = node->keys[index];
    
    if (!child->isLeaf) {
        child->children[child->keyCount + 1] = sibling->children[0];
    }
    
    node->keys[index] = sibling->keys[0];
    
    for (int i = 1; i < sibling->keyCount; i++) {
        sibling->keys[i - 1] = sibling->keys[i];
    }
    
    if (!sibling->isLeaf) {
        for (int i = 1; i <= sibling->keyCount; i++) {
            sibling->children[i - 1] = sibling->children[i];
        }
    }
    
    child->keyCount++;
    sibling->keyCount--;
}

// 辅助方法：填充节点
void Fill(BTreeNode *node, int index) {
    int m = node->m;
    if (index != 0 && node->children[index - 1]->keyCount >= m / 2) {
        BorrowFromPrev(node, index);
    } else if (index != node->keyCount && node->children[index + 1]->keyCount >= m / 2) {
        BorrowFromNext(node, index);
    } else {
        if (index != node->keyCount) {
            Merge(node, index);
        } else {
            Merge(node, index - 1);
        }
    }
}

// 辅助方法：从非叶子节点删除
// 前向声明 DeleteKey
void DeleteKey(BTreeNode *node, int key);

void RemoveFromNonLeaf(BTreeNode *node, int index) {
    int key = node->keys[index];
    int m = node->m;
    
    if (node->children[index]->keyCount >= m / 2) {
        int pred = GetPredecessor(node, index);
        node->keys[index] = pred;
        DeleteKey(node->children[index], pred);
    } else if (node->children[index + 1]->keyCount >= m / 2) {
        int succ = GetSuccessor(node, index);
        node->keys[index] = succ;
        DeleteKey(node->children[index + 1], succ);
    } else {
        Merge(node, index);
        DeleteKey(node->children[index], key);
    }
}

// 删除关键字递归函数
void DeleteKey(BTreeNode *node, int key) {
    int index = FindKey(node, key);
    int m = node->m;
    
    if (index < node->keyCount && node->keys[index] == key) {
        if (node->isLeaf) {
            RemoveFromLeaf(node, index);
        } else {
            RemoveFromNonLeaf(node, index);
        }
    } else {
        if (node->isLeaf) {
            return;  // 关键字不存在
        }
        
        bool flag = (index == node->keyCount);
        
        if (node->children[index]->keyCount < m / 2) {
            Fill(node, index);
        }
        
        if (flag && index > node->keyCount) {
            DeleteKey(node->children[index - 1], key);
        } else {
            DeleteKey(node->children[index], key);
        }
    }
}

// 删除操作
void Delete(BTree *tree, int key) {
    if (tree->root == NULL) {
        return;
    }
    
    DeleteKey(tree->root, key);
    
    if (tree->root->keyCount == 0) {
        BTreeNode *tmp = tree->root;
        if (tree->root->isLeaf) {
            tree->root = NULL;
        } else {
            tree->root = tree->root->children[0];
        }
        free(tmp->keys);
        free(tmp->children);
        free(tmp);
    }
}
```

---

## 九、性能分析

### 9.1 B树性能

| 操作 | 时间复杂度 | 磁盘I/O次数 | 说明 |
|------|-----------|------------|------|
| **查找** | O(log n) | O(log_m n) | 每次查找访问h个节点 |
| **插入** | O(log n) | O(log_m n) | 可能需要分裂节点 |
| **删除** | O(log n) | O(log_m n) | 可能需要合并节点 |

**优势：**
- 减少磁盘I/O次数（相比二叉排序树）
- 适合外部存储设备
- 保证平衡，查找效率稳定

**劣势：**
- 实现复杂
- 节点分裂和合并开销较大

### 9.2 B+树性能

| 操作 | 时间复杂度 | 磁盘I/O次数 | 说明 |
|------|-----------|------------|------|
| **查找** | O(log n) | O(log_m n) | 必须到叶子节点 |
| **范围查询** | O(log n + k) | O(log_m n + k/B) | k为结果数量，B为每页大小 |
| **插入** | O(log n) | O(log_m n) | 可能需要分裂节点 |
| **删除** | O(log n) | O(log_m n) | 可能需要合并节点 |
| **顺序访问** | O(n) | O(n/B) | 通过叶子节点链表 |

**优势：**
- 范围查询高效
- 顺序访问高效
- 内部节点更小，可以存储更多关键字
- 适合数据库索引

---

## 十、应用场景

### 10.1 B树应用

1. **文件系统**
   - Linux ext2/ext3/ext4文件系统
   - Windows NTFS文件系统
   - macOS HFS+文件系统

2. **数据库索引**
   - 某些数据库的内部索引结构
   - 适合单点查询

3. **其他应用**
   - 内存数据库
   - 缓存系统

### 10.2 B+树应用

1. **数据库索引**
   - MySQL InnoDB存储引擎（主键索引）
   - PostgreSQL索引
   - Oracle索引
   - SQL Server索引

2. **文件系统**
   - 某些文件系统的目录索引

3. **其他应用**
   - 搜索引擎索引
   - 大数据存储系统

### 10.3 选择建议

**选择B树：**
- 文件系统索引
- 单点查询为主
- 不需要范围查询

**选择B+树：**
- 数据库索引
- 需要范围查询
- 需要顺序访问
- 需要高效的顺序扫描

---

## 总结

```
✅ B树 = 多路平衡搜索树 + 适合外部存储
✅ B+树 = B树变体 + 叶子节点链表 + 适合数据库索引
✅ 核心优势：减少磁盘I/O次数，提高查找效率

📌 核心特点：
   - B树：关键字存储在内部节点和叶子节点
   - B+树：关键字只存储在叶子节点，内部节点只存储索引
   - B+树：叶子节点链接成有序链表，支持高效的范围查询

💡 选择建议：
   - 文件系统 → B树
   - 数据库索引 → B+树
   - 需要范围查询 → B+树
   - 单点查询为主 → B树或B+树都可以
```

---

**精简要点**: B树和B+树是多路平衡搜索树，通过减少树的高度来减少磁盘I/O次数。B+树是B树的变体，特别适合数据库索引，支持高效的范围查询和顺序访问 🌳📊✨

**代码参考**：[B树完整实现](../代码练习/05-树和二叉树/BTree.c)













