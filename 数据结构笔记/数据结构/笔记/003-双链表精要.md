# 双链表精要

> 双向链表的链式存储实现核心知识  
> 最后更新：2025年1月

## 📚 相关：[思维导图](./数据结构思维导图.md) | [代码练习](../代码练习/02-链表/) | [单链表](./002-单链表精要.md) | [循环链表](./004-循环链表精要.md)

### 📝 代码文件说明
- **[DoubleLinkList.c](../代码练习/02-链表/DoubleLinkList.c)** - 双链表（带头节点）完整实现

---

## 一、基本概念

### 什么是双链表？

**通俗理解：** 双链表就像"双向行驶的道路"，每个节点有两个指针：一个指向前面的节点（前驱），一个指向后面的节点（后继）。可以双向遍历，比单链表更灵活。

### 核心特点

```
┌─────────────────────────────────────────────────────────┐
│                   双链表存储结构                         │
└─────────────────────────────────────────────────────────┘

         null    ←    ←    ←    ←    ←
          ↓                            ↓
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ⇄ [40] → null
       (头节点)  (第一个数据节点)
        ↑                            ↑
         ←    ←    ←    ←    ←    ←
```

**关键特性：**
- ✅ **双向遍历**：可以从前往后，也可以从后往前遍历
- ✅ **删除更方便**：删除节点时不需要找前驱节点（已有prev指针）
- ✅ **插入更方便**：插入操作更容易实现
- ✅ **访问前驱快速**：可以直接通过prev指针访问前驱节点
- ⚠️ **空间开销大**：每个节点需要两个指针（prev和next）
- ⚠️ **维护复杂**：需要同时维护prev和next两个指针

### 与单链表的区别

| 特性 | 单链表 | 双链表 |
|------|--------|--------|
| **指针数量** | 1个（next） | 2个（prev + next） |
| **遍历方向** | 单向（只能从前往后） | 双向（可以从前往后，也可以从后往前） |
| **删除操作** | 需要找前驱节点 O(n) | 直接删除 O(1)（已有prev指针） |
| **空间开销** | 小 | 大（每个节点多一个指针） |
| **代码复杂度** | 简单 | 较复杂（需要维护两个指针） |

---

## 二、存储结构

### 节点结构

```c
// 双链表节点结构体
typedef struct DNode {
    int data;              // 数据域
    struct DNode *prev;    // 前驱指针
    struct DNode *next;    // 后继指针
} DNode, *DLinkList;
```

**结构说明：**
- `data`：数据域，存储数据元素
- `prev`：前驱指针，指向前一个节点（头节点的prev为null，第一个数据节点的prev指向head）
- `next`：后继指针，指向下一个节点（最后一个节点的next为null）

### 双链表类

```c
// 双链表通常使用 DLinkList L 来表示
DLinkList L;
```

**结构说明：**
- `head`：头指针，指向头节点（头节点不存储数据）
- `tail`：尾指针，指向最后一个数据节点（可选，用于快速尾插）
- `length`：链表的当前长度

### 内存布局

```
双链表在内存中的布局：

┌──────────┐
│ L (指针) │ 栈内存
└────┬─────┘
     │
     ↓
┌──────┬──────┬──────┐
│ data │ prev │ next │ 堆内存 (头节点)
└──────┴──────┴──────┘
              │
              ↓
┌──────┬──────┬──────┐
│ data │ prev │ next │ 堆内存 (节点1)
└──────┴──────┴──────┘
              │
              ↓
             ...
```

**空间开销：**
- 每个节点：数据域（4字节）+ prev指针（8字节）+ next指针（8字节） = 20字节
- 相比单链表：每个节点多8字节（prev指针）

---

## 三、基本操作

### 1. 初始化

**功能：** 创建一个空的双链表

```c
// 初始化双链表
Status InitDList(DLinkList *L) {
    *L = (DNode *)malloc(sizeof(DNode));
    if (*L == NULL) return ERROR;
    (*L)->prev = NULL;  // 头节点的prev永远为NULL
    (*L)->next = NULL;  // 初始为空
    return OK;
}
```

**时间复杂度：** O(1)  
**空间复杂度：** O(1)

**示例：**
```c
DLinkList L;
InitDList(&L);
```

---

### 2. 插入操作

#### 2.1 头插法（在链表头部插入）

**功能：** 在链表头部插入新节点

```c
Status DListInsertHead(DLinkList L, int e) {
    DNode *s = (DNode *)malloc(sizeof(DNode));
    s->data = e;
    
    s->next = L->next;
    if (L->next != NULL) {
        L->next->prev = s;
    }
    s->prev = L;
    L->next = s;
    return OK;
}
```

**插入过程图示：**

```
插入前：在头部插入元素 99
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] → null
       (头节点)  (第一个数据节点)

步骤1：创建新节点
newNode → [99] (prev=null, next=null)

步骤2：新节点指向原第一个数据节点
newNode.next = head.next  // newNode.next → [10]
newNode.prev = head        // newNode.prev → [dummy]

步骤3：更新原第一个节点的prev指针
head.next.prev = newNode   // [10].prev → [99]

步骤4：头节点指向新节点
head.next = newNode        // [dummy].next → [99]

插入后：
head → [dummy] ⇄ [99] ⇄ [10] ⇄ [20] ⇄ [30] → null
```

**时间复杂度：** O(1)

**关键点：**
- 需要更新4个指针：newNode的prev和next，原第一个节点的prev，head的next
- 如果链表为空，还需要更新tail指针

#### 2.2 尾插法（在链表尾部插入）

**功能：** 在链表尾部插入新节点（利用tail指针优化）

```c
Status DListInsertTail(DLinkList L, int e) {
    DNode *s = (DNode *)malloc(sizeof(DNode));
    s->data = e;
    s->next = NULL;
    
    DNode *p = L;
    while (p->next != NULL) {
        p = p->next;
    }
    
    p->next = s;
    s->prev = p;
    return OK;
}
```

**插入过程图示：**

```
插入前：在尾部插入元素 99
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] → null
       (头节点)                        ↑
                                     tail

步骤1：创建新节点
newNode → [99] (prev=null, next=null)

步骤2：tail指向新节点
tail.next = newNode       // [30].next → [99]
newNode.prev = tail       // [99].prev → [30]

步骤3：更新tail指针
tail = newNode            // tail → [99]

插入后：
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ⇄ [99] → null
                                                 ↑
                                               tail
```

**时间复杂度：** O(1) - 利用tail指针，不需要遍历

**优势：** 相比单链表的尾插法（O(n)），双链表的尾插法可以达到O(1)

#### 2.3 在指定位置插入

**功能：** 在第 i 个位置插入新节点

```c
Status DListInsert(DLinkList L, int i, int e) {
    if (i < 1) return ERROR;
    
    DNode *p = L;
    int j = 0;
    while (p && j < i - 1) {
        p = p->next;
        j++;
    }
    
    if (!p) return ERROR;
    
    DNode *s = (DNode *)malloc(sizeof(DNode));
    s->data = e;
    
    s->next = p->next;
    if (p->next != NULL) {
        p->next->prev = s;
    }
    s->prev = p;
    p->next = s;
    return OK;
}
```

**插入过程图示：**

```
插入前：在位置3插入元素 99
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ⇄ [40] → null
                 [1]    [2]    [3]    [4]

步骤1：找到第i个节点（位置3）
current → [30]

步骤2：插入新节点（更新4个指针）
newNode.next = current;           // [99].next → [30]
newNode.prev = current.prev;       // [99].prev → [20]
current.prev.next = newNode;       // [20].next → [99]
current.prev = newNode;            // [30].prev → [99]

插入后：
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [99] ⇄ [30] ⇄ [40] → null
```

**时间复杂度：** O(n) - 需要找到插入位置

**关键点：**
- 双链表插入需要更新4个指针（相比单链表的2个指针）
- 顺序很重要：先设置新节点的指针，再更新已有节点的指针

---

### 3. 删除操作

#### 3.1 删除指定位置的节点

**功能：** 删除第 i 个位置的节点

```c
Status DListDelete(DLinkList L, int i, int *e) {
    if (i < 1) return ERROR;
    
    DNode *p = L;
    int j = 0;
    while (p->next && j < i - 1) {
        p = p->next;
        j++;
    }
    
    if (!(p->next) || j > i - 1) return ERROR;
    
    DNode *q = p->next;
    *e = q->data;
    
    p->next = q->next;
    if (q->next != NULL) {
        q->next->prev = p;
    }
    
    free(q);
    return OK;
}
```

**删除过程图示：**

```
删除前：删除位置3的节点
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ⇄ [40] → null
                 [1]    [2]    [3]    [4]

步骤1：找到要删除的节点
current → [30]

步骤2：更新指针（删除节点只需要2步）
current.prev.next = current.next;  // [20].next → [40]
current.next.prev = current.prev;  // [40].prev → [20]

删除后：
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [40] → null
```

**时间复杂度：** O(n) - 需要找到删除位置，但删除操作本身更简单

**优势：** 相比单链表删除需要找前驱节点（O(n)），双链表删除时前驱节点已经存在（prev指针），删除操作本身是O(1)

#### 3.2 删除指定值的节点

**功能：** 删除第一个值为 data 的节点

```c
Status DListDeleteByValue(DLinkList L, int e) {
    if (L->next == NULL) return FALSE;
    
    DNode *p = L->next;
    while (p != NULL && p->data != e) {
        p = p->next;
    }
    
    if (p != NULL) {
        p->prev->next = p->next;
        if (p->next != NULL) {
            p->next->prev = p->prev;
        }
        free(p);
        return TRUE;
    }
    
    return FALSE;
}
```

**时间复杂度：** O(n)

---

### 4. 查找操作

#### 4.1 按位置查找（正向查找）

**功能：** 查找第 i 个位置的节点

```c
Status GetElem(DLinkList L, int i, int *e) {
    if (i < 1 || L->next == NULL) return ERROR;
    
    DNode *p = L->next;
    int j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    
    if (!p) return ERROR;
    *e = p->data;
    return OK;
}
```

**时间复杂度：** O(n)

#### 4.2 按位置查找（反向查找）

**功能：** 从尾部开始查找第 i 个位置的节点（双链表的特有优势）

```c
// 需要维护tail指针或遍历
Status GetElemFromTail(DLinkList L, int i, int *e) {
    // 假设有tail指针或先遍历找到尾节点
    // 这里省略具体实现
    return ERROR;
}
```

**时间复杂度：** O(n)

**示例：**
```java
// 链表：10 → 20 → 30 → 40
list.getFromTail(1);      // 返回 40（从尾部第1个）
list.getFromTail(2);      // 返回 30（从尾部第2个）
list.getFromTail(4);      // 返回 10（从尾部第4个）
```

#### 4.3 按值查找

**功能：** 查找值为 data 的节点位置

```c
int LocateElem(DLinkList L, int e) {
    DNode *p = L->next;
    int j = 1;
    while (p) {
        if (p->data == e) return j;
        p = p->next;
        j++;
    }
    return 0;  // 未找到
}
```

**时间复杂度：** O(n)

---

### 5. 遍历操作

#### 5.1 正向遍历

**功能：** 从前往后遍历链表

```c
void PrintDList(DLinkList L) {
    if (L->next == NULL) {
        printf("链表为空！\n");
        return;
    }
    
    DNode *p = L->next;
    printf("双链表（正向）：");
    while (p != NULL) {
        printf("%d", p->data);
        if (p->next != NULL) {
            printf(" <-> ");
        }
        p = p->next;
    }
    printf("\n");
}
```

**时间复杂度：** O(n)

#### 5.2 反向遍历

**功能：** 从后往前遍历链表（双链表的特有优势）

```c
// 需要先找到尾节点
void PrintDListBackward(DLinkList L) {
    DNode *p = L;
    while (p->next != NULL) {
        p = p->next;
    }
    
    if (p == L) {
        printf("链表为空！\n");
        return;
    }
    
    printf("双链表（反向）：");
    while (p != L) {
        printf("%d", p->data);
        if (p->prev != L) {
            printf(" <-> ");
        }
        p = p->prev;
    }
    printf("\n");
}
```

**时间复杂度：** O(n)

**示例：**
```java
// 链表：10 → 20 → 30
list.printForward();   // 输出：双链表（正向）：10 ⇄ 20 ⇄ 30
list.printBackward();  // 输出：双链表（反向）：30 ⇄ 20 ⇄ 10
```

---

### 6. 判空操作

**功能：** 判断链表是否为空

```c
Status ListEmpty(DLinkList L) {
    if (L->next == NULL) return TRUE;
    else return FALSE;
}
```

**时间复杂度：** O(1)

---

### 7. 获取长度

**功能：** 获取链表的当前长度

```c
int ListLength(DLinkList L) {
    // 需遍历计算
    int count = 0;
    DNode *p = L->next;
    while (p) {
        count++;
        p = p->next;
    }
    return count;
}
```

**时间复杂度：** O(1)

---

## 四、时间复杂度总结

| 操作 | 最好情况 | 平均情况 | 最坏情况 | 说明 |
|------|---------|---------|---------|------|
| **头插** | O(1) | O(1) | O(1) | 直接操作头节点 |
| **尾插** | O(1) | O(1) | O(1) | 利用tail指针优化 |
| **指定位置插入** | O(1) | O(n) | O(n) | 需要找到插入位置 |
| **删除** | O(1) | O(n) | O(n) | 需要找到删除位置，但删除操作本身更简单 |
| **正向查找** | O(1) | O(n) | O(n) | 必须从头遍历 |
| **反向查找** | O(1) | O(n) | O(n) | 必须从尾遍历（双链表特有） |
| **正向遍历** | O(n) | O(n) | O(n) | 必须访问所有节点 |
| **反向遍历** | O(n) | O(n) | O(n) | 必须访问所有节点（双链表特有） |
| **判空** | O(1) | O(1) | O(1) | 常数时间 |
| **获取长度** | O(1) | O(1) | O(1) | 如果维护length变量 |

**关键对比：**

| 操作 | 单链表 | 双链表 | 优势 |
|------|--------|--------|------|
| **尾插** | O(n) | O(1) | 双链表利用tail指针优化 |
| **删除** | O(n)（需要找前驱） | O(n)（删除操作本身O(1)） | 双链表删除操作更简单 |
| **反向查找** | ❌ 不支持 | ✅ O(n) | 双链表特有功能 |
| **反向遍历** | ❌ 不支持 | ✅ O(n) | 双链表特有功能 |

---

## 五、空间复杂度

**总空间复杂度：** O(n)

**空间组成：**
- 数据存储：O(n) - 存储 n 个节点
- 指针存储：O(2n) - 每个节点需要两个指针（prev和next）
- 辅助空间：O(1) - 只需几个变量（head、tail、length）

**存储密度：** 比单链表更低（需要额外存储prev指针）

**空间对比：**
- **单链表**：每个节点 4字节（data）+ 8字节（next） = 12字节
- **双链表**：每个节点 4字节（data）+ 8字节（prev）+ 8字节（next） = 20字节
- **额外开销**：双链表比单链表多33%的空间开销

---

## 六、优缺点分析

### ✅ 优点

1. **双向遍历**：可以从任意方向遍历链表
2. **删除方便**：删除节点时不需要找前驱节点（已有prev指针）
3. **插入方便**：插入操作更容易实现
4. **访问前驱快速**：可以直接通过prev指针访问前驱节点
5. **尾插优化**：利用tail指针可以实现O(1)的尾插操作
6. **适合频繁删除**：删除操作比单链表更高效

### ❌ 缺点

1. **空间开销大**：每个节点需要两个指针（prev和next）
2. **维护复杂**：需要同时维护prev和next两个指针
3. **代码复杂**：插入删除需要更新更多指针（4个指针）
4. **内存占用多**：比单链表多33%的空间开销

---

## 七、应用场景

### 适合使用双链表的场景

1. **需要双向遍历的场景**
   - 浏览器历史记录：前进/后退功能
   - 文本编辑器：撤销/重做操作
   - 音乐播放器：上一首/下一首

2. **频繁删除的场景**
   - 删除操作不需要找前驱节点
   - 删除操作更高效

3. **需要快速访问前驱节点**
   - 某些算法需要快速访问前驱节点
   - 双向链表提供了O(1)的前驱访问

4. **需要从尾部开始遍历**
   - 某些问题需要从后往前处理
   - 如：逆序输出、反向查找等

### 不适合使用双链表的场景

1. **空间受限**：内存有限，需要节省空间
2. **只需要单向遍历**：不需要反向遍历功能
3. **简单的插入删除**：单链表已经足够

---

## 八、与单链表的详细对比

### 结构对比

```
单链表结构：
head → [dummy] → [10] → [20] → [30] → null
       (头节点)   (数据节点)

双链表结构：
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] → null
       (头节点)   (数据节点)
        ↑         ↑         ↑         ↑
       prev     prev     prev     prev
```

### 操作对比

#### 插入操作对比

**单链表插入（需要更新2个指针）：**
```c
newNode->next = p->next;
if (p->next != NULL) {
    p->next->prev = newNode;
}
newNode->prev = p;
p->next = newNode;
```

**双链表插入（需要更新4个指针）：**
```java
newNode.next = current;           // 新节点指向第i个节点
newNode.prev = current.prev;       // 新节点指向前驱节点
current.prev.next = newNode;       // 前驱节点指向新节点
current.prev = newNode;            // 第i个节点指向前驱变为新节点
```

#### 删除操作对比

**单链表删除（需要找前驱节点，然后更新1个指针）：**
```c
// 不需要找前驱节点（已有prev指针）
p->prev->next = p->next;
if (p->next != NULL) {
    p->next->prev = p->prev;
}
free(p);
```

**双链表删除（不需要找前驱，直接更新2个指针）：**
```java
// 不需要找前驱节点（已有prev指针）
current.prev.next = current.next;  // 前驱节点指向后继节点
current.next.prev = current.prev;  // 后继节点指向前驱节点
```

### 性能对比表

| 操作 | 单链表 | 双链表 | 说明 |
|------|--------|--------|------|
| **头插** | O(1) | O(1) | 性能相同 |
| **尾插** | O(n) | O(1) | 双链表利用tail指针优化 |
| **指定位置插入** | O(n) | O(n) | 都需要找位置 |
| **删除** | O(n) | O(n) | 都需要找位置，但双链表删除操作更简单 |
| **正向查找** | O(n) | O(n) | 性能相同 |
| **反向查找** | ❌ 不支持 | ✅ O(n) | 双链表特有 |
| **正向遍历** | O(n) | O(n) | 性能相同 |
| **反向遍历** | ❌ 不支持 | ✅ O(n) | 双链表特有 |
| **空间开销** | 小 | 大（+33%） | 双链表每个节点多一个指针 |

---

## 九、完整代码示例

### 查看完整实现

- **[DoubleLinkList.java](../代码练习/02-链表/DoubleLinkList.java)** - 双链表完整实现

### 核心代码摘要

```java
// 双链表节点类
class DoubleListNode {
    int data;
    DoubleListNode prev;  // 前驱指针
    DoubleListNode next; // 后继指针
    
    DoubleListNode(int data) {
        this.data = data;
        this.prev = null;
        this.next = null;
    }
}

// 双链表类（带头节点）
public class DoubleLinkList {
    private DoubleListNode head;  // 头指针
    private DoubleListNode tail;  // 尾指针（可选但推荐）
    private int length;
    
    // 尾插法（利用tail指针优化到O(1)）
    public void insertAtTail(int data) {
        DoubleListNode newNode = new DoubleListNode(data);
        
        if (head.next == null) {
            head.next = newNode;
            newNode.prev = head;
            tail = newNode;
        } else {
            tail.next = newNode;
            newNode.prev = tail;
            tail = newNode;
        }
        length++;
    }
    
    // 删除操作（双链表的优势：不需要找前驱）
    public Integer delete(int i) {
        // ... 找到要删除的节点 ...
        
        // 删除节点（只需要更新2个指针）
        current.prev.next = current.next;
        if (current.next != null) {
            current.next.prev = current.prev;
        } else {
            tail = current.prev;
        }
        length--;
        return deletedValue;
    }
    
    // 反向遍历（双链表特有）
    public void printBackward() {
        DoubleListNode current = tail;
        while (current != head) {
            System.out.print(current.data + " ");
            current = current.prev;
        }
    }
}
```

---

## 十、常见考点

### 1. 双向链表的反转

**问题：** 如何反转一个双链表？

**算法：** 交换每个节点的prev和next指针

```c
void DListReverse(DLinkList L) {
    if (L->next == NULL || L->next->next == NULL) return;
    
    DNode *p = L->next;
    DNode *temp = NULL;
    
    while (p != NULL) {
        temp = p->prev;
        p->prev = p->next;
        p->next = temp;
        p = p->prev; // 向后移动（因为prev和next已经交换）
    }
    
    // 更新head的next指向新的第一个节点（原尾节点）
    if (temp != NULL) {
        L->next = temp->prev;
    }
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(1)

### 2. 合并两个有序双链表

**问题：** 如何合并两个有序双链表？

**算法：** 使用双指针，比较两个链表的节点值

```c
void MergeDList(DLinkList La, DLinkList Lb, DLinkList *Lc) {
    // 类似单链表合并，但需维护prev指针
    // 这里省略具体实现
}
```

**时间复杂度：** O(m + n)  
**空间复杂度：** O(m + n)

---

## 十一、学习要点总结

### ⭐⭐⭐ 必须掌握

1. **双链表的定义和存储结构**（prev和next两个指针）
2. **节点的插入和删除操作**（需要更新4个指针）
3. **双向遍历的实现**（正向和反向）
4. **tail指针的使用和优化**

### ⭐⭐ 重要理解

1. **双链表 vs 单链表的区别和优势**
2. **双链表的优缺点及应用场景**
3. **删除操作的优势**（不需要找前驱节点）
4. **空间开销的权衡**

### ⭐ 了解内容

1. **双链表的变体应用**
2. **双向链表的算法题**

---

## 总结

```
✅ 双链表 = 双向指针 + 双向遍历 + 删除更方便
✅ 适合：需要双向遍历、频繁删除、需要快速访问前驱节点
❌ 不适合：空间受限、只需要单向遍历、简单场景

📌 核心特点：
   - 每个节点有两个指针：prev（前驱）和next（后继）
   - 可以从任意方向遍历链表
   - 删除操作不需要找前驱节点（已有prev指针）
   - 尾插操作可以利用tail指针优化到O(1)

💡 优势：
   - 双向遍历：支持正向和反向遍历
   - 删除方便：删除操作更简单高效
   - 尾插优化：利用tail指针实现O(1)尾插

⚠️ 缺点：
   - 空间开销大：每个节点多一个prev指针（+33%）
   - 维护复杂：需要同时维护prev和next两个指针
```

---

**精简要点**: 双链表是单链表的扩展，通过增加prev指针实现双向遍历。虽然空间开销更大，但在需要双向遍历或频繁删除的场景中具有明显优势 ⚙️✨

**代码参考**：
- [双链表完整实现](../代码练习/02-链表/DoubleLinkList.c)

