# 查找精要

> 查找算法核心知识  
> 最后更新：2025年1月

## 📚 相关：[时间复杂度精要](./009-时间复杂度精要.md) | [代码练习](../代码练习/07-查找/) | [思维导图](./数据结构思维导图.md)

---

## 📑 目录

- [一、基本概念](#一基本概念)
  - [1.1 查找的定义](#11-查找的定义)
  - [1.2 查找的分类](#12-查找的分类)
  - [1.3 查找的性能评价](#13-查找的性能评价)
- [二、顺序查找](#二顺序查找)
  - [2.1 基本概念](#21-基本概念)
  - [2.2 算法实现](#22-算法实现)
  - [2.3 优化版本](#23-优化版本)
  - [2.4 时间复杂度分析](#24-时间复杂度分析)
- [三、折半查找](#三折半查找)
  - [3.1 基本概念](#31-基本概念)
  - [3.2 算法思想](#32-算法思想)
  - [3.3 算法实现](#33-算法实现)
  - [3.4 递归实现](#34-递归实现)
  - [3.5 时间复杂度分析](#35-时间复杂度分析)
  - [3.6 折半查找的变体](#36-折半查找的变体)
- [四、分块查找](#四分块查找)
  - [4.1 基本概念](#41-基本概念)
  - [4.2 算法思想](#42-算法思想)
  - [4.3 算法实现](#43-算法实现)
  - [4.4 时间复杂度分析](#44-时间复杂度分析)
- [五、哈希查找](#五哈希查找)
  - [5.1 基本概念](#51-基本概念)
  - [5.2 哈希函数](#52-哈希函数)
  - [5.3 冲突处理](#53-冲突处理)
  - [5.4 算法实现](#54-算法实现)
  - [5.5 时间复杂度分析](#55-时间复杂度分析)
- [六、查找算法对比](#六查找算法对比)
- [七、时间复杂度总结](#七时间复杂度总结)

---

## 一、基本概念

### 1.1 查找的定义

**查找（Search）**：在数据集合中寻找满足某种条件的数据元素的过程。

**查找表（Search Table）**：用于查找的数据集合。

**关键字（Key）**：数据元素中用于标识和比较的字段。

**查找成功**：在查找表中找到满足条件的数据元素。

**查找失败**：在查找表中没有找到满足条件的数据元素。

**平均查找长度（ASL, Average Search Length）**：查找过程中需要比较的关键字次数的期望值。

---

### 1.2 查找的分类

#### 按查找表的结构分类

1. **静态查找表（Static Search Table）**
   - 查找表的结构在查找过程中不变
   - 只进行查找操作，不进行插入和删除
   - 例如：顺序查找、折半查找、分块查找

2. **动态查找表（Dynamic Search Table）**
   - 查找表的结构在查找过程中可能改变
   - 可以进行查找、插入、删除操作
   - 例如：二叉排序树、平衡二叉树、散列表

#### 按查找方法分类

1. **线性表查找**
   - 顺序查找
   - 折半查找（二分查找）
   - 分块查找

2. **树形查找**
   - 二叉排序树（BST）
   - 平衡二叉树（AVL）
   - B树和B+树

3. **散列查找**
   - 哈希表查找

---

### 1.3 查找的性能评价

**评价指标：**

1. **平均查找长度（ASL）**
   - ASL = Σ(Pi × Ci)
   - Pi：查找第i个元素的概率
   - Ci：查找第i个元素需要比较的次数

2. **时间复杂度**
   - 最好情况
   - 平均情况
   - 最坏情况

3. **空间复杂度**
   - 算法所需的额外空间

4. **适用条件**
   - 查找表是否有序
   - 查找表的结构要求

---

## 二、顺序查找

### 2.1 基本概念

**顺序查找（Sequential Search）**：从查找表的一端开始，逐个比较关键字，直到找到目标元素或查找完整个表。

**核心思想：**
- 从第一个元素开始，逐个比较
- 如果找到目标元素，返回位置
- 如果查找完整个表仍未找到，返回失败

**特点：**
- 适用于有序表和无序表
- 实现简单
- 时间复杂度O(n)

---

### 2.2 算法实现

```c
#include <stdio.h>
#include <stdlib.h>

// 打印数组
void PrintArray(int arr[], int n) {
    printf("[");
    for (int i = 0; i < n; i++) {
        printf("%d", arr[i]);
        if (i < n - 1) printf(", ");
    }
    printf("]\n");
}

// 顺序查找（基础版本）
int SequentialSearch(int arr[], int n, int target) {
    // 从第一个元素开始逐个比较
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;  // 找到，返回索引
        }
    }
    
    return -1;  // 未找到，返回-1
}

// 顺序查找（带详细注释）
int SequentialSearchDetailed(int arr[], int n, int target) {
    printf("查找目标: %d\n", target);
    printf("查找表: ");
    PrintArray(arr, n);
    
    for (int i = 0; i < n; i++) {
        printf("比较 arr[%d]=%d 和 target=%d", i, arr[i], target);
        
        if (arr[i] == target) {
            printf(" → 找到！\n");
            return i;
        } else {
            printf(" → 不相等，继续\n");
        }
    }
    
    printf("查找失败，未找到目标元素\n");
    return -1;
}

// 顺序查找（在有序表中，可以提前终止）
int SequentialSearchOrdered(int arr[], int n, int target) {
    // 如果是有序表，可以提前终止
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;  // 找到
        } else if (arr[i] > target) {
            // 如果当前元素大于目标，且表是有序的，说明后面不可能有目标
            return -1;  // 提前终止
        }
    }
    
    return -1;  // 未找到
}

// 顺序查找（返回所有匹配位置）
// result: 存储结果的数组，count: 存储结果数量
void SequentialSearchAll(int arr[], int n, int target, int result[], int *count) {
    *count = 0;
    
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            result[(*count)++] = i;
        }
    }
}
```

---

### 2.3 优化版本

#### 优化1：使用哨兵

使用哨兵可以简化边界判断，提高效率：

```c
// 顺序查找（使用哨兵）
int SequentialSearchWithSentinel(int arr[], int n, int target) {
    // 假设arr的大小至少为n+1，且arr[n]可以被使用
    // 或者在调用前将数据复制到一个更大的数组中
    
    // 在数组末尾添加哨兵（目标值）
    // 这样可以避免每次循环都检查i < n
    int last = arr[n]; // 保存原来的值（如果需要）
    arr[n] = target;   // 哨兵
    
    int i = 0;
    while (arr[i] != target) {
        i++;
    }
    
    arr[n] = last; // 恢复原来的值（如果需要）
    
    // 如果i < n，说明找到了；如果i == n，说明未找到
    return (i < n) ? i : -1;
}
```

#### 优化2：有序表的提前终止

如果查找表是有序的，可以提前终止：

```c
// 顺序查找（有序表，提前终止）
int SequentialSearchOrderedOptimized(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i;
        } else if (arr[i] > target) {
            // 有序表中，当前元素大于目标，后面不可能有目标
            return -1;
        }
    }
    
    return -1;
}
```

---

### 2.4 时间复杂度分析

**最好情况：** O(1)
- 目标元素在第一个位置
- 只需要比较1次

**最坏情况：** O(n)
- 目标元素在最后一个位置或不存在
- 需要比较n次

**平均情况：** O(n)
- 假设每个元素被查找的概率相等（1/n）
- 平均比较次数：(1 + 2 + ... + n) / n = (n + 1) / 2 ≈ n/2
- 时间复杂度：O(n)

**空间复杂度：** O(1)
- 只需要常数个额外空间

**平均查找长度（ASL）：**
- **成功查找**：ASL = (n + 1) / 2
- **失败查找**：ASL = n

---

## 三、折半查找

### 3.1 基本概念

**折半查找（Binary Search）**：也称为**二分查找**，在有序表中，每次将查找区间缩小一半，直到找到目标元素或区间为空。

**核心思想：**
- 查找表必须是有序的
- 每次比较中间元素
- 根据比较结果缩小查找范围
- 重复直到找到或区间为空

**特点：**
- 时间复杂度：O(log n)
- 只适用于有序表
- 效率远高于顺序查找

---

### 3.2 算法思想

**折半查找的步骤：**

1. **确定查找区间**
   - 初始：left = 0, right = n - 1

2. **计算中间位置**
   - mid = (left + right) / 2

3. **比较中间元素**
   - 如果 arr[mid] == target：找到，返回mid
   - 如果 arr[mid] > target：在左半部分查找，right = mid - 1
   - 如果 arr[mid] < target：在右半部分查找，left = mid + 1

4. **重复步骤2-3**
   - 直到 left > right（查找失败）

**查找过程示例：**
```
有序表：[1, 3, 5, 7, 9, 11, 13, 15]
查找目标：7

第1次：left=0, right=7, mid=3
  arr[3]=7 == 7 → 找到！

查找目标：6

第1次：left=0, right=7, mid=3
  arr[3]=7 > 6 → 在左半部分查找，right=2

第2次：left=0, right=2, mid=1
  arr[1]=3 < 6 → 在右半部分查找，left=2

第3次：left=2, right=2, mid=2
  arr[2]=5 < 6 → 在右半部分查找，left=3

第4次：left=3 > right=2 → 查找失败
```

---

### 3.3 算法实现

```c
// 折半查找（迭代版本）
int BinarySearch(int arr[], int n, int target) {
    int left = 0;
    int right = n - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;  // 防止溢出
        
        if (arr[mid] == target) {
            return mid;  // 找到
        } else if (arr[mid] > target) {
            right = mid - 1;  // 在左半部分查找
        } else {
            left = mid + 1;   // 在右半部分查找
        }
    }
    
    return -1;  // 未找到
}

// 折半查找（带详细注释）
int BinarySearchDetailed(int arr[], int n, int target) {
    int left = 0;
    int right = n - 1;
    int step = 0;
    
    printf("查找目标: %d\n", target);
    printf("有序表: ");
    PrintArray(arr, n);
    
    while (left <= right) {
        step++;
        int mid = left + (right - left) / 2;
        
        printf("\n第%d次查找：\n", step);
        printf("  查找区间：[%d, %d]\n", left, right);
        printf("  中间位置：mid = %d, arr[%d] = %d\n", mid, mid, arr[mid]);
        
        if (arr[mid] == target) {
            printf("  arr[%d] == %d → 找到！\n", mid, target);
            return mid;
        } else if (arr[mid] > target) {
            printf("  arr[%d] = %d > %d → 在左半部分查找\n", mid, arr[mid], target);
            right = mid - 1;
        } else {
            printf("  arr[%d] = %d < %d → 在右半部分查找\n", mid, arr[mid], target);
            left = mid + 1;
        }
    }
    
    printf("\n查找失败，未找到目标元素\n");
    return -1;
}

// 折半查找（查找第一个等于target的位置）
int BinarySearchFirst(int arr[], int n, int target) {
    int left = 0;
    int right = n - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid;  // 记录位置，但不返回
            right = mid - 1;  // 继续在左半部分查找
        } else if (arr[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    
    return result;
}

// 折半查找（查找最后一个等于target的位置）
int BinarySearchLast(int arr[], int n, int target) {
    int left = 0;
    int right = n - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid;  // 记录位置，但不返回
            left = mid + 1;  // 继续在右半部分查找
        } else if (arr[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    
    return result;
}

// 折半查找（查找第一个大于等于target的位置）
int BinarySearchFirstGreaterOrEqual(int arr[], int n, int target) {
    int left = 0;
    int right = n - 1;
    int result = n;  // 如果不存在，返回数组长度
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] >= target) {
            result = mid;
            right = mid - 1;  // 继续在左半部分查找更小的
        } else {
            left = mid + 1;
        }
    }
    
    return result;
}

// 折半查找（查找最后一个小于等于target的位置）
int BinarySearchLastLessOrEqual(int arr[], int n, int target) {
    int left = 0;
    int right = n - 1;
    int result = -1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] <= target) {
            result = mid;
            left = mid + 1;  // 继续在右半部分查找更大的
        } else {
            right = mid - 1;
        }
    }
    
    return result;
}
```

---

### 3.4 递归实现

```c
// 折半查找（递归辅助函数）
int BinarySearchRecursiveHelper(int arr[], int target, int left, int right) {
    // 递归终止条件
    if (left > right) {
        return -1;  // 查找失败
    }
    
    int mid = left + (right - left) / 2;
    
    if (arr[mid] == target) {
        return mid;  // 找到
    } else if (arr[mid] > target) {
        // 在左半部分递归查找
        return BinarySearchRecursiveHelper(arr, target, left, mid - 1);
    } else {
        // 在右半部分递归查找
        return BinarySearchRecursiveHelper(arr, target, mid + 1, right);
    }
}

// 折半查找（递归版本入口）
int BinarySearchRecursive(int arr[], int n, int target) {
    return BinarySearchRecursiveHelper(arr, target, 0, n - 1);
}

// 带详细注释的递归版本
int BinarySearchDetailedRecursiveHelper(int arr[], int target, int left, int right, int depth) {
    for (int i = 0; i < depth; i++) printf("  ");
    printf("查找区间：[%d, %d]\n", left, right);
    
    if (left > right) {
        for (int i = 0; i < depth; i++) printf("  ");
        printf("查找失败\n");
        return -1;
    }
    
    int mid = left + (right - left) / 2;
    for (int i = 0; i < depth; i++) printf("  ");
    printf("中间位置：mid=%d, arr[%d]=%d\n", mid, mid, arr[mid]);
    
    if (arr[mid] == target) {
        for (int i = 0; i < depth; i++) printf("  ");
        printf("找到！位置：%d\n", mid);
        return mid;
    } else if (arr[mid] > target) {
        for (int i = 0; i < depth; i++) printf("  ");
        printf("在左半部分查找\n");
        return BinarySearchDetailedRecursiveHelper(arr, target, left, mid - 1, depth + 1);
    } else {
        for (int i = 0; i < depth; i++) printf("  ");
        printf("在右半部分查找\n");
        return BinarySearchDetailedRecursiveHelper(arr, target, mid + 1, right, depth + 1);
    }
}

int BinarySearchDetailedRecursive(int arr[], int n, int target) {
    return BinarySearchDetailedRecursiveHelper(arr, target, 0, n - 1, 0);
}
```

---

### 3.5 时间复杂度分析

**最好情况：** O(1)
- 目标元素正好在中间位置
- 只需要比较1次

**最坏情况：** O(log n)
- 目标元素在查找表的边界或不存在
- 需要比较⌊log₂n⌋ + 1次

**平均情况：** O(log n)
- 平均比较次数约为log₂n

**空间复杂度：**
- **迭代版本**：O(1)
- **递归版本**：O(log n)（递归调用栈）

**平均查找长度（ASL）：**
- **成功查找**：ASL ≈ log₂(n + 1) - 1
- **失败查找**：ASL ≈ log₂(n + 1)

**时间复杂度推导：**
```
设查找表长度为n，最坏情况下需要比较k次
每次比较后，查找范围缩小一半

第1次：查找范围 n
第2次：查找范围 n/2
第3次：查找范围 n/4
...
第k次：查找范围 n/2^(k-1)

最坏情况：n/2^(k-1) = 1
即：2^(k-1) = n
k - 1 = log₂n
k = log₂n + 1

时间复杂度：O(log n)
```

---

### 3.6 折半查找的变体

#### 变体1：查找插入位置

在有序表中查找插入位置（用于插入排序）：

```c
// 查找插入位置（第一个大于等于target的位置）
int FindInsertPosition(int arr[], int n, int target) {
    int left = 0;
    int right = n;
    
    while (left < right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid;
        }
    }
    
    return left;  // 插入位置
}
```

#### 变体2：查找范围

查找目标值在有序表中的范围：

```c
// 查找目标值的范围
void SearchRange(int arr[], int n, int target, int range[]) {
    int first = BinarySearchFirst(arr, n, target);
    
    if (first == -1) {
        range[0] = -1;
        range[1] = -1;
        return;
    }
    
    int last = BinarySearchLast(arr, n, target);
    range[0] = first;
    range[1] = last;
}
```

#### 变体3：查找旋转数组

在旋转有序数组中查找：

```c
// 在旋转有序数组中查找
// 例如：[4, 5, 6, 7, 0, 1, 2]
int SearchRotated(int arr[], int n, int target) {
    int left = 0;
    int right = n - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            return mid;
        }
        
        // 判断左半部分是否有序
        if (arr[left] <= arr[mid]) {
            // 左半部分有序
            if (arr[left] <= target && target < arr[mid]) {
                right = mid - 1;  // 在左半部分
            } else {
                left = mid + 1;    // 在右半部分
            }
        } else {
            // 右半部分有序
            if (arr[mid] < target && target <= arr[right]) {
                left = mid + 1;    // 在右半部分
            } else {
                right = mid - 1;   // 在左半部分
            }
        }
    }
    
    return -1;
}
```

---

## 四、分块查找

### 4.1 基本概念

**分块查找（Block Search）**：也称为**索引顺序查找**，将查找表分成若干块，块内无序，块间有序。

**核心思想：**
- 将查找表分成若干块
- 块内元素可以无序
- 块间有序（后一块的最小值大于前一块的最大值）
- 建立索引表，记录每块的最大关键字和起始位置
- 先在索引表中查找（折半查找或顺序查找）
- 再在对应块内查找（顺序查找）

**特点：**
- 时间复杂度：O(√n)
- 介于顺序查找和折半查找之间
- 不需要完全有序，只需要分块有序

---

### 4.2 算法思想

**分块查找的步骤：**

1. **建立索引表**
   - 将查找表分成若干块
   - 记录每块的最大关键字和起始位置

2. **查找索引表**
   - 确定目标元素所在的块
   - 可以使用折半查找或顺序查找

3. **在块内查找**
   - 在确定的块内进行顺序查找

**示例：**
```
查找表：[22, 12, 13, 8, 9, 20, 33, 42, 44, 38, 24, 48, 60, 58, 74, 49, 86, 53]
分成3块，每块6个元素：

块1：[22, 12, 13, 8, 9, 20]    最大值：22
块2：[33, 42, 44, 38, 24, 48]  最大值：48
块3：[60, 58, 74, 49, 86, 53]  最大值：86

索引表：
块号  最大值  起始位置
0     22     0
1     48     6
2     86     12

查找目标：38

步骤1：在索引表中查找，38在块1（22 < 38 ≤ 48）
步骤2：在块1内顺序查找，找到38在位置9
```

---

### 4.3 算法实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

// 索引表项
typedef struct {
    int maxValue;    // 块的最大值
    int startIndex;  // 块的起始位置
} IndexItem;

// 分块查找结构
typedef struct {
    int *data;           // 查找表
    int dataSize;        // 数据大小
    IndexItem *index;    // 索引表
    int indexSize;       // 索引表大小
    int blockSize;       // 每块的大小
} BlockSearch;

// 查找块内的最大值
int FindMax(int arr[], int start, int end) {
    int max = arr[start];
    for (int i = start + 1; i < end; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }
    return max;
}

// 初始化分块查找
void InitBlockSearch(BlockSearch *bs, int data[], int n, int blockSize) {
    bs->data = data;
    bs->dataSize = n;
    bs->blockSize = blockSize;
    
    // 计算块数
    bs->indexSize = (n + blockSize - 1) / blockSize;
    bs->index = (IndexItem *)malloc(bs->indexSize * sizeof(IndexItem));
    
    // 建立索引表
    for (int i = 0; i < bs->indexSize; i++) {
        int start = i * blockSize;
        int end = start + blockSize;
        if (end > n) end = n;
        
        bs->index[i].startIndex = start;
        bs->index[i].maxValue = FindMax(data, start, end);
    }
}

// 释放资源
void FreeBlockSearch(BlockSearch *bs) {
    if (bs->index != NULL) {
        free(bs->index);
        bs->index = NULL;
    }
}

// 在索引表中查找目标所在的块（顺序查找）
int FindBlock(BlockSearch *bs, int target) {
    for (int i = 0; i < bs->indexSize; i++) {
        IndexItem item = bs->index[i];
        
        // 如果是第一块，只需要小于等于最大值
        if (i == 0) {
            if (target <= item.maxValue) {
                return i;
            }
        } else {
            // 其他块：大于前一块的最大值，小于等于当前块的最大值
            IndexItem prevItem = bs->index[i - 1];
            if (target > prevItem.maxValue && target <= item.maxValue) {
                return i;
            }
        }
    }
    
    return -1;  // 目标大于所有块的最大值
}

// 在索引表中查找目标所在的块（折半查找，更高效）
int FindBlockBinary(BlockSearch *bs, int target) {
    int left = 0;
    int right = bs->indexSize - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        IndexItem item = bs->index[mid];
        
        if (target <= item.maxValue) {
            // 如果是第一块，或者大于前一块的最大值
            if (mid == 0 || target > bs->index[mid - 1].maxValue) {
                return mid;
            }
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    
    return -1;
}

// 分块查找
int BlockSearchFunc(BlockSearch *bs, int target) {
    // 步骤1：在索引表中查找目标所在的块
    int blockIndex = FindBlock(bs, target);
    
    if (blockIndex == -1) {
        return -1;  // 目标不在任何块中
    }
    
    // 步骤2：在对应块内顺序查找
    IndexItem block = bs->index[blockIndex];
    int start = block.startIndex;
    int end = start + bs->blockSize;
    if (end > bs->dataSize) end = bs->dataSize;
    
    for (int i = start; i < end; i++) {
        if (bs->data[i] == target) {
            return i;  // 找到
        }
    }
    
    return -1;  // 未找到
}

// 带详细注释的版本
int BlockSearchDetailed(BlockSearch *bs, int target) {
    printf("查找目标: %d\n", target);
    printf("查找表: ");
    PrintArray(bs->data, bs->dataSize);
    printf("索引表:\n");
    for (int i = 0; i < bs->indexSize; i++) {
        IndexItem item = bs->index[i];
        printf("  块%d: 最大值=%d, 起始位置=%d\n", 
            i, item.maxValue, item.startIndex);
    }
    
    // 步骤1：查找索引表
    printf("\n步骤1：在索引表中查找目标所在的块\n");
    int blockIndex = FindBlock(bs, target);
    
    if (blockIndex == -1) {
        printf("目标不在任何块中，查找失败\n");
        return -1;
    }
    
    IndexItem block = bs->index[blockIndex];
    printf("目标在块%d（最大值=%d，起始位置=%d）\n", 
        blockIndex, block.maxValue, block.startIndex);
    
    // 步骤2：在块内查找
    printf("\n步骤2：在块内顺序查找\n");
    int start = block.startIndex;
    int end = start + bs->blockSize;
    if (end > bs->dataSize) end = bs->dataSize;
    
    for (int i = start; i < end; i++) {
        printf("  比较 data[%d]=%d 和 target=%d", i, bs->data[i], target);
        if (bs->data[i] == target) {
            printf(" → 找到！\n");
            return i;
        } else {
            printf(" → 不相等，继续\n");
        }
    }
    
    printf("块内未找到，查找失败\n");
    return -1;
}

// 打印索引表
void PrintIndex(BlockSearch *bs) {
    printf("索引表:\n");
    for (int i = 0; i < bs->indexSize; i++) {
        IndexItem item = bs->index[i];
        int end = item.startIndex + bs->blockSize;
        if (end > bs->dataSize) end = bs->dataSize;
        
        printf("块%d: 最大值=%d, 位置[%d,%d), 元素: [",
            i, item.maxValue, item.startIndex, end);
        for (int j = item.startIndex; j < end; j++) {
            printf("%d", bs->data[j]);
            if (j < end - 1) printf(", ");
        }
        printf("]\n");
    }
}
```

---

### 4.4 时间复杂度分析

**时间复杂度：** O(√n)
- **查找索引表**：O(log m) 或 O(m)，其中m是块数
- **块内查找**：O(s)，其中s是每块的大小
- **最优情况**：当块数m = √n，每块大小s = √n时
  - 总时间复杂度：O(√n)

**空间复杂度：** O(m)
- 索引表需要O(m)空间，m是块数

**平均查找长度（ASL）：**
- **成功查找**：ASL = ASL索引表 + ASL块内
  - 如果索引表用折半查找：ASL ≈ log₂(m+1) + s/2 ≈ log₂(√n+1) + √n/2 ≈ √n + 1
  - 如果索引表用顺序查找：ASL ≈ m/2 + s/2 ≈ √n/2 + √n/2 = √n

**特点：**
- 时间复杂度介于顺序查找和折半查找之间
- 不需要完全有序，只需要分块有序
- 适合动态查找表（可以方便地插入和删除）

---

## 五、哈希查找

### 5.1 基本概念

**哈希查找（Hash Search）**：也称为**散列查找**，通过哈希函数将关键字映射到存储位置，直接访问该位置进行查找。

**核心思想：**
- **哈希函数（Hash Function）**：将关键字映射到存储位置
- **哈希表（Hash Table）**：存储数据的数组
- **冲突（Collision）**：不同关键字映射到同一位置

**特点：**
- 平均时间复杂度：O(1)
- 最坏时间复杂度：O(n)
- 需要额外的空间
- 查找效率非常高

**术语：**
- **关键字（Key）**：要查找的数据
- **哈希值（Hash Value）**：关键字通过哈希函数得到的值
- **冲突（Collision）**：不同关键字映射到同一位置
- **装填因子（Load Factor）**：α = n/m，其中n是元素个数，m是哈希表大小

---

### 5.2 哈希函数

哈希函数的设计原则：
- 计算简单
- 分布均匀
- 冲突少

#### 5.2.1 直接定址法

**公式：** H(key) = a × key + b

**特点：**
- 简单直接
- 不会产生冲突
- 适合关键字分布连续的情况

**示例：**
```c
// H(key) = key
int HashDirect(int key) {
    return key;
}
```

#### 5.2.2 除留余数法

**公式：** H(key) = key % p

**特点：**
- 最常用的哈希函数
- p通常选择小于等于表长的最大质数

**示例：**
```c
// H(key) = key % m，m是哈希表大小
int HashMod(int key, int tableSize) {
    return key % tableSize;
}
```

#### 5.2.3 数字分析法

**特点：**
- 分析关键字的分布规律
- 选择分布均匀的位数作为哈希值
- 适合关键字位数较多的情况

#### 5.2.4 平方取中法

**公式：** 取关键字平方的中间几位作为哈希值

**特点：**
- 分布较均匀
- 适合关键字位数不多的情况

**示例：**
```c
// 关键字1234，平方=1522756，取中间3位：227
int HashSquareMid(int key) {
    long long square = (long long)key * key;
    // 取中间3位
    return (int)((square / 100) % 1000);
}
```

#### 5.2.5 折叠法

**特点：**
- 将关键字分成几部分
- 将各部分相加（或异或）得到哈希值
- 适合关键字位数很多的情况

---

### 5.3 冲突处理

#### 5.3.1 开放定址法（Open Addressing）

**基本思想：** 当发生冲突时，寻找下一个空闲位置。

**1. 线性探测法（Linear Probing）**

**公式：** Hi = (H(key) + i) % m，i = 0, 1, 2, ...

**特点：**
- 简单易实现
- 容易产生聚集（Clustering）
- 查找效率可能降低

**示例：**
```
哈希表大小：10
哈希函数：H(key) = key % 10

插入22：H(22) = 2，位置2空闲，插入
插入12：H(12) = 2，位置2被占用，探测位置3，空闲，插入
插入32：H(32) = 2，位置2被占用，探测位置3，被占用，探测位置4，空闲，插入
```

**2. 平方探测法（Quadratic Probing）**

**公式：** Hi = (H(key) + i²) % m，i = 0, 1, 2, ...

**特点：**
- 减少聚集现象
- 可能无法找到空闲位置（即使有空闲位置）

**3. 双散列法（Double Hashing）**

**公式：** Hi = (H1(key) + i × H2(key)) % m

**特点：**
- 冲突处理效果好
- 需要两个哈希函数

#### 5.3.2 链地址法（Chaining）

**基本思想：** 将冲突的元素用链表连接起来。

**特点：**
- 不会产生聚集
- 可以存储超过表长的元素
- 需要额外的指针空间

**示例：**
```
哈希表大小：10
哈希函数：H(key) = key % 10

插入22：H(22) = 2，位置2为空，创建链表节点
插入12：H(12) = 2，位置2已有22，在链表后添加12
插入32：H(32) = 2，位置2已有22和12，在链表后添加32

位置2的链表：22 → 12 → 32
```

---

### 5.4 算法实现

```c
#include <stdio.h>
#include <stdlib.h>

// 链表节点
typedef struct Node {
    int key;
    int value;
    struct Node *next;
} Node;

// 哈希表（使用链地址法处理冲突）
typedef struct {
    Node **table;  // 哈希表（指针数组）
    int capacity;  // 哈希表容量
    int size;      // 元素个数
} HashTable;

// 初始化哈希表
void InitHashTable(HashTable *ht, int capacity) {
    ht->capacity = capacity;
    ht->size = 0;
    ht->table = (Node **)calloc(capacity, sizeof(Node *));
}

// 销毁哈希表
void DestroyHashTable(HashTable *ht) {
    for (int i = 0; i < ht->capacity; i++) {
        Node *current = ht->table[i];
        while (current != NULL) {
            Node *temp = current;
            current = current->next;
            free(temp);
        }
    }
    free(ht->table);
}

// 哈希函数（除留余数法）
int Hash(HashTable *ht, int key) {
    return abs(key) % ht->capacity;
}

// 插入元素
void Put(HashTable *ht, int key, int value) {
    int index = Hash(ht, key);
    Node *node = ht->table[index];
    
    // 检查是否已存在
    while (node != NULL) {
        if (node->key == key) {
            node->value = value;  // 更新值
            return;
        }
        node = node->next;
    }
    
    // 插入新节点（头插法）
    Node *newNode = (Node *)malloc(sizeof(Node));
    newNode->key = key;
    newNode->value = value;
    newNode->next = ht->table[index];
    ht->table[index] = newNode;
    ht->size++;
}

// 查找元素
// 返回1表示找到，0表示未找到，value通过指针返回
int Get(HashTable *ht, int key, int *value) {
    int index = Hash(ht, key);
    Node *node = ht->table[index];
    
    while (node != NULL) {
        if (node->key == key) {
            *value = node->value;  // 找到
            return 1;
        }
        node = node->next;
    }
    
    return 0;  // 未找到
}

// 删除元素
int Remove(HashTable *ht, int key) {
    int index = Hash(ht, key);
    Node *node = ht->table[index];
    Node *prev = NULL;
    
    while (node != NULL) {
        if (node->key == key) {
            if (prev == NULL) {
                ht->table[index] = node->next;
            } else {
                prev->next = node->next;
            }
            free(node);
            ht->size--;
            return 1;
        }
        prev = node;
        node = node->next;
    }
    
    return 0;  // 未找到
}

// 检查是否包含关键字
int Contains(HashTable *ht, int key) {
    int value;
    return Get(ht, key, &value);
}

// 获取装填因子
double GetLoadFactor(HashTable *ht) {
    return (double)ht->size / ht->capacity;
}

// 打印哈希表
void PrintHashTable(HashTable *ht) {
    printf("哈希表（容量=%d, 元素数=%d）:\n", ht->capacity, ht->size);
    for (int i = 0; i < ht->capacity; i++) {
        printf("位置%d: ", i);
        Node *node = ht->table[i];
        if (node == NULL) {
            printf("空\n");
        } else {
            while (node != NULL) {
                printf("%d(%d)", node->key, node->value);
                if (node->next != NULL) {
                    printf(" → ");
                }
                node = node->next;
            }
            printf("\n");
        }
    }
    printf("装填因子: %.2f\n", GetLoadFactor(ht));
}
#define EMPTY -1
#define DELETED -2

// 哈希表（使用开放定址法-线性探测）
typedef struct {
    int *keys;     // 关键字数组
    int *values;   // 值数组
    int *used;     // 标记数组 (0: unused, 1: used)
    int capacity;  // 哈希表容量
    int size;      // 元素个数
} HashTableOpenAddressing;

// 初始化哈希表
void InitHashTableOA(HashTableOpenAddressing *ht, int capacity) {
    ht->capacity = capacity;
    ht->size = 0;
    ht->keys = (int *)malloc(capacity * sizeof(int));
    ht->values = (int *)malloc(capacity * sizeof(int));
    ht->used = (int *)calloc(capacity, sizeof(int));
    
    for (int i = 0; i < capacity; i++) {
        ht->keys[i] = EMPTY;
    }
}

// 销毁哈希表
void DestroyHashTableOA(HashTableOpenAddressing *ht) {
    free(ht->keys);
    free(ht->values);
    free(ht->used);
}

// 哈希函数
int HashOA(HashTableOpenAddressing *ht, int key) {
    return abs(key) % ht->capacity;
}

// 插入元素
int PutOA(HashTableOpenAddressing *ht, int key, int value) {
    if (ht->size >= ht->capacity) {
        return 0;  // 哈希表已满
    }
    
    int index = HashOA(ht, key);
    
    // 线性探测
    while (ht->used[index] && ht->keys[index] != EMPTY && ht->keys[index] != DELETED) {
        if (ht->keys[index] == key) {
            ht->values[index] = value;  // 更新值
            return 1;
        }
        index = (index + 1) % ht->capacity;  // 下一个位置
    }
    
    // 找到空闲位置
    ht->keys[index] = key;
    ht->values[index] = value;
    ht->used[index] = 1;
    ht->size++;
    return 1;
}

// 查找元素
// 返回1表示找到，0表示未找到，value通过指针返回
int GetOA(HashTableOpenAddressing *ht, int key, int *value) {
    int index = HashOA(ht, key);
    int startIndex = index;
    
    // 线性探测查找
    while (ht->used[index]) {
        if (ht->keys[index] == key) {
            *value = ht->values[index];  // 找到
            return 1;
        }
        index = (index + 1) % ht->capacity;
        
        // 如果回到起始位置，说明查找失败
        if (index == startIndex) {
            break;
        }
    }
    
    return 0;  // 未找到
}

// 删除元素
int RemoveOA(HashTableOpenAddressing *ht, int key) {
    int index = HashOA(ht, key);
    int startIndex = index;
    
    // 线性探测查找
    while (ht->used[index]) {
        if (ht->keys[index] == key) {
            ht->keys[index] = DELETED;  // 标记为已删除
            ht->size--;
            return 1;
        }
        index = (index + 1) % ht->capacity;
        
        if (index == startIndex) {
            break;
        }
    }
    
    return 0;  // 未找到
}

// 打印哈希表
void PrintHashTableOA(HashTableOpenAddressing *ht) {
    printf("哈希表（容量=%d, 元素数=%d）:\n", ht->capacity, ht->size);
    for (int i = 0; i < ht->capacity; i++) {
        if (ht->keys[i] == EMPTY) {
            printf("位置%d: 空\n", i);
        } else if (ht->keys[i] == DELETED) {
            printf("位置%d: 已删除\n", i);
        } else {
            printf("位置%d: key=%d, value=%d\n", i, ht->keys[i], ht->values[i]);
        }
    }
}
```

---

### 5.5 时间复杂度分析

**平均情况：** O(1)
- 假设哈希函数分布均匀
- 冲突处理效率高
- 装填因子α < 0.75时，性能很好

**最坏情况：** O(n)
- 所有关键字都映射到同一位置
- 哈希表退化为链表或顺序查找

**空间复杂度：** O(n)
- 哈希表需要O(n)空间

**性能影响因素：**
1. **哈希函数的质量**
   - 分布越均匀，性能越好

2. **装填因子α**
   - α = n/m（元素个数/表长）
   - α越小，冲突越少，性能越好
   - 通常α < 0.75时性能较好

3. **冲突处理方法**
   - 链地址法：平均性能好
   - 开放定址法：可能产生聚集

**平均查找长度（ASL）：**
- **成功查找**：
  - 链地址法：ASL ≈ 1 + α/2
  - 线性探测法：ASL ≈ (1 + 1/(1-α)) / 2
- **失败查找**：
  - 链地址法：ASL ≈ α
  - 线性探测法：ASL ≈ (1 + 1/(1-α)²) / 2

---

## 六、查找算法对比

| 特性 | 顺序查找 | 折半查找 | 分块查找 | 哈希查找 |
|------|---------|---------|---------|---------|
| **适用表** | 有序/无序 | 有序 | 分块有序 | 任意 |
| **时间复杂度（最好）** | O(1) | O(1) | O(1) | O(1) |
| **时间复杂度（平均）** | O(n) | O(log n) | O(√n) | O(1) |
| **时间复杂度（最坏）** | O(n) | O(log n) | O(√n) | O(n) |
| **空间复杂度** | O(1) | O(1) | O(√n) | O(n) |
| **实现复杂度** | 简单 | 中等 | 中等 | 复杂 |
| **预处理要求** | 无 | 需要排序 | 需要分块 | 需要构建哈希表 |
| **查找效率** | 低 | 高 | 中等 | 非常高 |
| **稳定性** | ✅ | ✅ | ✅ | ❌ |
| **适用场景** | 小规模、无序表 | 大规模、有序表 | 中等规模、分块有序 | 大规模、查找频繁 |

**选择建议：**
- **无序表或小规模数据（<50）**：顺序查找
- **有序表、大规模数据（>50）**：折半查找
- **分块有序、中等规模**：分块查找
- **查找操作非常频繁、数据范围已知**：哈希查找
- **需要频繁插入删除**：顺序查找或哈希查找
- **需要稳定排序**：顺序查找、折半查找、分块查找

---

## 七、时间复杂度总结

### 线性表查找算法对比

| 算法 | 适用表 | 最好情况 | 平均情况 | 最坏情况 | 空间复杂度 | 预处理要求 |
|------|--------|---------|---------|---------|----------|----------|
| **顺序查找** | 有序/无序 | O(1) | O(n) | O(n) | O(1) | 无 |
| **折半查找** | 有序 | O(1) | O(log n) | O(log n) | O(1) | 需要排序 |
| **分块查找** | 分块有序 | O(1) | O(√n) | O(√n) | O(√n) | 需要分块 |
| **哈希查找** | 任意 | O(1) | O(1) | O(n) | O(n) | 需要构建哈希表 |

### 所有查找算法对比

| 算法 | 适用表 | 最好情况 | 平均情况 | 最坏情况 | 空间复杂度 | 预处理要求 |
|------|--------|---------|---------|---------|----------|----------|
| **顺序查找** | 有序/无序 | O(1) | O(n) | O(n) | O(1) | 无 |
| **折半查找** | 有序 | O(1) | O(log n) | O(log n) | O(1) | 需要排序 |
| **分块查找** | 分块有序 | O(1) | O(√n) | O(√n) | O(√n) | 需要分块 |
| **BST查找** | 二叉排序树 | O(1) | O(log n) | O(n) | O(n) | 需要构建BST |
| **AVL查找** | 平衡二叉树 | O(log n) | O(log n) | O(log n) | O(n) | 需要构建AVL |
| **哈希查找** | 哈希表 | O(1) | O(1) | O(n) | O(n) | 需要构建哈希表 |

### 平均查找长度（ASL）对比

| 算法 | 成功查找ASL | 失败查找ASL |
|------|-----------|-----------|
| **顺序查找** | (n+1)/2 | n |
| **折半查找** | log₂(n+1) - 1 | log₂(n+1) |
| **分块查找** | √n + 1 | √n |
| **哈希查找（链地址法）** | 1 + α/2 | α |
| **哈希查找（线性探测）** | (1 + 1/(1-α)) / 2 | (1 + 1/(1-α)²) / 2 |

注：α为装填因子，α = n/m（元素个数/表长）

---

## 总结

```
✅ 查找 = 在数据集合中寻找满足条件的数据元素
✅ 顺序查找：简单直观，适用于有序表和无序表，时间复杂度O(n)
✅ 折半查找：高效查找，仅适用于有序表，时间复杂度O(log n)
✅ 分块查找：介于顺序和折半之间，适用于分块有序表，时间复杂度O(√n)
✅ 哈希查找：最高效的查找，平均时间复杂度O(1)，需要构建哈希表

📌 核心特点：
   - 顺序查找：简单、通用、效率低
   - 折半查找：高效、需要有序表、实现稍复杂
   - 分块查找：中等效率、需要分块有序、适合动态查找
   - 哈希查找：最高效、需要构建哈希表、可能冲突

💡 选择建议：
   - 无序表 → 顺序查找
   - 小规模数据（<50）→ 顺序查找
   - 有序表、大规模数据（>50）→ 折半查找
   - 分块有序、中等规模 → 分块查找
   - 查找操作非常频繁、数据范围已知 → 哈希查找
   - 需要频繁插入删除 → 顺序查找或哈希查找
   - 需要稳定排序 → 顺序查找、折半查找、分块查找
```

---

**精简要点**: 
- **顺序查找**：简单通用但效率低，适用于无序表和小规模数据 🔍
- **折半查找**：高效但需要有序表，时间复杂度O(log n) ⚡
- **分块查找**：介于顺序和折半之间，时间复杂度O(√n)，适合分块有序的数据 📦
- **哈希查找**：最高效的查找方法，平均时间复杂度O(1)，但需要处理冲突问题 🔑

