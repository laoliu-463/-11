# 单链表精要

> 线性表的链式存储实现核心知识  
> 最后更新：2025年1月

## 📚 相关：[思维导图](./数据结构思维导图.md) | [代码练习](../代码练习/02-链表/) | [顺序表](./001-顺序表精要.md)

### 📝 代码文件说明
- **[LinkListWithoutHead.c](../代码练习/02-链表/LinkListWithoutHead.c)** - 单链表（不带头节点）
- **[LinkListWithHead.c](../代码练习/02-链表/LinkListWithHead.c)** - 单链表（带头节点）
- **[DoubleLinkList.c](../代码练习/02-链表/DoubleLinkList.c)** - 双链表（带头节点）
- **[CircularLinkList.c](../代码练习/02-链表/CircularLinkList.c)** - 循环链表（单链表+双链表）

---

## 一、基本概念

### 什么是单链表？

**通俗理解：** 单链表就像"一串珍珠项链"，每个节点（珍珠）通过指针（线）连接起来。每个节点包含数据和指向下一个节点的指针，形成一个链式结构。和顺序表的"连续座位"不同，链表的节点可以分散在内存的任何位置。

### 核心特点

```
┌─────────────────────────────────────────────────────────┐
│                   单链表存储结构                         │
└─────────────────────────────────────────────────────────┘

内存地址:  1000     2000     3000     4000     5000
          ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐
          │ 10  │→ │ 20  │→ │ 30  │→ │ 40  │→ │ 50  │→ null
          └─────┘  └─────┘  └─────┘  └─────┘  └─────┘
           data     data     data     data     data
           next     next     next     next     next
          ▲
        头指针
```

**关键特性：**
- ✅ **动态分配**：节点按需分配，不需要预分配空间
- ✅ **插入删除快**：在已知位置插入删除，时间复杂度 O(1)
- ✅ **空间利用灵活**：可以充分利用内存空间
- ⚠️ **访问慢**：必须从头开始遍历，时间复杂度 O(n)
- ⚠️ **存储密度低**：需要额外的指针空间

---

## 二、存储结构

### 节点结构

```c
// 节点结构体
typedef struct LNode {
    int data;           // 数据域
    struct LNode *next; // 指针域
} LNode, *LinkList;
```

**结构说明：**
- `data`：数据域，存储数据元素
- `next`：指针域，指向下一个节点（最后一个节点指向 `null`）

### 单链表类

```c
// 单链表通常使用 LinkList L 来表示
// L 指向头节点（带头节点）或第一个节点（不带头节点）
LinkList L;
```

**结构说明：**
- `head`：头指针，指向链表的第一个节点（如果链表为空则为 `null`）
- `length`：链表的当前长度（可选，用于快速获取长度）

### 内存布局

```
单链表在内存中的布局：

┌──────────┐
│ L (指针) │ 栈内存
└────┬─────┘
     │
     ↓
┌──────────┬──────────┐
│ data: 10 │ next ───>│ 堆内存 (节点1)
└──────────┴──────────┘
              │
              ↓
┌──────────┬──────────┐
│ data: 20 │ next ───>│ 堆内存 (节点2)
└──────────┴──────────┘
              │
              ↓
             ...
```

### 头节点 vs 头指针

#### 带头节点的单链表

```java
// 头节点：不存储数据，仅作为链表的入口
head → [dummy] → [data1] → [data2] → ... → null
       (头节点)    (第一个数据节点)
```

**代码实现：**
```c
// 带头节点初始化
Status InitList(LinkList *L) {
    *L = (LNode *)malloc(sizeof(LNode)); // 分配头节点
    if (*L == NULL) return ERROR;        // 内存分配失败
    (*L)->next = NULL;                   // 头节点next置空
    return OK;
}

// 判断空
Status ListEmpty(LinkList L) {
    if (L->next == NULL) return TRUE;
    else return FALSE;
}
```

**优点：**
- ✅ **统一操作**：插入删除操作不需要特殊处理头节点
- ✅ **简化代码**：不用判断头指针是否为空
- ✅ **代码更简洁**：插入删除位置1时不需要特殊处理

**缺点：**
- ⚠️ **额外空间**：需要多一个头节点空间

#### 不带头节点的单链表

```java
// 头指针直接指向第一个数据节点
head → [data1] → [data2] → ... → null
       (第一个节点)
```

**代码实现：**
```c
// 不带头节点初始化
Status InitList(LinkList *L) {
    *L = NULL; // 头指针置空
    return OK;
}

// 判断空
Status ListEmpty(LinkList L) {
    if (L == NULL) return TRUE;
    else return FALSE;
}
```

**特点：**
- ✅ **节省空间**：节省一个节点空间
- ⚠️ **需要特殊处理**：插入删除位置1需要特殊处理
- ⚠️ **代码复杂**：需要判断头指针是否为空

#### 两种实现的对比

| 特性 | 不带头节点 | 带头节点 |
|------|-----------|---------|
| **头指针** | 直接指向第一个数据节点 | 指向头节点 |
| **空链表判断** | `head == null` | `head.next == null` |
| **插入位置1** | 需要特殊处理（更新head） | 统一操作（head.next） |
| **删除位置1** | 需要特殊处理（更新head） | 统一操作（head.next） |
| **空间开销** | 节省一个节点 | 多一个头节点 |
| **代码复杂度** | 需要判断头节点 | 代码更简洁 |
| **推荐场景** | 空间受限 | 代码简洁优先 |

**实际代码对比：**

**不带头节点插入位置1：**
```c
// 需要特殊处理
if (i == 1) {
    newNode->next = L;
    L = newNode;  // 更新头指针
} else {
    // 其他位置的处理
}
```

**带头节点插入位置1：**
```c
// 统一操作，不需要特殊处理
LNode *p = L;  // 从头节点开始
int j = 0;
while (p && j < i - 1) {
    p = p->next;
    j++;
}
newNode->next = p->next;
p->next = newNode;
```

---

## 三、基本操作

### 1. 初始化

**功能：** 创建一个空的单链表

**不带头节点版本：**
```c
Status InitList(LinkList *L) {
    *L = NULL;
    return OK;
}
```

**带头节点版本：**
```c
Status InitList(LinkList *L) {
    *L = (LNode *)malloc(sizeof(LNode));
    if (*L == NULL) return ERROR;
    (*L)->next = NULL;
    return OK;
}
```

**时间复杂度：** O(1)  
**空间复杂度：** O(1)

**示例：**
```c
LinkList L;
InitList(&L);
```

---

### 2. 插入操作

#### 2.1 头插法（在链表头部插入）

**功能：** 在链表头部插入新节点

**不带头节点版本：**
```c
Status ListInsertHead(LinkList *L, int e) {
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = *L;
    *L = s;
    return OK;
}
```

**带头节点版本：**
```c
Status ListInsertHead(LinkList L, int e) {
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = L->next;
    L->next = s;
    return OK;
}
```

**插入过程图示（不带头节点）：**

```
插入前：在头部插入元素 99
head → [10] → [20] → [30] → null

步骤1：创建新节点
newNode → [99] → null

步骤2：新节点指向原头节点
newNode → [99] → [10] → [20] → [30] → null
           ↑
          head

步骤3：更新头指针
head → [99] → [10] → [20] → [30] → null
```

**插入过程图示（带头节点）：**

```
插入前：在头部插入元素 99
head → [dummy] → [10] → [20] → [30] → null
       (头节点)  (第一个数据节点)

步骤1：创建新节点
newNode → [99] → null

步骤2：新节点指向原第一个数据节点
newNode → [99] → [10] → [20] → [30] → null

步骤3：头节点指向新节点
head → [dummy] → [99] → [10] → [20] → [30] → null
       (头节点)  (新节点)
```

**时间复杂度：** O(1)

#### 2.2 尾插法（在链表尾部插入）

**功能：** 在链表尾部插入新节点

**不带头节点版本：**
```c
Status ListInsertTail(LinkList *L, int e) {
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = NULL;
    
    if (*L == NULL) {
        *L = s;
    } else {
        LNode *p = *L;
        while (p->next != NULL) {
            p = p->next;
        }
        p->next = s;
    }
    return OK;
}
```

**带头节点版本：**
```c
Status ListInsertTail(LinkList L, int e) {
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = NULL;
    
    LNode *p = L;
    while (p->next != NULL) {
        p = p->next;
    }
    p->next = s;
    return OK;
}
```

**时间复杂度：** O(n) - 需要遍历到尾部

#### 2.3 在指定位置插入

**功能：** 在第 i 个位置插入新节点

**不带头节点版本：**
```c
Status ListInsert(LinkList *L, int i, int e) {
    if (i < 1) return ERROR;
    
    if (i == 1) {
        LNode *s = (LNode *)malloc(sizeof(LNode));
        s->data = e;
        s->next = *L;
        *L = s;
        return OK;
    }
    
    LNode *p = *L;
    int j = 1;
    while (p && j < i - 1) {
        p = p->next;
        j++;
    }
    
    if (!p) return ERROR;
    
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}
```

**带头节点版本：**
```c
Status ListInsert(LinkList L, int i, int e) {
    if (i < 1) return ERROR;
    
    LNode *p = L;
    int j = 0;
    while (p && j < i - 1) {
        p = p->next;
        j++;
    }
    
    if (!p) return ERROR;
    
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    s->next = p->next;
    p->next = s;
    return OK;
}
```

**插入过程图示（不带头节点）：**

```
插入前：在位置3插入元素 99
head → [10] → [20] → [30] → [40] → null
        [1]    [2]    [3]    [4]

步骤1：找到第 i-1 个节点（位置2）
prev → [20]

步骤2：新节点指向原第 i 个节点
newNode → [99] → [30]

步骤3：第 i-1 个节点指向新节点
head → [10] → [20] → [99] → [30] → [40] → null
```

**插入过程图示（带头节点）：**

```
插入前：在位置3插入元素 99
head → [dummy] → [10] → [20] → [30] → [40] → null
       (头节点)   [1]    [2]    [3]    [4]

步骤1：从头节点开始，找到第 i-1 个节点（位置2）
prev → [20]

步骤2：新节点指向原第 i 个节点
newNode → [99] → [30]

步骤3：第 i-1 个节点指向新节点
head → [dummy] → [10] → [20] → [99] → [30] → [40] → null
```

**时间复杂度：** O(n) - 需要找到插入位置

**关键区别：**
- **不带头节点**：插入位置1需要特殊处理（更新head）
- **带头节点**：所有位置统一处理（从head开始遍历）

---

### 2.4 三种插入方法对比总结

**单链表提供了三种不同的插入方法，它们各有特点和适用场景：**

#### 对比表格

| 特性 | 头插法（insertAtHead） | 尾插法（insertAtTail） | 指定位置插入（insert） |
|------|----------------------|----------------------|---------------------|
| **时间复杂度** | ✅ O(1) | ❌ O(n) | ❌ O(n) |
| **插入位置** | 固定（头部） | 固定（尾部） | 任意位置（1 到 length+1） |
| **需要遍历** | ❌ 不需要 | ✅ 需要 | ✅ 需要 |
| **元素顺序** | 逆序（后进先出，LIFO） | 顺序（先进先出，FIFO） | 按指定位置 |
| **代码复杂度** | 简单 | 中等 | 较复杂 |
| **适用场景** | 栈、逆序构建 | 队列、顺序构建 | 任意位置插入 |

#### 详细说明

**1. 头插法（insertAtHead）**
- **特点：** 最快，时间复杂度 O(1)
- **元素顺序：** 后插入的在前（像栈一样）
- **示例：**
  ```
  插入顺序：10, 20, 30
  结果：30 → 20 → 10 → null
  ```
- **适用场景：**
  - 构建栈结构
  - 逆序构建链表
  - 需要快速在头部插入

**2. 尾插法（insertAtTail）**
- **特点：** 需要遍历到尾部，时间复杂度 O(n)
- **元素顺序：** 先插入的在前（像队列一样）
- **示例：**
  ```
  插入顺序：10, 20, 30
  结果：10 → 20 → 30 → null
  ```
- **适用场景：**
  - 构建队列结构
  - 保持插入顺序
  - 需要顺序访问
- **优化建议：** 可以维护一个尾指针（tail）来优化到 O(1)

**3. 指定位置插入（insert）**
- **特点：** 最灵活，可以在任意位置插入
- **元素顺序：** 按指定位置插入
- **示例：**
  ```
  原链表：10 → 20 → 30 → 40
  在位置3插入99
  结果：10 → 20 → 99 → 30 → 40
  ```
- **适用场景：**
  - 需要精确控制插入位置
  - 通用插入操作
  - 任意位置插入

#### 记忆技巧

```
头插法 = 最快（O(1)）+ 后进先出（栈）
尾插法 = 顺序（FIFO）+ 需要遍历（O(n)）
指定位置 = 最灵活 + 需要找位置（O(n)）
```

#### 代码实现对比

**头插法：**
```c
// 最简洁，只需2步
newNode->next = *L;  // 或 L->next（带头节点）
*L = newNode;        // 或 L->next = newNode（带头节点）
```

**尾插法：**
```c
// 需要遍历到最后一个节点
LNode *p = *L;
while (p->next != NULL) {
    p = p->next;  // 遍历
}
p->next = newNode;  // 插入
```

**指定位置插入：**
```c
// 需要找到第 i-1 个节点
LNode *p = *L;
int j = 1;
while (p && j < i - 1) {  // 或 j = 0（带头节点）
    p = p->next;  // 遍历到目标位置
    j++;
}
newNode->next = p->next;  // 新节点指向原第 i 个节点
p->next = newNode;        // 第 i-1 个节点指向新节点
```

#### 选择建议

- **如果只需要在头部插入**：使用**头插法**（最快，O(1)）
- **如果需要保持插入顺序**：使用**尾插法**（考虑维护尾指针优化）
- **如果需要在任意位置插入**：使用**指定位置插入**（最通用）

---

### 3. 删除操作

#### 3.1 删除指定位置的节点

**功能：** 删除第 i 个位置的节点

**不带头节点版本：**
```c
Status ListDelete(LinkList *L, int i, int *e) {
    if (i < 1 || *L == NULL) return ERROR;
    
    LNode *p = *L;
    if (i == 1) {
        *L = p->next;
        *e = p->data;
        free(p);
        return OK;
    }
    
    int j = 1;
    while (p && j < i - 1) {
        p = p->next;
        j++;
    }
    
    if (!(p->next) || j > i - 1) return ERROR;
    
    LNode *q = p->next;
    p->next = q->next;
    *e = q->data;
    free(q);
    return OK;
}
```

**带头节点版本：**
```c
Status ListDelete(LinkList L, int i, int *e) {
    if (i < 1) return ERROR;
    
    LNode *p = L;
    int j = 0;
    while (p->next && j < i - 1) {
        p = p->next;
        j++;
    }
    
    if (!(p->next) || j > i - 1) return ERROR;
    
    LNode *q = p->next;
    p->next = q->next;
    *e = q->data;
    free(q);
    return OK;
}
```

**删除过程图示（不带头节点）：**

```
删除前：删除位置3的节点
head → [10] → [20] → [30] → [40] → null
        [1]    [2]    [3]    [4]

步骤1：找到第 i-1 个节点（位置2）
prev → [20]

步骤2：跳过第 i 个节点
prev.next = prev.next.next

删除后：
head → [10] → [20] → [40] → null
```

**删除过程图示（带头节点）：**

```
删除前：删除位置3的节点
head → [dummy] → [10] → [20] → [30] → [40] → null
       (头节点)   [1]    [2]    [3]    [4]

步骤1：从头节点开始，找到第 i-1 个节点（位置2）
prev → [20]

步骤2：跳过第 i 个节点
prev.next = prev.next.next

删除后：
head → [dummy] → [10] → [20] → [40] → null
```

**时间复杂度：** O(n) - 需要找到删除位置

**关键区别：**
- **不带头节点**：删除位置1需要特殊处理（更新head）
- **带头节点**：所有位置统一处理（从head开始遍历）

#### 3.2 删除指定值的节点

**功能：** 删除第一个值为 data 的节点

```c
Status ListDeleteByValue(LinkList *L, int e) {
    // 如果链表为空
    if (*L == NULL) return FALSE;
    
    LNode *p = *L;
    
    // 如果删除头节点
    if (p->data == e) {
        *L = p->next;
        free(p);
        return TRUE;
    }
    
    // 找到要删除节点的前驱节点
    while (p->next != NULL && p->next->data != e) {
        p = p->next;
    }
    
    // 如果找到了
    if (p->next != NULL) {
        LNode *q = p->next;
        p->next = q->next;
        free(q);
        return TRUE;
    }
    
    return FALSE;  // 未找到
}
```

**时间复杂度：** O(n)

---

### 4. 查找操作

#### 4.1 按位置查找

**功能：** 查找第 i 个位置的节点

**不带头节点版本：**
```c
Status GetElem(LinkList L, int i, int *e) {
    if (i < 1 || L == NULL) return ERROR;
    
    LNode *p = L;
    int j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    
    if (!p) return ERROR;
    *e = p->data;
    return OK;
}
```

**带头节点版本：**
```c
Status GetElem(LinkList L, int i, int *e) {
    if (i < 1 || L->next == NULL) return ERROR;
    
    LNode *p = L->next;  // 从头节点的next开始
    int j = 1;
    while (p && j < i) {
        p = p->next;
        j++;
    }
    
    if (!p) return ERROR;
    *e = p->data;
    return OK;
}
```

**时间复杂度：** O(n) - 必须从头遍历

#### 4.2 按值查找

**功能：** 查找值为 data 的节点位置

**不带头节点版本：**
```c
int LocateElem(LinkList L, int e) {
    LNode *p = L;
    int j = 1;
    while (p) {
        if (p->data == e) return j;
        p = p->next;
        j++;
    }
    return 0;  // 未找到
}
```

**带头节点版本：**
```c
int LocateElem(LinkList L, int e) {
    LNode *p = L->next;  // 从头节点的next开始
    int j = 1;
    while (p) {
        if (p->data == e) return j;
        p = p->next;
        j++;
    }
    return 0;  // 未找到
}
```

**时间复杂度：** O(n)

---

### 5. 遍历操作

**功能：** 访问链表中的所有元素

**不带头节点版本：**
```c
void PrintList(LinkList L) {
    if (L == NULL) {
        printf("链表为空！\n");
        return;
    }
    
    LNode *p = L;
    printf("链表内容（不带头节点）：");
    while (p != NULL) {
        printf("%d", p->data);
        if (p->next != NULL) {
            printf(" -> ");
        }
        p = p->next;
    }
    printf("\n");
}
```

**带头节点版本：**
```c
void PrintList(LinkList L) {
    if (L->next == NULL) {
        printf("链表为空！\n");
        return;
    }
    
    LNode *p = L->next;  // 从头节点的next开始
    printf("链表内容（带头节点）：");
    while (p != NULL) {
        printf("%d", p->data);
        if (p->next != NULL) {
            printf(" -> ");
        }
        p = p->next;
    }
    printf("\n");
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(1)

---

### 6. 判空操作

**功能：** 判断链表是否为空

**不带头节点版本：**
```c
Status ListEmpty(LinkList L) {
    if (L == NULL) return TRUE;
    else return FALSE;
}
```

**带头节点版本：**
```c
Status ListEmpty(LinkList L) {
    if (L->next == NULL) return TRUE;
    else return FALSE;
}
```

**时间复杂度：** O(1)

---

### 7. 获取长度

**功能：** 获取链表的当前长度

**方法1：使用length变量（如果维护）**
```c
int ListLength(LinkList L) {
    // 假设结构体中有length字段，或者全局维护
    // 这里仅演示遍历计算
    return 0; 
}
```

**方法2：遍历计算**
```c
int ListLength(LinkList L) {
    int count = 0;
    LNode *p = L->next; // 假设带头节点
    while (p != NULL) {
        count++;
        p = p->next;
    }
    return count;
}
```

**时间复杂度：** 方法1为 O(1)，方法2为 O(n)

---

## 四、时间复杂度总结

| 操作 | 最好情况 | 平均情况 | 最坏情况 | 说明 |
|------|---------|---------|---------|------|
| **头插** | O(1) | O(1) | O(1) | 直接操作头指针 |
| **尾插** | O(1) | O(n) | O(n) | 需要遍历到尾部 |
| **指定位置插入** | O(1) | O(n) | O(n) | 需要找到插入位置 |
| **头删** | O(1) | O(1) | O(1) | 直接操作头指针 |
| **指定位置删除** | O(1) | O(n) | O(n) | 需要找到删除位置 |
| **按位置查找** | O(1) | O(n) | O(n) | 必须从头遍历 |
| **按值查找** | O(1) | O(n) | O(n) | 必须从头遍历 |
| **遍历** | O(n) | O(n) | O(n) | 必须访问所有节点 |
| **判空** | O(1) | O(1) | O(1) | 常数时间 |
| **获取长度** | O(1) | O(1) | O(n) | 取决于实现方式 |

---

## 五、空间复杂度

**总空间复杂度：** O(n)

**空间组成：**
- 数据存储：O(n) - 存储 n 个节点
- 指针存储：O(n) - 每个节点需要一个指针
- 辅助空间：O(1) - 只需几个变量

**存储密度：** 较低（需要额外存储指针）

---

## 六、优缺点分析

### ✅ 优点

1. **动态分配**：不需要预分配空间，按需分配
2. **插入删除快**：在已知位置插入删除，时间复杂度 O(1)
3. **空间利用灵活**：可以充分利用内存空间
4. **不需要移动元素**：插入删除只需要修改指针

### ❌ 缺点

1. **访问慢**：必须从头开始遍历，时间复杂度 O(n)
2. **存储密度低**：需要额外的指针空间
3. **不支持随机存取**：不能像数组一样通过下标直接访问
4. **内存开销**：每个节点需要额外的指针空间

---

## 七、应用场景

### 适合使用单链表的场景

1. **频繁插入删除**：如文本编辑器、动态数组
2. **数据量变化大**：如队列、栈的链式实现
3. **不需要随机访问**：如多项式相加、大整数运算
4. **内存受限**：可以充分利用内存碎片

### 不适合使用单链表的场景

1. **频繁查询**：适合使用顺序表或数组
2. **需要随机访问**：适合使用数组
3. **存储密度要求高**：适合使用顺序表

---

## 八、完整代码示例

### 查看完整实现

- **[LinkListWithoutHead.java](../代码练习/02-链表/LinkListWithoutHead.java)** - 不带头节点完整实现
- **[LinkListWithHead.java](../代码练习/02-链表/LinkListWithHead.java)** - 带头节点完整实现

### 代码示例摘要

**不带头节点版本核心代码：**
```java
// 节点类
class ListNode {
    int data;
    ListNode next;
    
    ListNode(int data) {
        this.data = data;
        this.next = null;
    }
}

// 单链表类（不带头节点）
public class LinkListWithoutHead {
    private ListNode head;
    private int length;
    
    public LinkListWithoutHead() {
        this.head = null;
        this.length = 0;
    }
    
    // 插入操作需要特殊处理位置1
    public boolean insert(int i, int data) {
        if (i < 1 || i > length + 1) return false;
        
        ListNode newNode = new ListNode(data);
        if (i == 1) {
            newNode.next = head;  // 特殊处理
            head = newNode;
        } else {
            ListNode prev = head;
            for (int j = 1; j < i - 1; j++) {
                prev = prev.next;
            }
            newNode.next = prev.next;
            prev.next = newNode;
        }
        length++;
        return true;
    }
    
    // 删除操作需要特殊处理位置1
    public Integer delete(int i) {
        if (i < 1 || i > length || head == null) return null;
        
        int deletedValue;
        if (i == 1) {
            deletedValue = head.data;  // 特殊处理
            head = head.next;
        } else {
            ListNode prev = head;
            for (int j = 1; j < i - 1; j++) {
                prev = prev.next;
            }
            deletedValue = prev.next.data;
            prev.next = prev.next.next;
        }
        length--;
        return deletedValue;
    }
}
```

**带头节点版本核心代码：**
```java
// 节点类
class ListNodeWithHead {
    int data;
    ListNodeWithHead next;
    
    ListNodeWithHead(int data) {
        this.data = data;
        this.next = null;
    }
    
    ListNodeWithHead() {
        this.data = 0;  // 头节点构造函数
        this.next = null;
    }
}

// 单链表类（带头节点）
public class LinkListWithHead {
    private ListNodeWithHead head;
    private int length;
    
    public LinkListWithHead() {
        this.head = new ListNodeWithHead();  // 创建头节点
        this.head.next = null;
        this.length = 0;
    }
    
    // 插入操作统一处理，不需要特殊处理位置1
    public boolean insert(int i, int data) {
        if (i < 1 || i > length + 1) return false;
        
        ListNodeWithHead newNode = new ListNodeWithHead(data);
        ListNodeWithHead prev = head;  // 从头节点开始
        for (int j = 0; j < i - 1; j++) {  // 统一操作
            prev = prev.next;
        }
        newNode.next = prev.next;
        prev.next = newNode;
        length++;
        return true;
    }
    
    // 删除操作统一处理，不需要特殊处理位置1
    public Integer delete(int i) {
        if (i < 1 || i > length || head.next == null) return null;
        
        ListNodeWithHead prev = head;  // 从头节点开始
        for (int j = 0; j < i - 1; j++) {  // 统一操作
            prev = prev.next;
        }
        int deletedValue = prev.next.data;
        prev.next = prev.next.next;
        length--;
        return deletedValue;
    }
}
```

### 两种实现的对比总结

| 操作 | 不带头节点 | 带头节点 |
|------|-----------|---------|
| **初始化** | `head = null` | `head = new ListNode()` |
| **空链表判断** | `head == null` | `head.next == null` |
| **插入位置1** | 需要 `if (i == 1)` 特殊处理 | 统一操作，无需特殊处理 |
| **删除位置1** | 需要 `if (i == 1)` 特殊处理 | 统一操作，无需特殊处理 |
| **遍历起点** | `current = head` | `current = head.next` |
| **代码行数** | 较多（需要判断） | 较少（统一处理） |
| **空间开销** | 节省一个节点 | 多一个头节点 |
| **推荐使用** | 空间受限场景 | 代码简洁优先 |

---

## 九、常见考点

### 1. 链表的反转

**问题：** 如何反转一个单链表？

**算法：** 使用三个指针，逐个反转节点间的连接

```c
void ListReverse(LinkList L) {
    LNode *prev = NULL;
    LNode *curr = L->next; // 假设带头节点
    LNode *next = NULL;
    
    while (curr != NULL) {
        next = curr->next;      // 保存下一个节点
        curr->next = prev;      // 反转当前节点的指针
        prev = curr;            // prev前移
        curr = next;            // curr前移
    }
    
    L->next = prev;  // 更新头节点指向新的第一个节点
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(1)

### 2. 链表的中间节点

**问题：** 如何找到链表的中间节点？

**算法：** 使用快慢指针，快指针一次走两步，慢指针一次走一步

```c
Status GetMiddle(LinkList L, int *e) {
    if (L->next == NULL) return ERROR;
    
    LNode *slow = L->next;
    LNode *fast = L->next;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;        // 慢指针走一步
        fast = fast->next->next;  // 快指针走两步
    }
    
    *e = slow->data;
    return OK;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(1)

### 3. 检测链表是否有环

**问题：** 如何判断链表是否有环？

**算法：** 使用快慢指针，如果有环，快慢指针会相遇

```c
Status HasCycle(LinkList L) {
    if (L->next == NULL) return FALSE;
    
    LNode *slow = L->next;
    LNode *fast = L->next;
    
    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {
            return TRUE;  // 相遇，有环
        }
    }
    
    return FALSE;  // 快指针到达末尾，无环
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(1)

### 4. 合并两个有序链表

**问题：** 如何合并两个有序链表？

**算法：** 使用双指针，比较两个链表的节点值

```c
void MergeList(LinkList La, LinkList Lb, LinkList *Lc) {
    // 已知La和Lb有序，合并为Lc
    LNode *pa = La->next;
    LNode *pb = Lb->next;
    LNode *pc;
    
    *Lc = pc = La;  // 用La的头节点作为Lc的头节点
    
    while (pa && pb) {
        if (pa->data <= pb->data) {
            pc->next = pa;
            pc = pa;
            pa = pa->next;
        } else {
            pc->next = pb;
            pc = pb;
            pb = pb->next;
        }
    }
    
    pc->next = pa ? pa : pb;  // 插入剩余段
    free(Lb);  // 释放Lb的头节点
}
```

**时间复杂度：** O(m + n)  
**空间复杂度：** O(1)

---

## 十、与顺序表的对比

| 特性 | 顺序表 | 单链表 |
|------|--------|--------|
| **存储方式** | 连续存储 | 链式存储 |
| **随机存取** | ✅ O(1) | ❌ O(n) |
| **头插** | ❌ O(n) | ✅ O(1) |
| **尾插** | ✅ O(1) | ❌ O(n) |
| **指定位置插入** | ❌ O(n) | ❌ O(n) |
| **指定位置删除** | ❌ O(n) | ❌ O(n) |
| **存储密度** | ✅ 高 | ❌ 低（需要指针） |
| **内存要求** | 需要连续空间 | 可以分散存储 |
| **动态扩展** | ❌ 困难 | ✅ 容易 |
| **空间预分配** | ✅ 需要 | ❌ 不需要 |
| **代码复杂度** | 简单 | 较复杂（需要指针操作） |

**选择建议：**
- **选择顺序表**：频繁查询、数据量固定、需要随机访问
- **选择单链表**：频繁插入删除、数据量变化大、不需要随机访问

**参考代码：**
- 顺序表：[SqList.c](../代码练习/01-顺序表/SqList.c)
- 单链表：[LinkListWithoutHead.c](../代码练习/02-链表/LinkListWithoutHead.c) | [LinkListWithHead.c](../代码练习/02-链表/LinkListWithHead.c)

---

## 十一、学习要点总结

### ⭐⭐⭐ 必须掌握

1. **单链表的定义和存储结构**
2. **节点的插入和删除操作（头插、尾插、指定位置）**
3. **链表的遍历和查找操作**
4. **时间复杂度分析（插入删除的特殊情况）**

### ⭐⭐ 重要理解

1. **头节点 vs 头指针的区别**
2. **单链表的优缺点及应用场景**
3. **与顺序表的对比**
4. **常见算法：反转、找中间节点、检测环**

### ⭐ 了解内容

1. **静态链表的应用**
2. **链表的变体应用**

---

## 十二、双链表（双向链表）

### 什么是双链表？

**通俗理解：** 双链表就像"双向行驶的道路"，每个节点有两个指针：一个指向前面的节点（前驱），一个指向后面的节点（后继）。可以双向遍历，比单链表更灵活。

### 核心特点

```
┌─────────────────────────────────────────────────────────┐
│                   双链表存储结构                         │
└─────────────────────────────────────────────────────────┘

         null    ←    ←    ←    ←    ←
          ↓                            ↓
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ⇄ [40] → null
       (头节点)  (第一个数据节点)
        ↑                            ↑
         ←    ←    ←    ←    ←    ←
```

**关键特性：**
- ✅ **双向遍历**：可以从前往后，也可以从后往前
- ✅ **删除更方便**：删除节点时不需要找前驱节点（已有prev指针）
- ✅ **插入更方便**：插入操作更容易实现
- ⚠️ **空间开销大**：每个节点需要两个指针（prev和next）
- ⚠️ **维护复杂**：需要同时维护prev和next两个指针

### 节点结构

```c
// 双链表节点结构体
typedef struct DNode {
    int data;              // 数据域
    struct DNode *prev;    // 前驱指针
    struct DNode *next;    // 后继指针
} DNode, *DLinkList;
```

**结构说明：**
- `data`：数据域，存储数据元素
- `prev`：前驱指针，指向前一个节点（头节点的prev为null）
- `next`：后继指针，指向下一个节点（最后一个节点的next为null）

### 双链表类

```c
// 初始化双链表
Status InitDList(DLinkList *L) {
    *L = (DNode *)malloc(sizeof(DNode));
    if (*L == NULL) return ERROR;
    (*L)->prev = NULL;  // 头节点的prev永远为NULL
    (*L)->next = NULL;  // 初始为空
    return OK;
}
```

### 基本操作

#### 1. 插入操作

**头插法：**
```c
Status DListInsertHead(DLinkList L, int e) {
    DNode *s = (DNode *)malloc(sizeof(DNode));
    s->data = e;
    
    s->next = L->next;
    if (L->next != NULL) {
        L->next->prev = s;
    }
    s->prev = L;
    L->next = s;
    return OK;
}
```

**尾插法（利用tail指针优化）：**
```c
Status DListInsertTail(DLinkList L, int e) {
    DNode *s = (DNode *)malloc(sizeof(DNode));
    s->data = e;
    s->next = NULL;
    
    DNode *p = L;
    while (p->next != NULL) {
        p = p->next;
    }
    
    p->next = s;
    s->prev = p;
    return OK;
}
```

**指定位置插入：**
```c
Status DListInsert(DLinkList L, int i, int e) {
    if (i < 1) return ERROR;
    
    DNode *p = L;
    int j = 0;
    while (p && j < i - 1) {
        p = p->next;
        j++;
    }
    
    if (!p) return ERROR;
    
    DNode *s = (DNode *)malloc(sizeof(DNode));
    s->data = e;
    
    s->next = p->next;
    if (p->next != NULL) {
        p->next->prev = s;
    }
    s->prev = p;
    p->next = s;
    return OK;
}
```

**插入过程图示：**
```
插入前：在位置3插入元素99
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ⇄ [40] → null
                 [1]    [2]    [3]    [4]

步骤1：找到第i个节点（位置3）
current → [30]

步骤2：插入新节点（更新4个指针）
newNode.prev = current.prev;      // newNode.prev → [20]
newNode.next = current;            // newNode.next → [30]
current.prev.next = newNode;       // [20].next → newNode
current.prev = newNode;            // [30].prev → newNode

插入后：
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [99] ⇄ [30] ⇄ [40] → null
```

#### 2. 删除操作

**删除指定位置：**
```c
Status DListDelete(DLinkList L, int i, int *e) {
    if (i < 1) return ERROR;
    
    DNode *p = L;
    int j = 0;
    while (p->next && j < i - 1) {
        p = p->next;
        j++;
    }
    
    if (!(p->next) || j > i - 1) return ERROR;
    
    DNode *q = p->next;
    *e = q->data;
    
    p->next = q->next;
    if (q->next != NULL) {
        q->next->prev = p;
    }
    
    free(q);
    return OK;
}
```

**删除过程图示：**
```
删除前：删除位置3的节点
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ⇄ [40] → null
                 [1]    [2]    [3]    [4]

步骤1：找到要删除的节点
current → [30]

步骤2：更新指针（删除节点只需要2步）
current.prev.next = current.next;  // [20].next → [40]
current.next.prev = current.prev;  // [40].prev → [20]

删除后：
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [40] → null
```

**优势：** 删除操作不需要找前驱节点，因为已经有prev指针！

#### 3. 双向遍历

**正向遍历：**
```c
void PrintDList(DLinkList L) {
    DNode *p = L->next;
    while (p != NULL) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}
```

**反向遍历：**
```c
// 需要先找到尾节点
void PrintDListBackward(DLinkList L) {
    DNode *p = L;
    while (p->next != NULL) {
        p = p->next;
    }
    
    while (p != L) {
        printf("%d ", p->data);
        p = p->prev;
    }
    printf("\n");
}
```

#### 4. 反向查找

```c
// 需要维护tail指针或遍历
// 这里省略具体实现
```

### 时间复杂度总结

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| **头插** | O(1) | 直接操作头节点 |
| **尾插** | O(1) | 利用tail指针 |
| **指定位置插入** | O(n) | 需要找到插入位置 |
| **删除** | O(n) | 需要找到删除位置（但删除操作本身更简单） |
| **正向查找** | O(n) | 从前往后遍历 |
| **反向查找** | O(n) | 从后往前遍历 |
| **正向遍历** | O(n) | 从前往后 |
| **反向遍历** | O(n) | 从后往前 |

### 优缺点分析

**✅ 优点：**
1. **双向遍历**：可以从任意方向遍历
2. **删除方便**：删除节点时不需要找前驱节点
3. **插入方便**：插入操作更容易实现
4. **适合频繁删除**：删除操作比单链表更高效

**❌ 缺点：**
1. **空间开销大**：每个节点需要两个指针
2. **维护复杂**：需要同时维护prev和next
3. **代码复杂**：插入删除需要更新更多指针

### 应用场景

- **需要双向遍历的场景**：如浏览器历史记录（前进/后退）
- **频繁删除的场景**：删除操作更方便
- **需要前驱节点的场景**：某些算法需要快速访问前驱节点

**参考代码：** [DoubleLinkList.java](../代码练习/02-链表/DoubleLinkList.java)

---

## 十三、循环链表

### 什么是循环链表？

**通俗理解：** 循环链表就像"环形跑道"，最后一个节点的指针不是指向null，而是指向头节点（或第一个节点），形成一个环。可以从任意节点开始遍历整个链表。

### 分类

1. **循环单链表**：最后一个节点的next指向头节点
2. **循环双链表**：最后一个节点的next指向头节点，头节点的prev指向最后一个节点

### 循环单链表

#### 结构特点

```
┌─────────────────────────────────────────────────────────┐
│               循环单链表存储结构                         │
└─────────────────────────────────────────────────────────┘

head → [dummy] → [10] → [20] → [30] → [40] ┐
       (头节点)                              │
        ↑                                    │
        └────────────────────────────────────┘
                    (循环回到头节点)
```

**关键特性：**
- ✅ **循环结构**：最后一个节点的next指向head
- ✅ **可从任意节点开始遍历**：不需要判断是否到达末尾
- ✅ **适合循环访问**：如轮询、循环队列

#### 节点结构

```c
// 循环单链表节点（同单链表）
typedef struct LNode {
    int data;
    struct LNode *next;
} LNode, *LinkList;
```

#### 循环单链表类

```c
// 初始化循环单链表
Status InitList(LinkList *L) {
    *L = (LNode *)malloc(sizeof(LNode));
    if (*L == NULL) return ERROR;
    (*L)->next = *L;  // 头节点的next指向自己
    return OK;
}

// 判断空
Status ListEmpty(LinkList L) {
    if (L->next == L) return TRUE;
    else return FALSE;
}
```

#### 基本操作

**尾插法：**
```c
Status ListInsertTail(LinkList L, int e) {
    LNode *s = (LNode *)malloc(sizeof(LNode));
    s->data = e;
    
    LNode *p = L;
    while (p->next != L) {  // 关键：判断条件改为 != L
        p = p->next;
    }
    
    s->next = L;  // 新节点的next指向head
    p->next = s;
    return OK;
}
```

**遍历：**
```c
void PrintList(LinkList L) {
    if (L->next == L) {
        printf("循环单链表为空！\n");
        return;
    }
    
    LNode *p = L->next;
    while (p != L) {  // 关键：当回到head时停止
        printf("%d ", p->data);
        p = p->next;
    }
    printf("(循环)\n");
}
```

**关键区别：**
- **单链表**：`current != null` 判断结束
- **循环单链表**：`current != head` 判断结束

### 循环双链表

#### 结构特点

```
┌─────────────────────────────────────────────────────────┐
│               循环双链表存储结构                         │
└─────────────────────────────────────────────────────────┘

        ┌──────────────────────────────────────────┐
        │                                          │
        ↓                                          ↑
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ⇄ [40] ⇄ [dummy]
       (头节点)                                    (头节点)
        ↑                                          │
        └──────────────────────────────────────────┘
            (双向循环：头节点的prev指向最后一个节点)
```

**关键特性：**
- ✅ **双向 + 循环**：既有双向链表的优点，又有循环的特性
- ✅ **可从任意节点双向遍历**：最灵活的链表结构
- ✅ **头节点的prev指向最后一个节点**：快速访问尾部

#### 节点结构

```c
// 循环双链表节点（同双链表）
typedef struct DNode {
    int data;
    struct DNode *prev;
    struct DNode *next;
} DNode, *DLinkList;
```

#### 循环双链表类

```c
// 初始化循环双链表
Status InitDList(DLinkList *L) {
    *L = (DNode *)malloc(sizeof(DNode));
    if (*L == NULL) return ERROR;
    (*L)->next = *L;  // next指向自己
    (*L)->prev = *L;  // prev指向自己
    return OK;
}

// 判断空
Status ListEmpty(DLinkList L) {
    if (L->next == L) return TRUE;
    else return FALSE;
}
```

#### 基本操作

**尾插法（利用head.prev快速找到最后一个节点）：**
```c
Status DListInsertTail(DLinkList L, int e) {
    DNode *s = (DNode *)malloc(sizeof(DNode));
    s->data = e;
    
    // 利用L->prev快速找到最后一个节点
    DNode *last = L->prev;
    
    s->next = L;
    s->prev = last;
    last->next = s;
    L->prev = s;  // 更新head的prev指向新节点
    return OK;
}
```

**正向遍历：**
```c
void PrintDListForward(DLinkList L) {
    DNode *p = L->next;
    while (p != L) {  // 当回到head时停止
        printf("%d ", p->data);
        p = p->next;
    }
    printf("(循环)\n");
}
```

**反向遍历：**
```c
void PrintDListBackward(DLinkList L) {
    DNode *p = L->prev;  // 从最后一个节点开始
    while (p != L) {  // 当回到head时停止
        printf("%d ", p->data);
        p = p->prev;  // 向前遍历
    }
    printf("(循环)\n");
}
```

### 循环链表 vs 普通链表

| 特性 | 普通单链表 | 循环单链表 | 普通双链表 | 循环双链表 |
|------|-----------|-----------|-----------|-----------|
| **尾节点指向** | null | head | null | head |
| **头节点prev** | null | null | null | 最后一个节点 |
| **遍历结束条件** | `current != null` | `current != head` | `current != null` | `current != head` |
| **空链表判断** | `head.next == null` | `head.next == head` | `head.next == null` | `head.next == head` |
| **从任意节点遍历** | ❌ 不行 | ✅ 可以 | ❌ 不行 | ✅ 可以 |
| **访问尾部** | O(n) | O(n) | O(1)（有tail） | O(1)（head.prev） |

### 应用场景

**循环单链表：**
- **循环队列**：队列的链式实现
- **轮询算法**：需要循环访问的场景
- **约瑟夫环问题**：经典的循环链表应用

**循环双链表：**
- **需要双向循环访问的场景**
- **浏览器历史记录**：前进/后退功能
- **音乐播放器的播放列表**：循环播放

**参考代码：** [CircularLinkList.java](../代码练习/02-链表/CircularLinkList.java)

---

## 十四、三种链表的对比总结

### 结构对比

```
单链表：
head → [dummy] → [10] → [20] → [30] → null

双链表：
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] → null
       ↑         ↑         ↑         ↑
      prev     prev     prev     prev

循环单链表：
head → [dummy] → [10] → [20] → [30] ┐
       ↑                              │
       └──────────────────────────────┘

循环双链表：
        ┌──────────────────────────┐
        │                          │
        ↓                          ↑
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ⇄ [dummy]
       ↑                          │
       └──────────────────────────┘
```

### 功能对比表

| 特性 | 单链表 | 双链表 | 循环单链表 | 循环双链表 |
|------|--------|--------|-----------|-----------|
| **前驱指针** | ❌ | ✅ | ❌ | ✅ |
| **后继指针** | ✅ | ✅ | ✅ | ✅ |
| **双向遍历** | ❌ | ✅ | ❌ | ✅ |
| **循环结构** | ❌ | ❌ | ✅ | ✅ |
| **删除操作** | 需要找前驱 | 直接删除 | 需要找前驱 | 直接删除 |
| **空间开销** | 小（1个指针） | 大（2个指针） | 小（1个指针） | 最大（2个指针） |
| **代码复杂度** | 简单 | 中等 | 中等 | 复杂 |
| **访问尾部** | O(n) | O(1)（有tail） | O(n) | O(1)（head.prev） |
| **从任意节点遍历** | ❌ | ❌ | ✅ | ✅ |

### 选择建议

**选择单链表：**
- 只需要单向遍历
- 空间受限
- 简单的插入删除操作

**选择双链表：**
- 需要双向遍历
- 频繁删除操作
- 需要快速访问前驱节点

**选择循环单链表：**
- 需要循环访问
- 实现循环队列
- 约瑟夫环等问题

**选择循环双链表：**
- 需要双向循环访问
- 最灵活的链表结构
- 浏览器历史记录等场景

---

## 总结

```
✅ 单链表 = 链式存储 + 动态分配 + 插入删除快
✅ 适合：频繁插入删除、数据量变化大、不需要随机访问
❌ 不适合：频繁查询、需要随机访问、存储密度要求高
✅ 核心操作时间复杂度：插入O(1)/O(n)、删除O(1)/O(n)、查找O(n)

📌 两种实现方式：
   - 不带头节点：节省空间，但需要特殊处理位置1
   - 带头节点：代码简洁，统一操作，但多一个节点空间

💡 推荐：带头节点实现（代码更简洁，不易出错）

📌 链表变体：
   - 双链表：双向遍历，删除更方便，但空间开销大
   - 循环单链表：循环结构，可从任意节点开始遍历
   - 循环双链表：最灵活，双向+循环，适合复杂场景
```

---

**精简要点**: 单链表是线性表的链式存储实现，理解其动态分配和指针操作是学习链表的基础。两种实现方式各有优缺点，建议熟练掌握带头节点的实现方式 ⚙️✨

**代码参考**：
- [单链表-不带头节点](../代码练习/02-链表/LinkListWithoutHead.c)
- [单链表-带头节点](../代码练习/02-链表/LinkListWithHead.c)
- [双链表-带头节点](../代码练习/02-链表/DoubleLinkList.c)
- [循环链表](../代码练习/02-链表/CircularLinkList.c)

