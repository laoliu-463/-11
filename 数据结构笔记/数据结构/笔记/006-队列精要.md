# 队列精要

> 队列的存储实现核心知识  
> 最后更新：2025年1月

## 📚 相关：[思维导图](./数据结构思维导图.md) | [代码练习](../代码练习/03-栈和队列/) | [顺序表](./001-顺序表精要.md) | [链表](./002-单链表精要.md) | [栈](./005-栈精要.md)

### 📝 代码文件说明
- **[CircularQueue.c](../代码练习/03-栈和队列/CircularQueue.c)** - 循环队列完整实现
- **[LinkQueue.c](../代码练习/03-栈和队列/LinkQueue.c)** - 链队列完整实现

---

## 一、基本概念

### 什么是队列？

**通俗理解：** 队列就像"排队买票"，先来的人先买到票，后来的人排在后面。这是一种**先进先出（FIFO：First In First Out）**的数据结构。

### 核心特点

```
┌─────────────────────────────────────────────────────────┐
│                   队列的存储结构                           │
└─────────────────────────────────────────────────────────┘

    队头（Front）← 唯一允许删除的位置
        ↓
  ┌─────────┐
  │    10   │ ← 最先入队的元素（先进先出）
  ├─────────┤
  │    20   │
  ├─────────┤
  │    30   │ ← 最后入队的元素
  └─────────┘
        ↑
    队尾（Rear）← 唯一允许插入的位置
```

**关键特性：**
- ✅ **先进先出（FIFO）**：先放入的元素先取出
- ✅ **操作受限**：只能在队尾插入，只能在队头删除
- ✅ **操作高效**：入队和出队操作时间复杂度都是 O(1)
- ⚠️ **访问受限**：只能访问队头和队尾元素，不能随机访问
- ⚠️ **大小限制**：顺序队列有容量限制，链队列受内存限制

### 队列的基本操作

队列的基本操作有两种：
1. **入队（Enqueue）**：在队尾插入新元素
2. **出队（Dequeue）**：删除队头元素并返回

其他常用操作：
3. **取队头（Front/Peek）**：获取队头元素但不删除
4. **判空（isEmpty）**：判断队列是否为空
5. **获取大小（size）**：获取队列中元素个数

---

## 二、存储结构

队列有两种实现方式：
1. **顺序队列**：使用数组实现（包括普通顺序队列和循环队列）
2. **链队列**：使用链表实现

### 顺序队列

#### 普通顺序队列的问题

**假溢出问题：**

```
初始状态：front=0, rear=0
┌─────┬─────┬─────┬─────┐
│  10 │  20 │  30 │     │
└─────┴─────┴─────┴─────┘
  ↑              ↑
front=0        rear=3

执行两次出队：
┌─────┬─────┬─────┬─────┐
│     │     │  30 │     │
└─────┴─────┴─────┴─────┘
        ↑          ↑
      front=2    rear=3

此时虽然前面有空位，但rear已经到达数组末尾
如果继续入队，会报错"队列已满"，但实际上还有空间！
这就是"假溢出"问题。
```

**解决方案：** 使用**循环队列**（将数组首尾相连）

#### 循环队列

**存储结构：**

```c
#define MAXSIZE 100

// 循环队列结构体
typedef struct {
    int data[MAXSIZE]; // 存储队列元素的数组
    int front;         // 队头指针
    int rear;          // 队尾指针
} SqQueue;
```

**结构说明：**
- `data`：数组，存储队列元素
- `front`：队头指针，指向队头元素
- `rear`：队尾指针，指向队尾元素的下一个位置
- `capacity`：队列的最大容量（实际分配 capacity+1 个空间）

**循环队列的循环特性：**

```
数组大小为5（索引0-4），循环使用：

rear = 4 时，下一个位置是 (4+1) % 5 = 0
front = 4 时，下一个位置是 (4+1) % 5 = 0

┌─────┬─────┬─────┬─────┬─────┐
│  10 │  20 │  30 │  40 │     │
└─────┴─────┴─────┴─────┴─────┘
  ↑                           ↑
front=0                    rear=4

入队50后：
┌─────┬─────┬─────┬─────┬─────┐
│  10 │  20 │  30 │  40 │  50 │
└─────┴─────┴─────┴─────┴─────┘
  ↑
front=0, rear=0 (rear = (4+1) % 5 = 0)
```

**内存布局：**

```
循环队列在内存中的布局：

┌────────────────────────────────────┐
│  CircularQueue 对象（堆内存）        │
│  ┌──────────────────────────────┐ │
│  │ data: [10, 20, 30, ...]      │ │  MAXSIZE*4字节
│  │ front = 0                    │ │  4字节（int）
│  │ rear = 0                     │ │  4字节（int）
│  └──────────────────────────────┘ │
│                                    │
│  数组（堆内存）                     │
│  ┌─────┬─────┬─────┬─────┬─────┐ │
│  │  10 │  20 │  30 │  40 │  50 │ │  每个int 4字节
│  └─────┴─────┴─────┴─────┴─────┘ │
│    ↑                              │
│  front=0, rear=0                  │
└────────────────────────────────────┘
         ↑
       栈底
```

**特点：**
- 队头元素在 `data[front]`
- 队尾元素在 `data[(rear-1+capacity)%capacity]`
- 循环队列通过取模运算实现循环
- 需要多分配一个空间来区分空和满的状态

---

### 链队列

#### 存储结构

```c
// 链队列节点结构体
typedef struct QueueNode {
    int data;
    struct QueueNode *next;
} QueueNode;

// 链队列结构体
typedef struct {
    QueueNode *front; // 队头指针
    QueueNode *rear;  // 队尾指针
    int length;       // 队列长度
} LinkQueue;
```

**结构说明：**
- `front`：队头指针，指向队头节点
- `rear`：队尾指针，指向队尾节点
- `size`：队列中元素个数

**内存布局：**

```
链队列在内存中的布局：

┌────────────────────────────────────┐
│  LinkQueue 对象（堆内存）            │
│  ┌──────────────────────────────┐ │
│  │ front (指针) → 节点1          │ │  8字节（指针）
│  │ rear (指针) → 节点3           │ │  8字节（指针）
│  │ length = 3                   │ │  4字节（int）
│  └──────────────────────────────┘ │
│                                    │
│  节点1（堆内存）                    │
│  ┌─────────┬─────────┐            │
│  │ data=10 │ next ───┼──→ 节点2   │
│  └─────────┴─────────┘            │
│                                    │
│  节点2（堆内存）                    │
│  ┌─────────┬─────────┐            │
│  │ data=20 │ next ───┼──→ 节点3   │
│  └─────────┴─────────┘            │
│                                    │
│  节点3（堆内存）                    │
│  ┌─────────┬─────────┐            │
│  │ data=30 │ next=null│            │
│  └─────────┴─────────┘            │
└────────────────────────────────────┘
         ↑
       栈底
```

**特点：**
- 队头元素在链表的第一个节点
- 队尾元素在链表的最后一个节点
- 链队列没有容量限制（受内存限制）
- 需要维护队头和队尾两个指针

---

## 三、基本操作

### 循环队列操作

#### 1. 初始化

**功能：** 创建一个空的循环队列

```c
// 初始化循环队列
Status InitQueue(SqQueue *Q) {
    Q->front = 0;
    Q->rear = 0;
    return OK;
}
```

**时间复杂度：** O(1)  
**空间复杂度：** O(n)

#### 2. 入队（Enqueue）

**功能：** 在队尾插入新元素

```c
Status EnQueue(SqQueue *Q, int e) {
    // 检查队列是否已满
    if ((Q->rear + 1) % MAXSIZE == Q->front) {
        return ERROR;  // 队列满
    }
    
    // 将元素放入队尾，然后队尾指针循环加1
    Q->data[Q->rear] = e;
    Q->rear = (Q->rear + 1) % MAXSIZE;
    return OK;
}
```

**入队过程图示：**

```
入队前：队列中有2个元素，capacity=5
┌─────┬─────┬─────┬─────┬─────┐
│  10 │  20 │     │     │     │
└─────┴─────┴─────┴─────┴─────┘
  ↑              ↑
front=0        rear=2

执行 enqueue(30)：

步骤1：将30放入data[rear]
data[2] = 30

步骤2：rear指针循环加1
rear = (2 + 1) % 5 = 3

入队后：
┌─────┬─────┬─────┬─────┬─────┐
│  10 │  20 │  30 │     │     │
└─────┴─────┴─────┴─────┴─────┘
  ↑                   ↑
front=0             rear=3
```

**时间复杂度：** O(1)

#### 3. 出队（Dequeue）

**功能：** 删除队头元素并返回

```c
Status DeQueue(SqQueue *Q, int *e) {
    // 检查队列是否为空
    if (Q->front == Q->rear) {
        return ERROR;  // 队列空
    }
    
    // 保存队头元素，然后队头指针循环加1
    *e = Q->data[Q->front];
    Q->front = (Q->front + 1) % MAXSIZE;
    return OK;
}
```

**出队过程图示：**

```
出队前：队列中有3个元素
┌─────┬─────┬─────┬─────┬─────┐
│  10 │  20 │  30 │     │     │
└─────┴─────┴─────┴─────┴─────┘
  ↑                   ↑
front=0             rear=3

执行 dequeue()：

步骤1：保存队头元素
value = data[0] = 10

步骤2：front指针循环加1
front = (0 + 1) % 5 = 1

出队后：
┌─────┬─────┬─────┬─────┬─────┐
│     │  20 │  30 │     │     │
└─────┴─────┴─────┴─────┴─────┘
        ↑               ↑
      front=1         rear=3
```

**时间复杂度：** O(1)

#### 4. 取队头（Front）

**功能：** 获取队头元素但不删除

```c
Status GetHead(SqQueue Q, int *e) {
    if (Q.front == Q.rear) {
        return ERROR;
    }
    *e = Q.data[Q.front];  // 返回队头元素，front不变
    return OK;
}
```

**时间复杂度：** O(1)

#### 5. 判空

**功能：** 判断队列是否为空

```c
Status QueueEmpty(SqQueue Q) {
    if (Q.front == Q.rear) return TRUE;
    else return FALSE;
}
```

**时间复杂度：** O(1)

**空队列图示：**

```
空队列：front == rear
┌─────┬─────┬─────┬─────┬─────┐
│     │     │     │     │     │
└─────┴─────┴─────┴─────┴─────┘
  ↑
front=0, rear=0
```

#### 6. 判满

**功能：** 判断队列是否已满

```c
Status QueueFull(SqQueue Q) {
    if ((Q.rear + 1) % MAXSIZE == Q.front) return TRUE;
    else return FALSE;
}
```

**时间复杂度：** O(1)

**满队列图示：**

```
满队列：(rear + 1) % capacity == front
┌─────┬─────┬─────┬─────┬─────┐
│  10 │  20 │  30 │  40 │     │
└─────┴─────┴─────┴─────┴─────┘
  ↑                           ↑
front=0                    rear=4

(rear + 1) % MAXSIZE == (4 + 1) % 5 = 0 == front
所以队列已满（注意：实际只用了4个位置，留一个位置区分空和满）
```

**为什么需要多分配一个空间？**

```
如果不留一个空位，空队列和满队列无法区分：

空队列：front == rear = 0
┌─────┬─────┬─────┬─────┐
│     │     │     │     │
└─────┴─────┴─────┴─────┘
  ↑
front=rear=0

满队列：front == rear = 0（如果不用空位）
┌─────┬─────┬─────┬─────┐
│  10 │  20 │  30 │  40 │
└─────┴─────┴─────┴─────┘
  ↑
front=rear=0

两者无法区分！

解决方案：多分配一个空间，满队列时留一个空位
满队列：(rear + 1) % MAXSIZE == front
┌─────┬─────┬─────┬─────┬─────┐
│  10 │  20 │  30 │  40 │     │  ← 留一个空位
└─────┴─────┴─────┴─────┴─────┘
  ↑                           ↑
front=0                    rear=4
```

#### 7. 获取大小

**功能：** 获取队列中元素个数

```c
int QueueLength(SqQueue Q) {
    return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
}
```

**时间复杂度：** O(1)

**大小计算示例：**

```
情况1：rear >= front
┌─────┬─────┬─────┬─────┬─────┐
│  10 │  20 │  30 │     │     │
└─────┴─────┴─────┴─────┴─────┘
  ↑                   ↑
front=0             rear=3
size = (3 - 0 + 5) % 5 = 3

情况2：rear < front（循环情况）
┌─────┬─────┬─────┬─────┬─────┐
│     │     │  30 │  40 │  50 │
└─────┴─────┴─────┴─────┴─────┘
        ↑           ↑
      front=2     rear=0
size = (0 - 2 + 5) % 5 = 3
```

---

### 链队列操作

#### 1. 初始化

**功能：** 创建一个空的链队列

```c
// 初始化链队列
Status InitLinkQueue(LinkQueue *Q) {
    Q->front = NULL;
    Q->rear = NULL;
    Q->length = 0;
    return OK;
}
```

**时间复杂度：** O(1)  
**空间复杂度：** O(1)

#### 2. 入队（Enqueue）

**功能：** 在队尾插入新元素

```c
Status EnQueueLink(LinkQueue *Q, int e) {
    QueueNode *p = (QueueNode *)malloc(sizeof(QueueNode));
    p->data = e;
    p->next = NULL;
    
    if (Q->front == NULL) {
        // 空队列：新节点既是队头也是队尾
        Q->front = p;
        Q->rear = p;
    } else {
        // 非空队列：将新节点连接到队尾
        Q->rear->next = p;
        Q->rear = p;  // 更新队尾指针
    }
    Q->length++;
    return OK;
}
```

**入队过程图示：**

```
入队前：队列中有2个元素
front → [10] → [20] → null
              ↑
             rear

执行 enqueue(30)：

步骤1：创建新节点
newNode = [30]

步骤2：将新节点连接到队尾
rear.next = newNode
front → [10] → [20] → [30] → null
                        ↑
                       rear

步骤3：更新队尾指针
rear = newNode
```

**时间复杂度：** O(1)

#### 3. 出队（Dequeue）

**功能：** 删除队头元素并返回

```c
Status DeQueueLink(LinkQueue *Q, int *e) {
    if (Q->front == NULL) {
        return ERROR;  // 队列空
    }
    
    QueueNode *p = Q->front;
    *e = p->data;      // 保存队头元素的值
    Q->front = p->next; // 队头指针指向下一个节点
    
    if (Q->front == NULL) {
        // 如果队列变空，队尾指针也要置为null
        Q->rear = NULL;
    }
    
    free(p);
    Q->length--;
    return OK;
}
```

**出队过程图示：**

```
出队前：队列中有3个元素
front → [10] → [20] → [30] → null
                        ↑
                       rear

执行 dequeue()：

步骤1：保存队头元素的值
value = front.data = 10

步骤2：队头指针指向下一个节点
front = front.next
        front → [20] → [30] → null
                        ↑
                       rear

步骤3：返回value
return 10
```

**时间复杂度：** O(1)

#### 4. 取队头（Front）

**功能：** 获取队头元素但不删除

```c
Status GetHeadLink(LinkQueue Q, int *e) {
    if (Q.front == NULL) {
        return ERROR;
    }
    *e = Q.front->data;  // 返回队头元素，front不变
    return OK;
}
```

**时间复杂度：** O(1)

#### 5. 判空

**功能：** 判断队列是否为空

```c
Status LinkQueueEmpty(LinkQueue Q) {
    if (Q.front == NULL) return TRUE;
    else return FALSE;
}
```

**时间复杂度：** O(1)

#### 6. 获取大小

**功能：** 获取队列中元素个数

```c
int LinkQueueLength(LinkQueue Q) {
    return Q.length;
}
```

**时间复杂度：** O(1)

---

## 四、顺序队列 vs 链队列

### 对比表

| 特性 | 循环队列（顺序队列） | 链队列 |
|------|---------------------|--------|
| **存储结构** | 数组 | 链表 |
| **空间效率** | 高（不需要额外指针） | 低（每个节点需要指针） |
| **容量限制** | 有（需要预先分配） | 无（受内存限制） |
| **访问速度** | 快（数组访问） | 慢（需要遍历） |
| **实现复杂度** | 中等（需要处理循环） | 简单（链表操作） |
| **空间浪费** | 可能（如果容量过大） | 无（按需分配） |
| **扩容** | 困难（需要重新分配） | 容易（动态分配） |

### 选择建议

**使用循环队列的场景：**
- 队列大小可以预估
- 需要高效的访问速度
- 内存空间有限
- 不需要频繁扩容

**使用链队列的场景：**
- 队列大小无法预估
- 需要动态扩展
- 内存空间充足
- 实现简单优先

---

## 五、时间复杂度分析

### 循环队列

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| 初始化 | O(1) | 创建数组和初始化变量 |
| 入队 | O(1) | 直接访问数组位置 |
| 出队 | O(1) | 直接访问数组位置 |
| 取队头 | O(1) | 直接访问数组位置 |
| 判空 | O(1) | 比较两个指针 |
| 判满 | O(1) | 比较两个指针 |
| 获取大小 | O(1) | 计算指针差值 |

### 链队列

| 操作 | 时间复杂度 | 说明 |
|------|-----------|------|
| 初始化 | O(1) | 初始化指针和变量 |
| 入队 | O(1) | 直接连接新节点 |
| 出队 | O(1) | 直接删除队头节点 |
| 取队头 | O(1) | 直接访问队头节点 |
| 判空 | O(1) | 检查队头指针 |
| 获取大小 | O(1) | 返回size变量 |

**总结：** 队列的所有基本操作都是 **O(1)** 时间复杂度，这是队列的核心优势。

---

## 六、空间复杂度分析

### 循环队列

- **空间复杂度：** O(n)
  - 数组空间：O(n)，n为队列容量
  - 额外空间：O(1)，只有几个变量（front、rear、capacity）

### 链队列

- **空间复杂度：** O(n)
  - 节点空间：O(n)，n为队列中元素个数
  - 每个节点需要额外的指针空间
  - 额外空间：O(1)，只有几个变量（front、rear、size）

**对比：**
- 循环队列：空间效率高，但容量固定
- 链队列：空间效率低（有指针开销），但动态分配

---

## 七、应用场景

### 1. 层次遍历（BFS）

**问题：** 二叉树的层次遍历

**算法：** 使用队列保存每一层的节点

```c
void BFS(int start, int *visited, int graph[][MAX_VERTICES], int numVertices) {
    SqQueue Q;
    InitQueue(&Q);
    EnQueue(&Q, start);
    visited[start] = 1;
    int node;
    
    while (!QueueEmpty(Q)) {
        DeQueue(&Q, &node);
        printf("%d ", node);
        
        // 访问所有邻接节点
        for (int i = 0; i < numVertices; i++) {
            if (graph[node][i] == 1 && !visited[i]) {
                EnQueue(&Q, i);
                visited[i] = 1;
            }
        }
    }
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(n)

### 2. 缓冲区

**问题：** 生产者-消费者问题中的缓冲区

**算法：** 使用队列作为缓冲区，生产者入队，消费者出队

```c
// 缓冲区结构体
typedef struct {
    SqQueue queue;
    int maxSize;
} Buffer;

// 生产者：入队
void Produce(Buffer *b, int item) {
    if (QueueLength(b->queue) >= b->maxSize) {
        // 缓冲区满，等待 (需使用线程同步机制)
        return;
    }
    EnQueue(&b->queue, item);
    // 通知消费者
}

// 消费者：出队
int Consume(Buffer *b) {
    if (QueueEmpty(b->queue)) {
        // 缓冲区空，等待
        return -1;
    }
    int item;
    DeQueue(&b->queue, &item);
    // 通知生产者
    return item;
}
```

**时间复杂度：** O(1)  
**空间复杂度：** O(n)

### 3. 消息队列

**问题：** 系统间的消息传递

**算法：** 使用队列保存消息，按顺序处理

```c
// 消息结构体
typedef struct {
    int id;
    char content[100];
} Message;

// 消息队列结构体
typedef struct {
    LinkQueue queue;
} MessageQueue;

// 发送消息
void SendMessage(MessageQueue *mq, Message msg) {
    // 假设LinkQueue支持Message类型，或者这里简化为int
    // EnQueueLink(&mq->queue, msg); 
}

// 接收消息
Message ReceiveMessage(MessageQueue *mq) {
    Message msg;
    // DeQueueLink(&mq->queue, &msg);
    return msg;
}
```

**时间复杂度：** O(1)  
**空间复杂度：** O(n)

### 4. 广度优先搜索（BFS）

**问题：** 图的广度优先遍历

**算法：** 使用队列保存待访问的节点

```c
void BFS_Graph(int start, int *visited, int graph[][MAX_VERTICES], int numVertices) {
    // 同上文BFS实现
}
```

**时间复杂度：** O(V + E)，V为顶点数，E为边数  
**空间复杂度：** O(V)

### 5. 任务调度

**问题：** 操作系统的任务调度

**算法：** 使用队列保存待执行的任务

```c
typedef struct {
    LinkQueue taskQueue;
} TaskScheduler;

void AddTask(TaskScheduler *ts, int taskID) {
    EnQueueLink(&ts->taskQueue, taskID);
}

void ExecuteTasks(TaskScheduler *ts) {
    int taskID;
    while (!LinkQueueEmpty(ts->taskQueue)) {
        DeQueueLink(&ts->taskQueue, &taskID);
        // Execute(taskID);
    }
}
```

**时间复杂度：** O(1)（单个操作）  
**空间复杂度：** O(n)

---

## 八、常见面试题

### 1. 用两个栈实现队列

**问题：** 使用两个栈实现一个队列

**思路：** 一个栈用于入队，一个栈用于出队

```c
typedef struct {
    SqStack stack1; // 用于入队
    SqStack stack2; // 用于出队
} QueueWithTwoStacks;

void Q2S_Enqueue(QueueWithTwoStacks *Q, int x) {
    Push(&Q->stack1, x);
}

Status Q2S_Dequeue(QueueWithTwoStacks *Q, int *e) {
    if (StackEmpty(Q->stack2)) {
        while (!StackEmpty(Q->stack1)) {
            int val;
            Pop(&Q->stack1, &val);
            Push(&Q->stack2, val);
        }
    }
    if (StackEmpty(Q->stack2)) return ERROR;
    Pop(&Q->stack2, e);
    return OK;
}
```

**时间复杂度：** 
- 入队：O(1)
- 出队：平均O(1)，最坏O(n)（需要倒栈）

**空间复杂度：** O(n)

### 2. 用两个队列实现栈

**问题：** 使用两个队列实现一个栈

**思路：** 一个队列用于存储，另一个队列用于辅助

```c
typedef struct {
    LinkQueue queue1;
    LinkQueue queue2;
} StackWithTwoQueues;

void S2Q_Push(StackWithTwoQueues *S, int x) {
    EnQueueLink(&S->queue1, x);
}

Status S2Q_Pop(StackWithTwoQueues *S, int *e) {
    if (LinkQueueEmpty(S->queue1)) return ERROR;
    
    int val;
    while (LinkQueueLength(S->queue1) > 1) {
        DeQueueLink(&S->queue1, &val);
        EnQueueLink(&S->queue2, val);
    }
    
    DeQueueLink(&S->queue1, e);
    
    // 交换queue1和queue2
    LinkQueue temp = S->queue1;
    S->queue1 = S->queue2;
    S->queue2 = temp;
    
    return OK;
}
```

**时间复杂度：** 
- 入栈：O(1)
- 出栈：O(n)

**空间复杂度：** O(n)

### 3. 设计循环队列

**问题：** 设计一个循环队列，支持入队、出队、判空、判满操作

**思路：** 使用数组实现，多分配一个空间区分空和满

```c
// 参见前文 SqQueue 实现
```

**时间复杂度：** 所有操作都是O(1)  
**空间复杂度：** O(n)

### 4. 滑动窗口最大值

**问题：** 给定数组和窗口大小k，找出每个窗口的最大值

**思路：** 使用双端队列（单调队列）保存可能的最大值

```c
void MaxSlidingWindow(int *nums, int numsSize, int k, int *result) {
    int *deque = (int *)malloc(sizeof(int) * numsSize);
    int front = 0, rear = -1;
    int resIdx = 0;
    
    for (int i = 0; i < numsSize; i++) {
        // 移除窗口外的元素
        if (front <= rear && deque[front] < i - k + 1) {
            front++;
        }
        // 移除小于当前元素的元素（保持单调递减）
        while (front <= rear && nums[deque[rear]] < nums[i]) {
            rear--;
        }
        deque[++rear] = i;
        
        // 窗口形成后，记录最大值
        if (i >= k - 1) {
            result[resIdx++] = nums[deque[front]];
        }
    }
    free(deque);
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(k)

---

## 九、学习要点总结

### ⭐⭐⭐ 必须掌握

1. **队列的定义和特点**（FIFO：先进先出）
2. **循环队列的实现**（数组、循环特性、判空判满）
3. **链队列的实现**（链表、队头队尾指针）
4. **基本操作**（入队、出队、取队头、判空）
5. **时间复杂度分析**（所有操作都是O(1)）

### ⭐⭐ 重要理解

1. **循环队列的循环特性**（取模运算）
2. **循环队列的空满判断**（为什么需要多分配一个空间）
3. **顺序队列 vs 链队列的选择**
4. **队列的应用场景**（BFS、缓冲区、消息队列等）

### ⭐ 了解内容

1. **双端队列（Deque）**及其应用
2. **优先队列（Priority Queue）**及其应用
3. **队列相关的算法题**（用栈实现队列、滑动窗口等）
4. **队列在系统中的应用**（任务调度、消息队列等）

---

## 总结

```
✅ 队列 = 先进先出（FIFO）+ 队头删除 + 队尾插入
✅ 适合：需要先进先出的场景、BFS、缓冲区、消息队列
❌ 不适合：需要随机访问、需要后进先出的场景

📌 核心特点：
   - 先进先出（FIFO：First In First Out）
   - 操作受限：只能在队尾插入，只能在队头删除
   - 操作高效：所有基本操作都是O(1)

💡 实现方式：
   - 循环队列：使用数组，需要处理循环和空满判断
   - 链队列：使用链表，动态分配，实现简单

⚠️ 注意事项：
   - 循环队列需要多分配一个空间区分空和满
   - 循环队列的判空：front == rear
   - 循环队列的判满：(rear + 1) % capacity == front
   - 链队列需要维护队头和队尾两个指针
```

---

**精简要点**: 队列是一种先进先出（FIFO）的线性数据结构，只能在队尾插入，只能在队头删除。循环队列和链队列各有优缺点，所有基本操作都是O(1)时间复杂度。队列广泛应用于BFS、缓冲区、消息队列等场景 📚✨

**代码参考**：
- [循环队列完整实现](../代码练习/03-栈和队列/CircularQueue.c)
- [链队列完整实现](../代码练习/03-栈和队列/LinkQueue.c)

