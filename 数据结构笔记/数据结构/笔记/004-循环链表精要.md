# 循环链表精要

> 循环链表的链式存储实现核心知识  
> 最后更新：2025年1月

## 📚 相关：[思维导图](./数据结构思维导图.md) | [代码练习](../代码练习/02-链表/) | [单链表](./002-单链表精要.md) | [双链表](./003-双链表精要.md)

### 📝 代码文件说明
- **[CircularLinkList.java](../代码练习/02-链表/CircularLinkList.java)** - 循环链表（单链表+双链表）完整实现

---

## 一、基本概念

### 什么是循环链表？

**通俗理解：** 循环链表就像"一个圆环"，链表的最后一个节点不是指向 `null`，而是指向头节点（或第一个节点），形成一个环形结构。可以从任意节点开始遍历整个链表，不需要判断是否到达链表末尾。

### 核心特点

```
┌─────────────────────────────────────────────────────────┐
│               循环单链表存储结构                          │
└─────────────────────────────────────────────────────────┘

         ←    ←    ←    ←    ←    ←    ←
          ↓                            ↓
head → [dummy] → [10] → [20] → [30] → [40] ┐
       (头节点)  (第一个数据节点)            │
          ↑                               │
          └───────────────────────────────┘
                (形成循环)
```

**关键特性：**
- ✅ **循环结构**：最后一个节点的next指向头节点（或第一个节点）
- ✅ **可以从任意节点开始遍历**：不需要判断是否到达链表末尾
- ✅ **遍历终止条件**：通过判断是否回到起始节点
- ✅ **适合循环访问**：适合需要循环访问的场景（如轮询、循环队列）
- ⚠️ **注意循环判断**：遍历时必须注意终止条件，避免无限循环
- ⚠️ **需要头节点**：通常使用头节点来简化循环判断

### 分类

循环链表分为两种：

1. **循环单链表**：最后一个节点的next指向头节点
2. **循环双链表**：最后一个节点的next指向头节点，头节点的prev指向最后一个节点

### 与普通链表的区别

| 特性 | 普通单链表 | 循环单链表 | 普通双链表 | 循环双链表 |
|------|------------|------------|------------|------------|
| **最后一个节点指向** | null | head（头节点） | null | head（头节点） |
| **头节点的prev** | - | - | null | 最后一个节点 |
| **遍历终止条件** | current == null | current == head | current == null | current == head |
| **判空条件** | head.next == null | head.next == head | head.next == null | head.next == head |
| **可以从任意节点开始** | ❌ | ✅ | ❌ | ✅ |
| **适合循环访问** | ❌ | ✅ | ❌ | ✅ |

---

## 二、循环单链表

### 2.1 存储结构

#### 节点结构

```java
// 循环单链表节点类（与普通单链表相同）
class CircularSingleListNode {
    int data;                          // 数据域：存储数据元素
    CircularSingleListNode next;       // 指针域：指向下一个节点
    
    CircularSingleListNode(int data) {
        this.data = data;
        this.next = null;
    }
    
    CircularSingleListNode() {
        this.data = 0;
        this.next = null;
    }
}
```

**结构说明：**
- `data`：数据域，存储数据元素
- `next`：指针域，指向下一个节点（最后一个节点的next指向head）

#### 循环单链表类

```java
public class CircularSingleLinkList {
    private CircularSingleListNode head;  // 头指针（指向头节点）
    private int length;                   // 链表长度
    
    /**
     * 构造函数：创建空的循环单链表
     */
    public CircularSingleLinkList() {
        this.head = new CircularSingleListNode();
        this.head.next = head;  // 关键：头节点的next指向自己，形成循环
        this.length = 0;
    }
}
```

**结构说明：**
- `head`：头指针，指向头节点（头节点不存储数据）
- `length`：链表的当前长度
- **关键点**：头节点的next指向自己，表示空链表

#### 内存布局

```
循环单链表在内存中的布局：

┌────────────────────────────────────┐
│  CircularSingleLinkList 对象       │
│  ┌──────────────────────────────┐ │
│  │ head (引用) → 头节点          │ │  8字节（引用）
│  └──────────────────────────────┘ │
│  ┌──────────────────────────────┐ │
│  │ length: 3                    │ │  4字节
│  └──────────────────────────────┘ │
└────────────────────────────────────┘
         │
         ↓
┌────────────────────────────────────┐
│  头节点（堆内存）                   │
│  ┌──────┬──────┐                  │
│  │ data │ next │→ ...             │  4字节 + 8字节 = 12字节
│  └──────┴──────┘                  │
└────────────────────────────────────┘
         │
         ↓
┌────────────────────────────────────┐
│  节点1（堆内存）                    │
│  ┌──────┬──────┐                  │
│  │ data │ next │→ ...             │  12字节
│  └──────┴──────┘                  │
└────────────────────────────────────┘
         │
         ↓
┌────────────────────────────────────┐
│  节点2（堆内存）                    │
│  ┌──────┬──────┐                  │
│  │ data │ next │→ ...             │  12字节
│  └──────┴──────┘                  │
└────────────────────────────────────┘
         │
         ↓
┌────────────────────────────────────┐
│  节点3（堆内存）                    │
│  ┌──────┬──────┐                  │
│  │ data │ next │→ head（循环）    │  12字节
│  └──────┴──────┘                  │
└────────────────────────────────────┘
```

**循环结构：** 最后一个节点的next指向head，形成循环

---

### 2.2 基本操作

#### 2.2.1 初始化

**功能：** 创建一个空的循环单链表

```java
public CircularSingleLinkList() {
    this.head = new CircularSingleListNode();
    this.head.next = head;  // 关键：头节点的next指向自己
    this.length = 0;
}
```

**时间复杂度：** O(1)  
**空间复杂度：** O(1)

**关键点：**
- 头节点的next指向自己，表示空链表
- 这是判断空链表的关键条件

#### 2.2.2 判空操作

**功能：** 判断链表是否为空

```java
public boolean isEmpty() {
    return head.next == head;  // 头节点的next指向自己表示空链表
}
```

**时间复杂度：** O(1)

**与普通单链表的区别：**
- **普通单链表**：`head.next == null` 表示空链表
- **循环单链表**：`head.next == head` 表示空链表

#### 2.2.3 尾插法（在链表尾部插入）

**功能：** 在链表尾部插入新节点

```java
public void insertAtTail(int data) {
    CircularSingleListNode newNode = new CircularSingleListNode(data);
    
    // 找到最后一个节点（next指向head的节点）
    CircularSingleListNode current = head;
    while (current.next != head) {  // 关键：判断条件改为head而不是null
        current = current.next;
    }
    
    // 插入新节点
    newNode.next = head;      // 新节点的next指向head（形成循环）
    current.next = newNode;   // 最后一个节点指向新节点
    length++;
}
```

**插入过程图示：**

```
插入前：在尾部插入元素 99
head → [dummy] → [10] → [20] → [30] ┐
       (头节点)                      │
          ↑                          │
          └──────────────────────────┘

步骤1：找到最后一个节点（next指向head的节点）
current → [30] (current.next == head)

步骤2：插入新节点
newNode.next = head        // [99].next → [dummy]
current.next = newNode     // [30].next → [99]

插入后：
head → [dummy] → [10] → [20] → [30] → [99] ┐
       (头节点)                              │
          ↑                                  │
          └──────────────────────────────────┘
```

**时间复杂度：** O(n) - 需要找到最后一个节点

**关键点：**
- 遍历终止条件：`current.next != head`（而不是 `current.next != null`）
- 新节点的next必须指向head，保持循环结构

#### 2.2.4 头插法（在链表头部插入）

**功能：** 在链表头部插入新节点

```java
public void insertAtHead(int data) {
    CircularSingleListNode newNode = new CircularSingleListNode(data);
    newNode.next = head.next;  // 新节点指向原第一个数据节点
    head.next = newNode;       // 头节点指向新节点
    length++;
}
```

**时间复杂度：** O(1)

**与普通单链表的区别：**
- 代码相同，但新插入的节点会保持循环结构（因为原第一个节点的next已指向head）

#### 2.2.5 在指定位置插入

**功能：** 在第 i 个位置插入新节点

```java
public boolean insert(int i, int data) {
    if (i < 1 || i > length + 1) {
        return false;
    }
    
    CircularSingleListNode newNode = new CircularSingleListNode(data);
    CircularSingleListNode prev = head;
    
    // 找到第i-1个节点（前驱节点）
    for (int j = 0; j < i - 1; j++) {
        prev = prev.next;
    }
    
    // 插入新节点
    newNode.next = prev.next;
    prev.next = newNode;
    length++;
    return true;
}
```

**时间复杂度：** O(n)

**关键点：**
- 插入操作与普通单链表相同
- 循环结构会自动保持（因为插入位置的后续节点已正确连接）

#### 2.2.6 删除操作

**功能：** 删除第 i 个位置的节点

```java
public Integer delete(int i) {
    if (i < 1 || i > length || isEmpty()) {
        return null;
    }
    
    CircularSingleListNode prev = head;
    for (int j = 0; j < i - 1; j++) {
        prev = prev.next;
    }
    
    int deletedValue = prev.next.data;
    prev.next = prev.next.next;  // 删除节点
    length--;
    return deletedValue;
}
```

**时间复杂度：** O(n)

**关键点：**
- 删除操作与普通单链表相同
- 循环结构会自动保持（因为删除后的前后节点仍正确连接）

#### 2.2.7 遍历操作

**功能：** 遍历输出链表（循环一次）

```java
public void print() {
    if (isEmpty()) {
        System.out.println("循环单链表为空！");
        return;
    }
    
    CircularSingleListNode current = head.next;
    System.out.print("循环单链表：");
    while (current != head) {  // 关键：当回到head时停止
        System.out.print(current.data);
        if (current.next != head) {
            System.out.print(" → ");
        }
        current = current.next;
    }
    System.out.println(" (循环)");
}
```

**时间复杂度：** O(n)

**关键点：**
- **遍历终止条件**：`current != head`（而不是 `current != null`）
- 这是循环链表遍历的核心区别

**遍历示例：**

```java
// 链表：10 → 20 → 30 (循环)
list.print();  
// 输出：循环单链表：10 → 20 → 30 (循环)
```

---

## 三、循环双链表

> **参考**：循环双链表的基础结构与普通双链表相同，请参考[双链表笔记](./003-双链表精要.md)。本节重点说明循环双链表与普通双链表的**区别**。

### 3.1 存储结构

#### 节点结构

**节点结构与普通双链表相同**（参考[双链表笔记](./003-双链表精要.md)），区别在于：
- 最后一个节点的`next`指向`head`（而不是`null`）
- `head`的`prev`指向最后一个节点（而不是`null`）

#### 循环双链表类

```java
public class CircularDoubleLinkList {
    private CircularDoubleListNode head;  // 头指针（指向头节点）
    private int length;                   // 链表长度
    
    /**
     * 构造函数：创建空的循环双链表
     */
    public CircularDoubleLinkList() {
        this.head = new CircularDoubleListNode();
        this.head.next = head;  // 头节点的next指向自己（关键）
        this.head.prev = head;  // 头节点的prev指向自己（关键）
        this.length = 0;
    }
}
```

**关键区别：**
- **普通双链表**：`head.next = null`，`head.prev = null` 表示空链表
- **循环双链表**：`head.next = head`，`head.prev = head` 表示空链表

#### 循环结构图示

```
循环双链表结构：

head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ┐
       (头节点)                      │
          ↑                          │
          └──────────────────────────┘
       (形成循环)

关键点：
- 最后一个节点的next指向head
- head的prev指向最后一个节点
- 第一个数据节点的prev指向head
- head的next指向第一个数据节点
```

---

### 3.2 基本操作

> **说明**：循环双链表的大部分操作与普通双链表相同（参考[双链表笔记](./003-双链表精要.md)），主要区别在于：
> - 判空条件：`head.next == head`（而不是 `head.next == null`）
> - 遍历终止条件：`current != head`（而不是 `current != null`）
> - 利用`head.prev`可以快速找到最后一个节点（O(1)尾插优势）

#### 3.2.1 判空操作

**功能：** 判断链表是否为空

```java
public boolean isEmpty() {
    return head.next == head;  // 头节点的next指向自己表示空链表
}
```

**时间复杂度：** O(1)

**与普通双链表的区别：**
- **普通双链表**：`head.next == null` 表示空链表
- **循环双链表**：`head.next == head` 表示空链表

#### 3.2.2 尾插法（在链表尾部插入）

**功能：** 在链表尾部插入新节点（利用head.prev快速找到最后一个节点）

```java
public void insertAtTail(int data) {
    CircularDoubleListNode newNode = new CircularDoubleListNode(data);
    
    // 利用head.prev快速找到最后一个节点（循环双链表的优势）
    CircularDoubleListNode last = head.prev;
    
    // 插入新节点（需要更新4个指针）
    newNode.next = head;         // 新节点的next指向head
    newNode.prev = last;         // 新节点的prev指向最后一个节点
    last.next = newNode;         // 最后一个节点指向新节点
    head.prev = newNode;         // head的prev指向新节点（关键）
    
    length++;
}
```

**插入过程图示：**

```
插入前：在尾部插入元素 99
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ┐
       (头节点)                      │
          ↑                          │
          └──────────────────────────┘

步骤1：利用head.prev快速找到最后一个节点（循环双链表的优势）
last = head.prev → [30]

步骤2：插入新节点（更新4个指针）
newNode.next = head        // [99].next → [dummy]
newNode.prev = last        // [99].prev → [30]
last.next = newNode       // [30].next → [99]
head.prev = newNode       // [dummy].prev → [99]

插入后：
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ⇄ [99] ┐
       (头节点)                              │
          ↑                                  │
          └──────────────────────────────────┘
```

**时间复杂度：** O(1) - 利用head.prev快速找到最后一个节点

**优势：** 相比循环单链表的尾插法（O(n)），循环双链表的尾插法可以达到O(1)

#### 3.2.3 其他操作

**说明**：头插法、指定位置插入、删除等操作与普通双链表相同（参考[双链表笔记](./003-双链表精要.md)），只是需要确保循环结构正确维护。

**时间复杂度：**
- 头插：O(1)
- 指定位置插入：O(n)
- 删除：O(n)

#### 3.2.4 遍历操作

**功能：** 正向遍历输出链表

```java
public void printForward() {
    if (isEmpty()) {
        System.out.println("循环双链表为空！");
        return;
    }
    
    CircularDoubleListNode current = head.next;
    System.out.print("循环双链表（正向）：");
    while (current != head) {  // 关键：当回到head时停止
        System.out.print(current.data);
        if (current.next != head) {
            System.out.print(" ⇄ ");
        }
        current = current.next;
    }
    System.out.println(" (循环)");
}
```

**时间复杂度：** O(n)

**功能：** 反向遍历输出链表

```java
public void printBackward() {
    if (isEmpty()) {
        System.out.println("循环双链表为空！");
        return;
    }
    
    CircularDoubleListNode current = head.prev;  // 从最后一个节点开始
    System.out.print("循环双链表（反向）：");
    while (current != head) {  // 关键：当回到head时停止
        System.out.print(current.data);
        if (current.prev != head) {
            System.out.print(" ⇄ ");
        }
        current = current.prev;  // 向前遍历
    }
    System.out.println(" (循环)");
}
```

**时间复杂度：** O(n)

**关键点：**
- **正向遍历终止条件**：`current != head`
- **反向遍历终止条件**：`current != head`
- 可以从任意节点开始遍历整个链表

---

## 四、时间复杂度总结

### 循环单链表

| 操作 | 最好情况 | 平均情况 | 最坏情况 | 说明 |
|------|---------|---------|---------|------|
| **头插** | O(1) | O(1) | O(1) | 直接操作头节点 |
| **尾插** | O(n) | O(n) | O(n) | 需要找到最后一个节点 |
| **指定位置插入** | O(1) | O(n) | O(n) | 需要找到插入位置 |
| **删除** | O(1) | O(n) | O(n) | 需要找到删除位置 |
| **查找** | O(1) | O(n) | O(n) | 必须从头遍历 |
| **遍历** | O(n) | O(n) | O(n) | 必须访问所有节点 |
| **判空** | O(1) | O(1) | O(1) | 常数时间 |

### 循环双链表

| 操作 | 最好情况 | 平均情况 | 最坏情况 | 说明 |
|------|---------|---------|---------|------|
| **头插** | O(1) | O(1) | O(1) | 直接操作头节点 |
| **尾插** | O(1) | O(1) | O(1) | 利用head.prev快速找到最后一个节点 |
| **指定位置插入** | O(1) | O(n) | O(n) | 需要找到插入位置 |
| **删除** | O(1) | O(n) | O(n) | 需要找到删除位置 |
| **正向查找** | O(1) | O(n) | O(n) | 必须从头遍历 |
| **反向查找** | O(1) | O(n) | O(n) | 必须从尾遍历 |
| **正向遍历** | O(n) | O(n) | O(n) | 必须访问所有节点 |
| **反向遍历** | O(n) | O(n) | O(n) | 必须访问所有节点 |
| **判空** | O(1) | O(1) | O(1) | 常数时间 |

**关键对比：**

| 操作 | 循环单链表 | 循环双链表 | 优势 |
|------|------------|------------|------|
| **尾插** | O(n) | O(1) | 循环双链表利用head.prev优化 |
| **反向查找** | ❌ 不支持 | ✅ O(n) | 循环双链表特有功能 |
| **反向遍历** | ❌ 不支持 | ✅ O(n) | 循环双链表特有功能 |

---

## 五、空间复杂度

**总空间复杂度：** O(n)

**空间组成：**
- **循环单链表**：数据存储 O(n) + 指针存储 O(n) = O(2n)
- **循环双链表**：数据存储 O(n) + 指针存储 O(2n) = O(3n)（参考[双链表笔记](./003-双链表精要.md)）
- 辅助空间：O(1) - 只需几个变量（head、length）

**存储密度：**
- **循环单链表**：每个节点 4字节（data）+ 8字节（next） = 12字节
- **循环双链表**：每个节点 4字节（data）+ 8字节（prev）+ 8字节（next） = 20字节（与普通双链表相同）

---

## 六、优缺点分析

### ✅ 优点

1. **可以从任意节点开始遍历**：不需要从头节点开始
2. **适合循环访问**：适合需要循环访问的场景（如轮询、循环队列）
3. **遍历终止条件简单**：通过判断是否回到起始节点
4. **循环双链表尾插优化**：利用head.prev可以实现O(1)的尾插操作
5. **循环双链表双向遍历**：支持正向和反向遍历

### ❌ 缺点

1. **需要特别注意循环判断**：遍历时必须注意终止条件，避免无限循环
2. **代码复杂度稍高**：需要维护循环结构
3. **空间开销**：循环双链表需要额外的prev指针

---

## 七、应用场景

### 适合使用循环链表的场景

1. **需要循环访问的场景**
   - 轮询：循环访问任务列表
   - 循环队列：使用循环链表实现循环队列
   - 轮盘游戏：循环访问玩家

2. **需要从任意节点开始遍历**
   - 某些算法需要从中间节点开始遍历
   - 需要多次遍历链表的场景

3. **循环双链表的特殊应用**
   - 需要频繁尾插和反向遍历的场景
   - 需要从任意节点双向遍历的场景

### 不适合使用循环链表的场景

1. **简单的线性访问**：只需要从头到尾访问一次
2. **不需要循环访问**：普通链表已经足够
3. **空间受限**：循环双链表需要额外的prev指针

---

## 八、与普通链表的详细对比

### 结构对比

#### 循环单链表 vs 普通单链表

```
普通单链表：
head → [dummy] → [10] → [20] → [30] → null

循环单链表：
head → [dummy] → [10] → [20] → [30] ┐
       (头节点)                      │
          ↑                          │
          └──────────────────────────┘
```

#### 循环双链表 vs 普通双链表

```
普通双链表：
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] → null
       (头节点)                        ↑
                                     null

循环双链表：
head → [dummy] ⇄ [10] ⇄ [20] ⇄ [30] ┐
       (头节点)                      │
          ↑                          │
          └──────────────────────────┘
```

### 操作对比

#### 判空操作对比

**普通单链表：**
```java
public boolean isEmpty() {
    return head.next == null;  // 头节点的next为null表示空链表
}
```

**循环单链表：**
```java
public boolean isEmpty() {
    return head.next == head;  // 头节点的next指向自己表示空链表
}
```

#### 遍历操作对比

**普通单链表：**
```java
public void print() {
    ListNode current = head.next;
    while (current != null) {  // 终止条件：current == null
        System.out.print(current.data);
        current = current.next;
    }
}
```

**循环单链表：**
```java
public void print() {
    CircularSingleListNode current = head.next;
    while (current != head) {  // 终止条件：current == head
        System.out.print(current.data);
        current = current.next;
    }
}
```

#### 尾插操作对比

**循环单链表（需要遍历）：**
```java
public void insertAtTail(int data) {
    CircularSingleListNode newNode = new CircularSingleListNode(data);
    CircularSingleListNode current = head;
    while (current.next != head) {  // 找到最后一个节点
        current = current.next;
    }
    newNode.next = head;
    current.next = newNode;
}
```

**循环双链表（利用head.prev优化）：**
```java
public void insertAtTail(int data) {
    CircularDoubleListNode newNode = new CircularDoubleListNode(data);
    CircularDoubleListNode last = head.prev;  // 直接找到最后一个节点（O(1)）
    newNode.next = head;
    newNode.prev = last;
    last.next = newNode;
    head.prev = newNode;
}
```

**关键区别：**
- **循环单链表**：尾插需要O(n)时间（需要遍历找到最后一个节点）
- **循环双链表**：尾插只需要O(1)时间（利用head.prev直接找到最后一个节点）
- **普通双链表**：尾插需要O(1)时间（利用tail指针），参考[双链表笔记](./003-双链表精要.md)

---

## 九、常见考点

### 1. 判断链表是否有环

**问题：** 如何判断一个链表是否有环？

**算法：** 使用快慢指针（Floyd判圈算法）

```java
// 判断循环链表是否有环（循环链表本身就有环）
public boolean hasCycle() {
    if (head.next == head) {
        return false;  // 空链表没有环
    }
    
    CircularSingleListNode slow = head.next;
    CircularSingleListNode fast = head.next;
    
    while (fast != head && fast.next != head) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            return true;  // 快慢指针相遇，说明有环
        }
    }
    
    return false;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(1)

### 2. 查找循环链表的入口节点

**问题：** 如何找到循环链表的入口节点（头节点）？

**算法：** 使用快慢指针找到相遇点，然后一个指针从头开始，一个指针从相遇点开始

```java
public CircularSingleListNode findEntry() {
    if (head.next == head) {
        return null;  // 空链表
    }
    
    CircularSingleListNode slow = head.next;
    CircularSingleListNode fast = head.next;
    
    // 找到相遇点
    while (fast != head && fast.next != head) {
        slow = slow.next;
        fast = fast.next.next;
        
        if (slow == fast) {
            break;  // 找到相遇点
        }
    }
    
    // 一个指针从头开始，一个指针从相遇点开始
    CircularSingleListNode p1 = head.next;
    CircularSingleListNode p2 = slow;
    
    while (p1 != p2) {
        p1 = p1.next;
        p2 = p2.next;
    }
    
    return p1;  // 返回入口节点
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(1)

### 3. 循环链表的长度计算

**问题：** 如何计算循环链表的长度？

**算法：** 从任意节点开始遍历，直到回到起始节点

```java
public int getLength() {
    if (head.next == head) {
        return 0;
    }
    
    int count = 0;
    CircularSingleListNode current = head.next;
    
    while (current != head) {
        count++;
        current = current.next;
    }
    
    return count;
}
```

**时间复杂度：** O(n)  
**空间复杂度：** O(1)

---

## 十、学习要点总结

### ⭐⭐⭐ 必须掌握

1. **循环链表的定义和存储结构**（最后一个节点指向头节点）
2. **判空条件**（head.next == head）
3. **遍历终止条件**（current != head）
4. **循环单链表和循环双链表的区别**

### ⭐⭐ 重要理解

1. **循环链表 vs 普通链表的区别和优势**
2. **循环双链表的尾插优化**（利用head.prev）
3. **遍历时避免无限循环**（注意终止条件）
4. **循环链表的应用场景**

### ⭐ 了解内容

1. **循环链表的变体应用**
2. **循环链表的算法题**（判断环、找入口节点等）

---

## 总结

```
✅ 循环链表 = 最后一个节点指向头节点 + 可以从任意节点开始遍历
✅ 适合：需要循环访问、从任意节点开始遍历的场景
❌ 不适合：简单的线性访问、不需要循环访问的场景

📌 核心特点：
   - 最后一个节点的next指向头节点（循环单链表）
   - 最后一个节点的next指向head，head的prev指向最后一个节点（循环双链表）
   - 判空条件：head.next == head
   - 遍历终止条件：current != head

💡 优势：
   - 可以从任意节点开始遍历整个链表
   - 适合循环访问的场景
   - 循环双链表可以实现O(1)的尾插操作

⚠️ 注意事项：
   - 遍历时必须注意终止条件，避免无限循环
   - 需要正确维护循环结构
```

---

**精简要点**: 循环链表通过最后一个节点指向头节点形成环形结构，可以从任意节点开始遍历。适合需要循环访问的场景，但遍历时需要注意终止条件避免无限循环 🔄✨

**代码参考**：
- [循环链表完整实现](../代码练习/02-链表/CircularLinkList.java)

