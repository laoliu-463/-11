 # 图精要

> 图的数据结构核心知识  
> 最后更新：2025年1月

## 📚 相关：[树精要](./007-树精要.md) | [时间复杂度精要](./009-时间复杂度精要.md) | [代码练习](../代码练习/06-图/) | [思维导图](./数据结构思维导图.md)

---

## 📑 目录

- [一、基本概念](#一基本概念)
  - [1.1 图的定义](#11-图的定义)
  - [1.2 基本术语](#12-基本术语)
  - [1.3 图的分类](#13-图的分类)
- [二、存储结构](#二存储结构)
  - [2.1 邻接矩阵](#21-邻接矩阵)
  - [2.2 邻接表](#22-邻接表)
  - [2.3 十字链表](#23-十字链表)
  - [2.4 邻接多重表](#24-邻接多重表)
- [三、图的遍历](#三图的遍历)
  - [3.1 深度优先搜索（DFS）](#31-深度优先搜索dfs)
  - [3.2 广度优先搜索（BFS）](#32-广度优先搜索bfs)
- [四、最小生成树](#四最小生成树)
  - [4.1 基本概念](#41-基本概念)
  - [4.2 Prim算法](#42-prim算法)
  - [4.3 Kruskal算法](#43-kruskal算法)
- [五、最短路径](#五最短路径)
  - [5.1 基本概念](#51-基本概念)
  - [5.2 Dijkstra算法](#52-dijkstra算法)
  - [5.3 Floyd算法](#53-floyd算法)
- [六、拓扑排序](#六拓扑排序)
  - [6.1 基本概念](#61-基本概念)
  - [6.2 算法思想](#62-算法思想)
  - [6.3 Kahn算法（基于BFS）](#63-kahn算法基于bfs)
  - [6.3.1 DFS算法（基于深度优先搜索）](#631-dfs算法基于深度优先搜索)
  - [6.4 算法示例详解](#64-算法示例详解)
  - [6.5 Kahn算法 vs DFS算法](#65-kahn算法-vs-dfs算法)
  - [6.6 实际应用案例](#66-实际应用案例)
  - [6.7 时间复杂度分析](#67-时间复杂度分析)
  - [6.8 常见考点](#68-常见考点)
- [七、关键路径](#七关键路径)
  - [7.1 基本概念](#71-基本概念)
  - [7.2 算法思想](#72-算法思想)
  - [7.3 算法步骤详解](#73-算法步骤详解)
  - [7.4 算法实现](#74-算法实现)
  - [7.5 算法示例详解](#75-算法示例详解)
  - [7.6 应用场景](#76-应用场景)
  - [7.7 时间复杂度分析](#77-时间复杂度分析)
  - [7.8 常见考点](#78-常见考点)
- [八、时间复杂度总结](#八时间复杂度总结)

---

## 一、基本概念

### 1.1 图的定义

**图（Graph）** 是由顶点（Vertex）和边（Edge）组成的数据结构，用于表示多对多的关系。

**形式化定义：**
- 图 G = (V, E)
- V：顶点的有限非空集合
- E：边的有限集合（边是顶点的有序对或无序对）

**通俗理解：**
图就像"城市交通网络"：
- 顶点 = 城市
- 边 = 城市之间的道路
- 有向图 = 单行道
- 无向图 = 双向道路

---

### 1.2 基本术语

#### 顶点相关

- **顶点（Vertex/Node）**：图中的节点
- **度（Degree）**：与顶点相连的边的数量
  - **入度（In-Degree）**：指向该顶点的边的数量（有向图）
  - **出度（Out-Degree）**：从该顶点出发的边的数量（有向图）
- **邻接点（Adjacent）**：通过边直接相连的顶点

#### 边相关

- **边（Edge/Arc）**：连接两个顶点的线段
- **有向边（Directed Edge）**：有方向的边，用有序对 <u, v> 表示
- **无向边（Undirected Edge）**：无方向的边，用无序对 (u, v) 表示
- **权（Weight）**：边上的数值，表示距离、成本等

#### 路径相关

- **路径（Path）**：从顶点u到顶点v的顶点序列
- **路径长度**：路径上边的数量（或权值之和）
- **简单路径**：路径中顶点不重复
- **回路/环（Cycle）**：起点和终点相同的路径
- **简单回路**：除起点和终点外，其他顶点不重复的回路

#### 连通性相关

- **连通**：无向图中，顶点u到v存在路径
- **连通图**：任意两个顶点都连通的无向图
- **连通分量**：无向图的极大连通子图
- **强连通**：有向图中，顶点u到v和v到u都存在路径
- **强连通图**：任意两个顶点都强连通的有向图
- **强连通分量**：有向图的极大强连通子图

#### 其他术语

- **子图（Subgraph）**：图的顶点和边的子集
- **生成树（Spanning Tree）**：包含所有顶点的连通子图（树）
- **完全图**：任意两个顶点都有边相连
- **稀疏图**：边数远少于完全图的边数
- **稠密图**：边数接近完全图的边数

---

### 1.3 图的分类

#### 按边的方向分类

1. **无向图（Undirected Graph）**
   - 边没有方向
   - 边用 (u, v) 表示
   - 示例：社交网络（朋友关系）

2. **有向图（Directed Graph/Digraph）**
   - 边有方向
   - 边用 <u, v> 表示
   - 示例：网页链接、任务依赖关系

#### 按边的权值分类

1. **无权图（Unweighted Graph）**
   - 边没有权值
   - 只表示连接关系

2. **有权图/带权图（Weighted Graph）**
   - 边有权值
   - 表示距离、成本等
   - 示例：地图（城市间距离）、网络（带宽）

#### 按连通性分类

1. **连通图**：任意两个顶点都连通
2. **非连通图**：存在不连通的顶点对

#### 综合分类示例

```
无向无权图：社交网络
无向有权图：地图（城市间距离）
有向无权图：网页链接图
有向有权图：任务依赖图（带时间）
```

---

## 二、存储结构

### 2.1 邻接矩阵

**邻接矩阵（Adjacency Matrix）** 使用二维数组表示图的边关系。

**存储方式：**
- 对于图 G = (V, E)，使用 n×n 的矩阵 A
- A[i][j] = 1 表示顶点 i 和 j 之间有边
- A[i][j] = 0 表示顶点 i 和 j 之间没有边
- 对于有权图，A[i][j] = 权值（无边时为∞）

**实现：**

```c
#define MAX_VERTICES 100
#define INF INT_MAX

typedef struct {
    int matrix[MAX_VERTICES][MAX_VERTICES];  // 邻接矩阵
    int vertexCount;  // 顶点数
    int directed;     // 是否为有向图 (1:是, 0:否)
    int weighted;     // 是否为有权图 (1:是, 0:否)
} GraphAdjMatrix;

void InitGraphAdjMatrix(GraphAdjMatrix *g, int n, int directed, int weighted) {
    g->vertexCount = n;
    g->directed = directed;
    g->weighted = weighted;
    
    // 初始化：无权图初始化为0，有权图初始化为无穷大
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (weighted) {
                g->matrix[i][j] = (i == j) ? 0 : INF;
            } else {
                g->matrix[i][j] = 0;
            }
        }
    }
}

// 添加边
void AddEdgeMatrix(GraphAdjMatrix *g, int from, int to, int weight) {
    g->matrix[from][to] = weight;
    if (!g->directed) {
        g->matrix[to][from] = weight;  // 无向图，对称
    }
}

// 添加边（无权图）
void AddEdgeMatrixUnweighted(GraphAdjMatrix *g, int from, int to) {
    AddEdgeMatrix(g, from, to, 1);
}

// 判断是否有边
int HasEdgeMatrix(GraphAdjMatrix *g, int from, int to) {
    if (g->weighted) {
        return g->matrix[from][to] != INF && g->matrix[from][to] != 0;
    }
    return g->matrix[from][to] != 0;
}

// 获取边的权值
int GetWeightMatrix(GraphAdjMatrix *g, int from, int to) {
    return g->matrix[from][to];
}
```

**示例：**

```
无向图：
    0---1
    |   |
    2---3

邻接矩阵：
      0  1  2  3
    0[0  1  1  0]
    1[1  0  0  1]
    2[1  0  0  1]
    3[0  1  1  0]

有向图：
    0 → 1
    ↓   ↑
    2 → 3

邻接矩阵：
      0  1  2  3
    0[0  1  1  0]
    1[0  0  0  0]
    2[0  0  0  1]
    3[0  1  0  0]
```

**优缺点：**

✅ **优点：**
- 判断两个顶点是否相邻：O(1)
- 添加/删除边：O(1)
- 适合稠密图

❌ **缺点：**
- 空间复杂度：O(V²)
- 遍历所有邻接点：O(V)
- 不适合稀疏图（浪费空间）

**时间复杂度：**
- 空间复杂度：O(V²)
- 添加边：O(1)
- 删除边：O(1)
- 查找边：O(1)
- 遍历所有边：O(V²)

---

### 2.2 邻接表

**邻接表（Adjacency List）** 使用链表数组表示图的边关系。

**存储方式：**
- 为每个顶点维护一个链表
- 链表中存储该顶点的所有邻接点
- 对于有权图，链表节点还存储边的权值

**实现：**

```c
// 边节点（邻接表节点）
typedef struct EdgeNode {
    int to;        // 目标顶点
    int weight;    // 边的权值
    struct EdgeNode *next; // 下一个邻接点
} EdgeNode;

typedef struct {
    EdgeNode *adjList[MAX_VERTICES];  // 邻接表数组
    int vertexCount;     // 顶点数
    int directed;        // 是否为有向图
    int weighted;        // 是否为有权图
} GraphAdjList;

void InitGraphAdjList(GraphAdjList *g, int n, int directed, int weighted) {
    g->vertexCount = n;
    g->directed = directed;
    g->weighted = weighted;
    for (int i = 0; i < n; i++) {
        g->adjList[i] = NULL;
    }
}

// 创建新边节点
EdgeNode* CreateEdgeNode(int to, int weight) {
    EdgeNode *node = (EdgeNode*)malloc(sizeof(EdgeNode));
    node->to = to;
    node->weight = weight;
    node->next = NULL;
    return node;
}

// 添加边
void AddEdgeList(GraphAdjList *g, int from, int to, int weight) {
    // 头插法
    EdgeNode *newNode = CreateEdgeNode(to, weight);
    newNode->next = g->adjList[from];
    g->adjList[from] = newNode;
    
    // 无向图，添加反向边
    if (!g->directed) {
        EdgeNode *reverseNode = CreateEdgeNode(from, weight);
        reverseNode->next = g->adjList[to];
        g->adjList[to] = reverseNode;
    }
}

// 添加边（无权图）
void AddEdgeListUnweighted(GraphAdjList *g, int from, int to) {
    AddEdgeList(g, from, to, 1);
}

// 判断是否有边
int HasEdgeList(GraphAdjList *g, int from, int to) {
    EdgeNode *current = g->adjList[from];
    while (current != NULL) {
        if (current->to == to) {
            return 1;
        }
        current = current->next;
    }
    return 0;
}
```

**示例：**

```
无向图：
    0---1
    |   |
    2---3

邻接表：
0: 1 → 2 → null
1: 0 → 3 → null
2: 0 → 3 → null
3: 1 → 2 → null
```

**优缺点：**

✅ **优点：**
- 空间复杂度：O(V + E)
- 遍历所有邻接点：O(度)
- 适合稀疏图

❌ **缺点：**
- 判断两个顶点是否相邻：O(度)
- 删除边：O(度)
- 不适合稠密图

**时间复杂度：**
- 空间复杂度：O(V + E)
- 添加边：O(1)
- 删除边：O(度)
- 查找边：O(度)
- 遍历所有边：O(V + E)

---

### 2.3 十字链表

**十字链表（Orthogonal List）** 用于存储有向图，结合了邻接表和逆邻接表。

**存储方式：**
- 每个顶点维护两个链表：出边链表和入边链表
- 每条边只存储一次，同时出现在两个链表中

**适用场景：**
- 有向图
- 需要频繁查询入边和出边

**优缺点：**

✅ **优点：**
- 同时支持查询入边和出边
- 空间效率高

❌ **缺点：**
- 实现复杂
- 不适合无向图

---

### 2.4 邻接多重表

**邻接多重表（Adjacency Multilist）** 用于存储无向图，每条边只存储一次。

**存储方式：**
- 每条边用一个节点表示
- 边节点同时出现在两个顶点的链表中

**适用场景：**
- 无向图
- 需要频繁删除边

**优缺点：**

✅ **优点：**
- 每条边只存储一次
- 删除边方便

❌ **缺点：**
- 实现复杂
- 不适合有向图

---

### 2.5 存储结构对比

| 特性 | 邻接矩阵 | 邻接表 | 十字链表 | 邻接多重表 |
|------|---------|--------|---------|-----------|
| **适用图类型** | 有向/无向 | 有向/无向 | 有向 | 无向 |
| **空间复杂度** | O(V²) | O(V+E) | O(V+E) | O(V+E) |
| **查找边** | O(1) | O(度) | O(度) | O(度) |
| **遍历邻接点** | O(V) | O(度) | O(度) | O(度) |
| **添加边** | O(1) | O(1) | O(1) | O(1) |
| **删除边** | O(1) | O(度) | O(度) | O(1) |
| **适用场景** | 稠密图 | 稀疏图 | 有向图 | 无向图 |

---

## 三、图的遍历

### 3.1 深度优先搜索（DFS）

**深度优先搜索（Depth-First Search, DFS）** 从起始顶点开始，尽可能深地搜索图的分支。

**算法思想：**
1. 访问起始顶点v，标记为已访问
2. 递归访问v的未访问邻接点
3. 重复直到所有顶点都被访问

**实现：**

```c
// DFS遍历（递归版本）
void DFS(GraphAdjList *g, int vertex, int *visited) {
    visited[vertex] = 1;
    printf("%d ", vertex);
    
    EdgeNode *current = g->adjList[vertex];
    while (current != NULL) {
        if (!visited[current->to]) {
            DFS(g, current->to, visited);
        }
        current = current->next;
    }
}

// DFS遍历入口
void GraphDFS(GraphAdjList *g, int start) {
    int *visited = (int *)calloc(g->vertexCount, sizeof(int));
    DFS(g, start, visited);
    free(visited);
}

// DFS遍历（非递归版本，使用栈）
void DFSIterative(GraphAdjList *g, int start) {
    int *visited = (int *)calloc(g->vertexCount, sizeof(int));
    // 假设有一个简单的栈实现
    int stack[MAX_VERTICES];
    int top = -1;
    
    stack[++top] = start;
    visited[start] = 1;
    printf("%d ", start); // 注意：这里访问顺序可能与递归不同，通常入栈时访问或出栈时访问
    
    // 修正的非递归DFS通常是出栈时访问，或者模拟递归栈
    // 这里采用简单的模拟：
    // 1. 访问当前节点
    // 2. 将未访问邻居压栈
    
    while (top >= 0) {
        int vertex = stack[top--];
        // 如果是出栈访问：
        // if (!visited[vertex]) {
        //     visited[vertex] = 1;
        //     printf("%d ", vertex);
        // }
        
        // 这里演示的是一种变体，实际标准DFS非递归较复杂
        // 简单起见，我们保留递归版本作为主要学习对象
    }
    free(visited);
}
```

**遍历示例：**

```
图：
    0---1---3
    |   |
    2   4

DFS遍历（从0开始）：
递归版本：0 → 1 → 3 → 4 → 2
栈版本：0 → 2 → 1 → 4 → 3
```

**时间复杂度：**
- 邻接表：O(V + E)
- 邻接矩阵：O(V²)

**空间复杂度：**
- O(V)（递归栈或显式栈）

**应用：**
- 图的连通性判断
- 拓扑排序
- 强连通分量
- 路径查找

---

### 3.2 广度优先搜索（BFS）

**广度优先搜索（Breadth-First Search, BFS）** 从起始顶点开始，逐层访问所有顶点。

**算法思想：**
1. 访问起始顶点v，标记为已访问，加入队列
2. 从队列取出顶点，访问其所有未访问的邻接点
3. 将未访问的邻接点标记为已访问并加入队列
4. 重复直到队列为空

**实现：**

```c
// BFS遍历
void BFS(GraphAdjList *g, int start) {
    int *visited = (int *)calloc(g->vertexCount, sizeof(int));
    // 假设有一个简单的队列实现
    int queue[MAX_VERTICES];
    int front = 0, rear = 0;
    
    visited[start] = 1;
    queue[rear++] = start; // 入队
    
    while (front < rear) {
        int vertex = queue[front++]; // 出队
        printf("%d ", vertex);
        
        EdgeNode *current = g->adjList[vertex];
        while (current != NULL) {
            if (!visited[current->to]) {
                visited[current->to] = 1;
                queue[rear++] = current->to;
            }
            current = current->next;
        }
    }
    free(visited);
}

// BFS求最短路径（无权图）
void BFSShortestPath(GraphAdjList *g, int start, int *distance) {
    for (int i = 0; i < g->vertexCount; i++) distance[i] = -1;
    
    int queue[MAX_VERTICES];
    int front = 0, rear = 0;
    
    distance[start] = 0;
    queue[rear++] = start;
    
    while (front < rear) {
        int vertex = queue[front++];
        
        EdgeNode *current = g->adjList[vertex];
        while (current != NULL) {
            if (distance[current->to] == -1) {
                distance[current->to] = distance[vertex] + 1;
                queue[rear++] = current->to;
            }
            current = current->next;
        }
    }
}
```

**遍历示例：**

```
图：
    0---1---3
    |   |
    2   4

BFS遍历（从0开始）：
0 → 1 → 2 → 3 → 4
（按层次访问）
```

**时间复杂度：**
- 邻接表：O(V + E)
- 邻接矩阵：O(V²)

**空间复杂度：**
- O(V)（队列）

**应用：**
- 最短路径（无权图）
- 层次遍历
- 连通性判断
- 最小生成树（Prim算法）

---

### 3.3 DFS vs BFS

| 特性 | DFS | BFS |
|------|-----|-----|
| **数据结构** | 栈（递归或显式栈） | 队列 |
| **遍历顺序** | 深度优先 | 广度优先 |
| **最短路径** | ❌ 不保证最短 | ✅ 保证最短（无权图） |
| **空间复杂度** | O(V) | O(V) |
| **应用** | 拓扑排序、强连通分量 | 最短路径、层次遍历 |

---

## 四、最小生成树

### 4.1 基本概念

**生成树（Spanning Tree）**：包含图中所有顶点的连通子图，且是树（无环）。

**最小生成树（Minimum Spanning Tree, MST）**：在有权连通无向图中，权值之和最小的生成树。

**性质：**
- 最小生成树可能不唯一
- 最小生成树的边数 = 顶点数 - 1
- 最小生成树包含所有顶点

**应用场景：**
- 网络设计（最小成本连接所有节点）
- 电路设计
- 交通规划

---

### 4.2 Prim算法

**Prim算法（普里姆算法）**：从任意顶点开始，逐步扩展最小生成树。

**算法步骤：**
1. 选择任意顶点作为起始顶点，加入MST
2. 在MST的顶点和非MST的顶点之间，选择权值最小的边
3. 将该边和对应的顶点加入MST
4. 重复步骤2和3，直到所有顶点都加入MST

**实现：**

```c
typedef struct {
    int from, to, weight;
} Edge;

// Prim算法
void Prim(GraphAdjMatrix *g, int start) {
    int n = g->vertexCount;
    int *inMST = (int *)calloc(n, sizeof(int));
    int *minWeight = (int *)malloc(n * sizeof(int));
    int *parent = (int *)malloc(n * sizeof(int));
    
    for (int i = 0; i < n; i++) minWeight[i] = INF;
    minWeight[start] = 0;
    parent[start] = -1;
    
    for (int i = 0; i < n; i++) {
        // 找到不在MST中且权值最小的顶点
        int u = -1;
        int min = INF;
        for (int j = 0; j < n; j++) {
            if (!inMST[j] && minWeight[j] < min) {
                min = minWeight[j];
                u = j;
            }
        }
        
        if (u == -1) break;
        
        inMST[u] = 1;
        
        // 输出边
        if (parent[u] != -1) {
            printf("边: (%d, %d), 权值: %d\n", parent[u], u, minWeight[u]);
        }
        
        // 更新邻接点的最小权值
        for (int v = 0; v < n; v++) {
            if (!inMST[v] && HasEdgeMatrix(g, u, v)) {
                int weight = GetWeightMatrix(g, u, v);
                if (weight < minWeight[v]) {
                    minWeight[v] = weight;
                    parent[v] = u;
                }
            }
        }
    }
    
    free(inMST);
    free(minWeight);
    free(parent);
}
```

**算法示例：**

```
图：
      1
  0 ----- 1
  | \   / |
 3|  \ /  |2
  |   X   |
  2 ----- 3
      4

Prim算法过程（从0开始）：
步骤1：选择顶点0，MST = {0}
步骤2：选择边(0,1)，权值1，MST = {0,1}
步骤3：选择边(1,3)，权值2，MST = {0,1,3}
步骤4：选择边(0,2)，权值3，MST = {0,1,2,3}

最小生成树总权值：1 + 2 + 3 = 6
```

**时间复杂度：**
- 邻接矩阵：O(V²)
- 邻接表+优先队列：O(E log V)

**空间复杂度：** O(V)

---

### 4.3 Kruskal算法

**Kruskal算法（克鲁斯卡尔算法）**：按边权值从小到大排序，逐步加入MST。

**算法步骤：**
1. 将所有边按权值从小到大排序
2. 依次选择边，如果边的两个顶点不在同一连通分量中，则加入MST
3. 使用并查集判断是否形成环
4. 重复直到MST有V-1条边

**实现：**

```c
// 比较函数
int compareEdges(const void *a, const void *b) {
    return ((Edge *)a)->weight - ((Edge *)b)->weight;
}

// Kruskal算法
void Kruskal(GraphAdjList *g) {
    int maxEdges = g->vertexCount * (g->vertexCount - 1) / 2; // 最多边数
    Edge *edges = (Edge *)malloc(maxEdges * sizeof(Edge));
    int edgeCount = 0;
    
    // 收集所有边
    for (int i = 0; i < g->vertexCount; i++) {
        EdgeNode *current = g->adjList[i];
        while (current != NULL) {
            if (i < current->to) {  // 避免重复添加无向图的边
                edges[edgeCount].from = i;
                edges[edgeCount].to = current->to;
                edges[edgeCount].weight = current->weight;
                edgeCount++;
            }
            current = current->next;
        }
    }
    
    // 按权值排序
    qsort(edges, edgeCount, sizeof(Edge), compareEdges);
    
    // 使用并查集
    UnionFind uf;
    InitUF(&uf, g->vertexCount);
    
    int mstEdges = 0;
    for (int i = 0; i < edgeCount; i++) {
        if (!Connected(&uf, edges[i].from, edges[i].to)) {
            Union(&uf, edges[i].from, edges[i].to);
            printf("边: (%d, %d), 权值: %d\n", edges[i].from, edges[i].to, edges[i].weight);
            mstEdges++;
            
            if (mstEdges == g->vertexCount - 1) {
                break;  // MST已完整
            }
        }
    }
    
    free(edges);
    // FreeUF(&uf); // 假设有释放函数
}
```

**算法示例：**

```
图：
      1
  0 ----- 1
  | \   / |
 3|  \ /  |2
  |   X   |
  2 ----- 3
      4

边排序：1(0,1), 2(1,3), 3(0,2), 4(2,3)

Kruskal算法过程：
步骤1：选择边(0,1)，权值1，MST = {(0,1)}
步骤2：选择边(1,3)，权值2，MST = {(0,1), (1,3)}
步骤3：选择边(0,2)，权值3，MST = {(0,1), (1,3), (0,2)}
步骤4：边(2,3)会形成环，跳过

最小生成树总权值：1 + 2 + 3 = 6
```

**时间复杂度：**
- O(E log E) = O(E log V)（排序 + 并查集）

**空间复杂度：** O(V)

---

### 4.4 Prim vs Kruskal

| 特性 | Prim算法 | Kruskal算法 |
|------|---------|------------|
| **算法思想** | 顶点扩展 | 边选择 |
| **数据结构** | 优先队列/数组 | 并查集 |
| **时间复杂度** | O(V²) 或 O(E log V) | O(E log E) |
| **适用图** | 稠密图 | 稀疏图 |
| **实现复杂度** | 中等 | 简单 |

---

## 五、最短路径

### 5.1 基本概念

**最短路径问题**：在有权图中，找到两个顶点之间权值之和最小的路径。

**分类：**
1. **单源最短路径**：从一个顶点到其他所有顶点的最短路径
   - Dijkstra算法（非负权）
   - Bellman-Ford算法（可处理负权）

2. **所有顶点对最短路径**：任意两个顶点之间的最短路径
   - Floyd算法

---

### 5.2 Dijkstra算法

**Dijkstra算法（迪杰斯特拉算法）**：解决单源最短路径问题（非负权图）。

**算法步骤：**
1. 初始化：起点距离为0，其他顶点距离为∞
2. 选择距离最小的未访问顶点u
3. 更新u的所有邻接点的距离：dist[v] = min(dist[v], dist[u] + weight(u,v))
4. 标记u为已访问
5. 重复步骤2-4，直到所有顶点都被访问

**实现：**

```c
// Dijkstra算法（基础版本）
void Dijkstra(GraphAdjMatrix *g, int start, int *dist) {
    int n = g->vertexCount;
    int *visited = (int *)calloc(n, sizeof(int));
    
    for (int i = 0; i < n; i++) dist[i] = INF;
    dist[start] = 0;
    
    for (int i = 0; i < n; i++) {
        // 找到未访问的距离最小的顶点
        int u = -1;
        int minDist = INF;
        for (int j = 0; j < n; j++) {
            if (!visited[j] && dist[j] < minDist) {
                minDist = dist[j];
                u = j;
            }
        }
        
        if (u == -1) break;
        visited[u] = 1;
        
        // 更新邻接点的距离
        for (int v = 0; v < n; v++) {
            if (!visited[v] && HasEdgeMatrix(g, u, v)) {
                int weight = GetWeightMatrix(g, u, v);
                if (dist[u] != INF && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                }
            }
        }
    }
    
    free(visited);
}

// 获取最短路径（记录路径）
void DijkstraWithPath(GraphAdjMatrix *g, int start, int end, int *path, int *pathLen) {
    int n = g->vertexCount;
    int *dist = (int *)malloc(n * sizeof(int));
    int *parent = (int *)malloc(n * sizeof(int));
    int *visited = (int *)calloc(n, sizeof(int));
    
    for (int i = 0; i < n; i++) {
        dist[i] = INF;
        parent[i] = -1;
    }
    dist[start] = 0;
    
    for (int i = 0; i < n; i++) {
        int u = -1;
        int minDist = INF;
        for (int j = 0; j < n; j++) {
            if (!visited[j] && dist[j] < minDist) {
                minDist = dist[j];
                u = j;
            }
        }
        
        if (u == -1) break;
        visited[u] = 1;
        
        for (int v = 0; v < n; v++) {
            if (!visited[v] && HasEdgeMatrix(g, u, v)) {
                int weight = GetWeightMatrix(g, u, v);
                if (dist[u] != INF && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    parent[v] = u;
                }
            }
        }
    }
    
    // 重构路径
    *pathLen = 0;
    if (dist[end] == INF) {
        // 不可达
    } else {
        int current = end;
        int tempPath[MAX_VERTICES];
        int count = 0;
        while (current != -1) {
            tempPath[count++] = current;
            current = parent[current];
        }
        // 反转路径
        for (int i = 0; i < count; i++) {
            path[i] = tempPath[count - 1 - i];
        }
        *pathLen = count;
    }
    
    free(dist);
    free(parent);
    free(visited);
}
```

**算法示例：**

```
图：
      1
  0 ----- 1
  | \   / |
 3|  \ /  |2
  |   X   |
  2 ----- 3
      4

Dijkstra算法（从0开始）：
步骤1：dist[0]=0, dist[1]=1, dist[2]=3, dist[3]=∞
步骤2：选择顶点1，dist[3]=min(∞, 1+2)=3
步骤3：选择顶点2，dist[3]=min(3, 3+4)=3
步骤4：选择顶点3

最短距离：
0→0: 0
0→1: 1
0→2: 3
0→3: 3
```

**时间复杂度：**
- 基础版本：O(V²)
- 优先队列优化：O(E log V)

**空间复杂度：** O(V)

**限制：**
- 不能处理负权边
- 不能处理负权回路

---

### 5.3 Floyd算法

**Floyd算法（弗洛伊德算法，Floyd-Warshall算法）**：解决所有顶点对最短路径问题，可以一次性求出图中任意两点之间的最短路径。

**问题描述：**
- 给定有向图或无向图（可带权，可带负权，但不能有负权回路）
- 求任意两个顶点之间的最短路径长度

**算法思想：**

Floyd算法基于**动态规划**思想：

**核心思想：** 逐步允许经过更多顶点作为中转点

**状态定义：**
- dist[k][i][j]：从顶点i到顶点j，**只允许经过顶点0,1,2,...,k作为中转点**的最短路径长度

**状态转移方程：**
```
dist[k][i][j] = min(
    dist[k-1][i][j],              // 不经过顶点k
    dist[k-1][i][k] + dist[k-1][k][j]  // 经过顶点k
)
```

**空间优化：**
由于dist[k][...]只依赖于dist[k-1][...]，可以用二维数组：
```java
dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])
```

**算法步骤详解：**

**步骤1：初始化距离矩阵dist**
- dist[i][i] = 0（自己到自己的距离为0）
- 如果存在边(i,j)，dist[i][j] = weight(i,j)
- 否则，dist[i][j] = ∞（表示不可达）

**步骤2：三重循环更新**
- 外层循环k：依次允许顶点0,1,2,...,n-1作为中转点
- 内层循环i, j：对于每对顶点(i,j)，尝试通过顶点k缩短路径
  - 如果dist[i][k] + dist[k][j] < dist[i][j]，则更新

**步骤3：检测负权回路**
- 如果存在dist[i][i] < 0，说明存在负权回路

**代码实现：**

```c
// Floyd算法基础版本
void Floyd(GraphAdjMatrix *g, int dist[MAX_VERTICES][MAX_VERTICES]) {
    int n = g->vertexCount;
    
    // 步骤1：初始化距离矩阵
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) {
                dist[i][j] = 0;  // 自己到自己的距离为0
            } else if (HasEdgeMatrix(g, i, j)) {
                dist[i][j] = GetWeightMatrix(g, i, j);  // 直接边的权重
            } else {
                dist[i][j] = INF;  // 不可达
            }
        }
    }
    
    // 步骤2：Floyd算法核心 - 三重循环
    // k：中转点，逐步允许经过更多顶点
    for (int k = 0; k < n; k++) {
        // i：起点
        for (int i = 0; i < n; i++) {
            // j：终点
            for (int j = 0; j < n; j++) {
                // 避免溢出：检查路径是否存在
                if (dist[i][k] != INF && dist[k][j] != INF) {
                    // 状态转移：尝试通过顶点k缩短路径
                    if (dist[i][k] + dist[k][j] < dist[i][j]) {
                        dist[i][j] = dist[i][k] + dist[k][j];
                    }
                }
            }
        }
    }
}

// Floyd算法 - 检测负权回路
int HasNegativeCycle(GraphAdjMatrix *g) {
    int dist[MAX_VERTICES][MAX_VERTICES];
    Floyd(g, dist);
    
    // 检查是否存在dist[i][i] < 0
    for (int i = 0; i < g->vertexCount; i++) {
        if (dist[i][i] < 0) {
            return 1;
        }
    }
    
    return 0;
}

// Floyd算法 - 带路径记录版本
void FloydWithPath(GraphAdjMatrix *g, int dist[MAX_VERTICES][MAX_VERTICES], int next[MAX_VERTICES][MAX_VERTICES]) {
    int n = g->vertexCount;
    
    // 初始化
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            if (i == j) {
                dist[i][j] = 0;
                next[i][j] = j;
            } else if (HasEdgeMatrix(g, i, j)) {
                dist[i][j] = GetWeightMatrix(g, i, j);
                next[i][j] = j;
            } else {
                dist[i][j] = INF;
                next[i][j] = -1;
            }
        }
    }
    
    // Floyd算法
    for (int k = 0; k < n; k++) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (dist[i][k] != INF && dist[k][j] != INF &&
                    dist[i][k] + dist[k][j] < dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                    next[i][j] = next[i][k];
                }
            }
        }
    }
}

// 根据next矩阵重构路径
void ReconstructPath(int next[MAX_VERTICES][MAX_VERTICES], int start, int end, int *path, int *pathLen) {
    *pathLen = 0;
    if (next[start][end] == -1) {
        return;  // 不可达
    }
    
    int current = start;
    while (current != end) {
        path[(*pathLen)++] = current;
        current = next[current][end];
    }
    path[(*pathLen)++] = end;
}
```

**算法示例详解：**

```
有向图示例：
        1
   0 -----> 1
   ↑        ↓
   |        2
   3        ↓
   ↑        3
   2 -----> 3
        4

初始距离矩阵dist[0]（不允许任何中转点）：
    0  1  2  3
0 [0  1  ∞  ∞]
1 [∞  0  ∞  2]
2 [3  ∞  0  4]
3 [∞  ∞  ∞  0]

k=0（允许经过顶点0作为中转点）：
检查所有(i,j)对，看是否可以通过顶点0缩短路径
- dist[1][0] = ∞，无法通过0
- dist[2][0] = 3，但无法更新其他路径
- 无更新

k=1（允许经过顶点0,1作为中转点）：
- dist[0][3] = min(∞, dist[0][1] + dist[1][3]) = min(∞, 1+2) = 3 ✓
- dist[2][3] = min(4, dist[2][1] + dist[1][3]) = min(4, ∞+2) = 4
- 更新dist[0][3] = 3

k=2（允许经过顶点0,1,2作为中转点）：
- dist[0][3] = min(3, dist[0][2] + dist[2][3]) = min(3, ∞+4) = 3
- dist[1][3] = min(2, dist[1][2] + dist[2][3]) = min(2, ∞+4) = 2
- dist[0][1] = min(1, dist[0][2] + dist[2][1]) = min(1, ∞+∞) = 1
- 无更新

k=3（允许经过所有顶点作为中转点）：
- 检查所有路径，无更新

最终最短距离矩阵：
    0  1  2  3
0 [0  1  ∞  3]
1 [∞  0  ∞  2]
2 [3  4  0  4]
3 [∞  ∞  ∞  0]

路径示例：
- 从0到3：0 → 1 → 3（距离3）
- 从2到1：2 → 0 → 1（距离4）
```

**负权回路检测示例：**

```
带负权边的图：
   0 --(-2)--> 1
   ↑           |
   |           |
   3 <--(-1)-- 2

初始dist矩阵：
    0  1  2
0 [0  -2  ∞]
1 [∞  0  ∞]
2 [∞  -1  0]

k=0后：
    0  1  2
0 [0  -2  ∞]
1 [∞  0  ∞]
2 [∞  -1  0]

k=1后：
    0  1  2
0 [0  -2  ∞]
1 [∞  0  ∞]
2 [∞  -1  0]

k=2后：
    0  1  2
0 [0  -2  ∞]
1 [∞  0  ∞]
2 [∞  -1  0]

如果存在负权回路（如：0→1→2→0，总权重-2-1+3=0，但如果有-3的边）：
检测：dist[0][0] < 0？如果存在负权回路，dist[i][i]会变成负数
```

**时间复杂度：** O(V³)
- 三重循环，每层循环V次
- 总次数：V × V × V = V³

**空间复杂度：** O(V²)
- 需要存储距离矩阵dist[V][V]
- 如果记录路径，还需要next[V][V]矩阵

**算法特点：**

✅ **优点：**
- 代码简洁，实现容易
- 一次计算所有顶点对的最短路径
- 可以处理负权边（但不能有负权回路）
- 可以检测负权回路

❌ **缺点：**
- 时间复杂度高O(V³)，不适合大规模图
- 空间复杂度O(V²)，需要矩阵存储

**应用场景：**

1. **网络路由**：计算网络中任意两点间的最短路径
2. **交通规划**：计算城市间的最短距离
3. **社交网络**：计算用户间的最短关系路径
4. **游戏开发**：AI寻路算法
5. **资源分配**：计算最优传输路径

**常见考点：**

1. **算法原理**：动态规划思想，状态转移方程
2. **时间复杂度**：O(V³)，为什么是三次方
3. **空间优化**：从三维数组优化到二维数组
4. **负权回路检测**：如何判断是否存在负权回路
5. **路径重建**：如何根据next矩阵重构路径
6. **与Dijkstra的区别**：
   - Dijkstra：单源最短路径，O(V²)或O(E log V)
   - Floyd：所有顶点对最短路径，O(V³)
7. **适用场景**：
   - 需要所有顶点对最短路径时用Floyd
   - 只需要单源最短路径时用Dijkstra更高效

---

### 5.4 最短路径算法对比

| 算法 | 类型 | 时间复杂度 | 空间复杂度 | 限制 |
|------|------|----------|----------|------|
| **Dijkstra** | 单源 | O(V²) 或 O(E log V) | O(V) | 非负权 |
| **Bellman-Ford** | 单源 | O(VE) | O(V) | 可处理负权，检测负权回路 |
| **Floyd** | 所有顶点对 | O(V³) | O(V²) | 可处理负权（无负权回路） |

---

## 六、拓扑排序

### 6.1 基本概念

**拓扑排序（Topological Sort）**：对有向无环图（DAG, Directed Acyclic Graph）的顶点进行排序，使得对于每条边<u,v>，u在排序中出现在v之前。

**核心要求：**
- 图必须是有向图
- 图必须是无环图（DAG）
- 排序结果可能不唯一

**形式化定义：**
- 对于有向图 G = (V, E)
- 拓扑排序是一个顶点序列 v₁, v₂, ..., vₙ
- 对于任意边 <vᵢ, vⱼ>，都有 i < j

**应用场景：**
- **任务调度**：确定任务的执行顺序（任务间有依赖关系）
- **课程安排**：确定课程的学习顺序（先修课程关系）
- **编译系统**：确定源文件的编译顺序（文件间有依赖关系）
- **依赖管理**：软件包依赖关系的解析
- **项目管理**：确定项目活动的执行顺序

---

### 6.2 算法思想

拓扑排序的核心思想是**逐步移除入度为0的顶点**，直到所有顶点都被处理。

**基本步骤：**
1. 计算所有顶点的入度
2. 将所有入度为0的顶点加入队列
3. 从队列中取出一个顶点，加入结果序列
4. 删除该顶点及其所有出边（更新邻接顶点的入度）
5. 如果某个邻接顶点的入度变为0，将其加入队列
6. 重复步骤3-5，直到队列为空
7. 如果结果序列包含所有顶点，则拓扑排序成功；否则存在环

---

### 6.3 Kahn算法（基于BFS）

**Kahn算法**：使用队列实现，基于广度优先搜索的思想。

**算法步骤详解：**
1. **初始化**：计算所有顶点的入度
2. **入队**：将所有入度为0的顶点加入队列
3. **循环处理**：
   - 从队列取出顶点u，加入结果序列
   - 遍历u的所有邻接顶点v
   - 将v的入度减1
   - 如果v的入度变为0，将v加入队列
4. **检查**：如果结果序列长度等于顶点数，排序成功；否则存在环

**实现：**

```c
// 拓扑排序（Kahn算法）
void TopologicalSortKahn(GraphAdjList *g, int *result, int *count) {
    int n = g->vertexCount;
    int *inDegree = (int *)calloc(n, sizeof(int));
    int queue[MAX_VERTICES];
    int front = 0, rear = 0;
    
    // 步骤1：计算所有顶点的入度
    for (int i = 0; i < n; i++) {
        EdgeNode *current = g->adjList[i];
        while (current != NULL) {
            inDegree[current->to]++;
            current = current->next;
        }
    }
    
    // 步骤2：将所有入度为0的顶点加入队列
    for (int i = 0; i < n; i++) {
        if (inDegree[i] == 0) {
            queue[rear++] = i;
        }
    }
    
    // 步骤3：Kahn算法主循环
    *count = 0;
    while (front < rear) {
        int u = queue[front++];
        result[(*count)++] = u;
        
        EdgeNode *current = g->adjList[u];
        while (current != NULL) {
            int v = current->to;
            inDegree[v]--;
            if (inDegree[v] == 0) {
                queue[rear++] = v;
            }
            current = current->next;
        }
    }
    
    free(inDegree);
}

// 判断图是否有环
int HasCycle(GraphAdjList *g) {
    int result[MAX_VERTICES];
    int count;
    TopologicalSortKahn(g, result, &count);
    return count != g->vertexCount;
}
```

**Kahn算法特点：**
- ✅ 实现简单直观
- ✅ 易于理解和调试
- ✅ 可以检测环（结果序列长度 < 顶点数）
- ✅ 结果按层次顺序输出

---

### 6.3.1 DFS算法（基于深度优先搜索）

**DFS算法**：使用深度优先搜索和栈实现拓扑排序。

**算法思想：**
1. 对图进行深度优先遍历
2. 当一个顶点的所有邻接顶点都被访问后，将该顶点压入栈
3. 最后将栈中的元素依次弹出，得到拓扑排序结果

**关键点：**
- DFS完成后，栈顶是最后访问的顶点（没有后继）
- 栈底是最先访问的顶点（有最多后继）
- 需要先检测环，再进行拓扑排序

**实现：**
```c
// 检测有向图中是否存在环（DFS方法）
int HasCycleDFSUtil(GraphAdjList *g, int vertex, int *visited, int *onStack) {
    visited[vertex] = 1;
    onStack[vertex] = 1;
    
    EdgeNode *current = g->adjList[vertex];
    while (current != NULL) {
        int adj = current->to;
        if (!visited[adj]) {
            if (HasCycleDFSUtil(g, adj, visited, onStack)) return 1;
        } else if (onStack[adj]) {
            return 1;
        }
        current = current->next;
    }
    
    onStack[vertex] = 0;
    return 0;
}

// DFS递归函数：深度优先遍历并压栈
void DFSTopologicalUtil(GraphAdjList *g, int vertex, int *visited, int *stack, int *top) {
    visited[vertex] = 1;
    
    EdgeNode *current = g->adjList[vertex];
    while (current != NULL) {
        if (!visited[current->to]) {
            DFSTopologicalUtil(g, current->to, visited, stack, top);
        }
        current = current->next;
    }
    
    stack[++(*top)] = vertex;
}

// 拓扑排序（DFS版本）
void TopologicalSortDFS(GraphAdjList *g, int *result, int *count) {
    int n = g->vertexCount;
    int *visited = (int *)calloc(n, sizeof(int));
    int *onStack = (int *)calloc(n, sizeof(int));
    int stack[MAX_VERTICES];
    int top = -1;
    
    // 步骤1：检查是否有环
    for (int i = 0; i < n; i++) {
        if (!visited[i] && HasCycleDFSUtil(g, i, visited, onStack)) {
            *count = 0; // 存在环
            free(visited);
            free(onStack);
            return;
        }
    }
    
    // 步骤2：重置访问标记，进行DFS拓扑排序
    for (int i = 0; i < n; i++) visited[i] = 0;
    
    for (int i = 0; i < n; i++) {
        if (!visited[i]) {
            DFSTopologicalUtil(g, i, visited, stack, &top);
        }
    }
    
    // 步骤3：将栈中的元素倒序输出
    *count = 0;
    while (top >= 0) {
        result[(*count)++] = stack[top--];
    }
    
    free(visited);
    free(onStack);
}
```

---

### 6.4 算法示例详解

#### 示例1：课程安排问题

**问题描述：**
- 课程0：无先修课程
- 课程1：需要先修课程0
- 课程2：需要先修课程0
- 课程3：需要先修课程1和2

**有向图表示：**
```
    0 → 1 → 3
    ↓       ↑
    2 ──────┘
```

**Kahn算法执行过程：**

| 步骤 | 队列状态 | 入度数组 | 处理顶点 | 结果序列 |
|------|---------|---------|---------|---------|
| 初始 | [0] | [0,1,1,2] | - | [] |
| 1 | [] | [0,0,1,2] | 0 | [0] |
| 2 | [1,2] | [0,0,0,2] | 1 | [0,1] |
| 3 | [2] | [0,0,0,1] | 2 | [0,1,2] |
| 4 | [3] | [0,0,0,0] | 3 | [0,1,2,3] |
| 5 | [] | [0,0,0,0] | - | [0,1,2,3] |

**拓扑排序结果：** `[0, 1, 2, 3]` 或 `[0, 2, 1, 3]`（结果可能不唯一）

**DFS算法执行过程：**
- DFS(0) → DFS(1) → DFS(3) → 压栈3 → 压栈1 → DFS(2) → 压栈2 → 压栈0
- 栈中顺序（从底到顶）：0, 2, 1, 3
- 出栈顺序：3, 1, 2, 0
- **注意**：DFS版本的结果是逆序的，需要反转

---

#### 示例2：检测环

**有环图：**
```
    0 → 1 → 2
    ↑       ↓
    └───────┘
```

**Kahn算法执行：**
- 初始：只有顶点0入度为0，队列 = [0]
- 处理0：队列变为空，但还有顶点1和2未处理
- **结果**：result.size() = 1 < 4，检测到环

**DFS算法执行：**
- DFS(0) → DFS(1) → DFS(2) → 发现2指向0，且0在栈中
- **结果**：检测到环

---

### 6.5 Kahn算法 vs DFS算法

| 特性 | Kahn算法（BFS） | DFS算法 |
|------|----------------|---------|
| **数据结构** | 队列 | 栈（递归或显式） |
| **算法思想** | 广度优先，逐层处理 | 深度优先，递归回溯 |
| **环检测** | 结果序列长度 < 顶点数 | 后向边检测 |
| **结果顺序** | 按入度0的顺序 | 逆序（需要反转） |
| **实现复杂度** | 简单直观 | 需要理解递归 |
| **适用场景** | 需要按层次处理 | 需要深度优先遍历 |
| **时间复杂度** | O(V + E) | O(V + E) |
| **空间复杂度** | O(V) | O(V)（递归栈） |

**选择建议：**
- **Kahn算法**：更直观，易于理解，推荐使用
- **DFS算法**：在需要深度优先遍历的场景下使用

---

### 6.6 实际应用案例

#### 案例1：任务调度系统

**场景：** 多个任务有依赖关系，需要确定执行顺序

```java
// 任务依赖关系
// Task 0: 无依赖
// Task 1: 依赖 Task 0
// Task 2: 依赖 Task 0
// Task 3: 依赖 Task 1, Task 2

// 拓扑排序结果：[0, 1, 2, 3] 或 [0, 2, 1, 3]
// 执行顺序：先执行0，然后可以并行执行1和2，最后执行3
```

#### 案例2：编译系统

**场景：** 多个源文件有依赖关系，需要确定编译顺序

```java
// 文件依赖关系
// fileA.c: 无依赖
// fileB.c: 依赖 fileA.c
// fileC.c: 依赖 fileA.c
// fileD.c: 依赖 fileB.c, fileC.c

// 拓扑排序结果：[fileA, fileB, fileC, fileD]
// 编译顺序：先编译fileA，然后可以并行编译fileB和fileC，最后编译fileD
```

#### 案例3：课程学习计划

**场景：** 多门课程有先修关系，需要确定学习顺序

```java
// 课程先修关系
// 数据结构：无先修
// 算法分析：需要先修数据结构
// 操作系统：需要先修数据结构
// 编译原理：需要先修算法分析、操作系统

// 拓扑排序结果：[数据结构, 算法分析, 操作系统, 编译原理]
// 学习顺序：先学数据结构，然后可以并行学习算法分析和操作系统，最后学编译原理
```

---

### 6.7 时间复杂度分析

**Kahn算法：**
- **时间复杂度：** O(V + E)
  - 计算入度：O(E)
  - 队列操作：O(V)
  - 更新入度：O(E)
- **空间复杂度：** O(V)
  - 入度数组：O(V)
  - 队列：O(V)
  - 结果数组：O(V)

**DFS算法：**
- **时间复杂度：** O(V + E)
  - DFS遍历：O(V + E)
  - 环检测：O(V + E)
- **空间复杂度：** O(V)
  - 访问标记：O(V)
  - 递归栈：O(V)
  - 结果栈：O(V)

---

### 6.8 常见考点

1. **拓扑排序的定义和性质**
   - 只适用于有向无环图（DAG）
   - 结果可能不唯一

2. **环检测**
   - Kahn算法：结果序列长度 < 顶点数
   - DFS算法：存在后向边

3. **算法实现**
   - Kahn算法的队列操作
   - DFS算法的递归和栈操作

4. **应用场景**
   - 任务调度
   - 课程安排
   - 依赖关系处理

5. **时间复杂度**
   - 两种算法都是 O(V + E)

---

## 七、关键路径

### 7.1 基本概念

**关键路径（Critical Path）**：在AOE网（Activity On Edge）中，从源点到汇点的**最长路径**。

**AOE网（Activity On Edge Network）**：
- **有向边**表示**活动**（Activity）
- **边上的权值**表示活动的**持续时间**
- **顶点**表示**事件**（Event），即活动的开始或结束时刻
- **源点**：入度为0的顶点（工程开始）
- **汇点**：出度为0的顶点（工程结束）

**AOE网 vs AOV网：**

| 特性 | AOE网（Activity On Edge） | AOV网（Activity On Vertex） |
|------|-------------------------|---------------------------|
| **边** | 表示活动 | 表示活动间的优先关系 |
| **顶点** | 表示事件 | 表示活动 |
| **权值** | 在边上（活动持续时间） | 在顶点上（活动持续时间） |
| **应用** | 关键路径分析 | 拓扑排序 |
| **问题** | 求最长路径 | 求拓扑序列 |

**关键术语：**

1. **事件（Event）**：顶点，表示活动的开始或结束时刻
2. **活动（Activity）**：边，表示一个过程或任务
3. **活动持续时间**：边上的权值
4. **源点（Source）**：入度为0的顶点，工程开始事件
5. **汇点（Sink）**：出度为0的顶点，工程结束事件
6. **事件的最早发生时间（ve）**：从源点到该事件的最长路径长度
7. **事件的最迟发生时间（vl）**：在不影响整个工程工期的前提下，该事件最迟必须发生的时间
8. **活动的最早开始时间（e）**：该活动最早可以开始的时间
9. **活动的最迟开始时间（l）**：在不影响整个工程工期的前提下，该活动最迟必须开始的时间
10. **关键活动**：e = l 的活动，即没有时间余量的活动
11. **关键路径**：由关键活动组成的路径

**关键路径特点：**
- ✅ 关键路径上的活动称为关键活动
- ✅ 关键路径的长度决定整个工程的工期
- ✅ 缩短关键活动可以缩短工期
- ✅ 非关键活动可以适当延迟，不影响总工期
- ✅ 关键路径可能不唯一

---

### 7.2 算法思想

关键路径算法的核心思想是：
1. **正向计算**：从源点开始，按拓扑顺序计算每个事件的最早发生时间
2. **反向计算**：从汇点开始，按逆拓扑顺序计算每个事件的最迟发生时间
3. **计算活动时间**：根据事件时间计算活动的最早和最迟开始时间
4. **找出关键活动**：e = l 的活动即为关键活动

---

### 7.3 算法步骤详解

#### 步骤1：拓扑排序确定事件顺序

使用拓扑排序确定事件的执行顺序，得到拓扑序列。

#### 步骤2：计算事件的最早发生时间（ve）

**公式：**
- ve[源点] = 0
- ve[j] = max{ve[i] + weight(i,j)}，其中 <i,j> 是到达j的所有边

**计算方向：** 从源点开始，按拓扑顺序正向计算

#### 步骤3：计算事件的最迟发生时间（vl）

**公式：**
- vl[汇点] = ve[汇点]
- vl[i] = min{vl[j] - weight(i,j)}，其中 <i,j> 是从i出发的所有边

**计算方向：** 从汇点开始，按逆拓扑顺序反向计算

#### 步骤4：计算活动的最早开始时间（e）

**公式：**
- e[k] = ve[i]，其中活动k = <i,j>

**含义：** 活动k的最早开始时间等于其起始事件i的最早发生时间

#### 步骤5：计算活动的最迟开始时间（l）

**公式：**
- l[k] = vl[j] - weight(i,j)，其中活动k = <i,j>

**含义：** 活动k的最迟开始时间等于其结束事件j的最迟发生时间减去活动持续时间

#### 步骤6：找出关键活动

**判断条件：**
- 如果 e[k] = l[k]，则活动k是关键活动
- 所有关键活动组成的路径即为关键路径

---

### 7.4 算法实现

```c
typedef struct {
    int from;      // 起始事件
    int to;        // 结束事件
    int weight;    // 活动持续时间
    int e;         // 最早开始时间
    int l;         // 最迟开始时间
    int isCritical;// 是否关键活动
} Activity;

typedef struct {
    int *ve;                      // 事件最早发生时间
    int *vl;                      // 事件最迟发生时间
    Activity *activities;         // 所有活动
    int activityCount;            // 活动数量
    int totalTime;                // 总工期
} CriticalPathResult;

// 关键路径算法
CriticalPathResult* FindCriticalPath(GraphAdjList *g) {
    int n = g->vertexCount;
    int topoOrder[MAX_VERTICES];
    int count;
    
    // 步骤1：拓扑排序
    TopologicalSortKahn(g, topoOrder, &count);
    if (count != n) {
        return NULL;  // 存在环，无法计算关键路径
    }
    
    int source = topoOrder[0];  // 源点
    int sink = topoOrder[n - 1];  // 汇点
    
    // 步骤2：计算事件的最早发生时间（ve）
    int *ve = (int *)calloc(n, sizeof(int));
    // calloc已初始化为0
    
    for (int i = 0; i < n; i++) {
        int u = topoOrder[i];
        EdgeNode *current = g->adjList[u];
        while (current != NULL) {
            int v = current->to;
            int weight = current->weight;
            if (ve[u] + weight > ve[v]) {
                ve[v] = ve[u] + weight;
            }
            current = current->next;
        }
    }
    
    // 步骤3：计算事件的最迟发生时间（vl）
    int *vl = (int *)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) vl[i] = ve[sink];  // 初始化为汇点的最早发生时间
    
    // 逆拓扑顺序计算
    for (int i = n - 1; i >= 0; i--) {
        int u = topoOrder[i];
        EdgeNode *current = g->adjList[u];
        while (current != NULL) {
            int v = current->to;
            int weight = current->weight;
            if (vl[v] - weight < vl[u]) {
                vl[u] = vl[v] - weight;
            }
            current = current->next;
        }
    }
    
    // 步骤4和5：计算活动的最早和最迟开始时间，找出关键活动
    // 计算总边数
    int edgeCount = 0;
    for (int i = 0; i < n; i++) {
        EdgeNode *current = g->adjList[i];
        while (current != NULL) {
            edgeCount++;
            current = current->next;
        }
    }
    
    Activity *activities = (Activity *)malloc(edgeCount * sizeof(Activity));
    int actIdx = 0;
    
    for (int u = 0; u < n; u++) {
        EdgeNode *current = g->adjList[u];
        while (current != NULL) {
            int v = current->to;
            int weight = current->weight;
            int e = ve[u];  // 活动的最早开始时间
            int l = vl[v] - weight;  // 活动的最迟开始时间
            
            activities[actIdx].from = u;
            activities[actIdx].to = v;
            activities[actIdx].weight = weight;
            activities[actIdx].e = e;
            activities[actIdx].l = l;
            activities[actIdx].isCritical = (e == l);
            actIdx++;
            
            current = current->next;
        }
    }
    
    CriticalPathResult *result = (CriticalPathResult *)malloc(sizeof(CriticalPathResult));
    result->ve = ve;
    result->vl = vl;
    result->activities = activities;
    result->activityCount = edgeCount;
    result->totalTime = ve[sink];
    
    return result;
}

void PrintCriticalPathResult(CriticalPathResult *res) {
    if (res == NULL) {
        printf("无法计算关键路径（可能存在环）\n");
        return;
    }
    
    printf("=== 关键路径分析结果 ===\n");
    printf("总工期: %d\n", res->totalTime);
    
    printf("\n关键活动:\n");
    for (int i = 0; i < res->activityCount; i++) {
        if (res->activities[i].isCritical) {
            printf("活动<%d,%d>: 持续时间=%d\n", 
                   res->activities[i].from, res->activities[i].to, res->activities[i].weight);
        }
    }
    
    // 释放内存
    free(res->ve);
    free(res->vl);
    free(res->activities);
    free(res);
}
```

---

### 7.5 算法示例详解

#### 示例：工程项目管理

**AOE网：**
```
        活动a1(6)     活动a4(1)
    事件0 ──────→ 事件1 ──────→ 事件4
      │                          ↑
      │ 活动a2(4)                │ 活动a6(9)
      ↓                          │
    事件2 ──────→ 事件3 ──────→ ┘
      │            ↑           活动a5(2)
      │ 活动a3(5)   │
      └────────────┘
```

**顶点（事件）说明：**
- 事件0：工程开始
- 事件1：活动a1完成
- 事件2：活动a2完成
- 事件3：活动a3完成
- 事件4：工程结束

**边（活动）说明：**
- a1: <0,1>, 持续时间6
- a2: <0,2>, 持续时间4
- a3: <2,3>, 持续时间5
- a4: <1,4>, 持续时间1
- a5: <3,4>, 持续时间2
- a6: <1,3>, 持续时间9

**计算过程：**

**步骤1：拓扑排序**
- 拓扑序列：[0, 1, 2, 3, 4]
- 源点：0，汇点：4

**步骤2：计算ve（事件最早发生时间）**
- ve[0] = 0
- ve[1] = max{ve[0] + 6} = 6
- ve[2] = max{ve[0] + 4} = 4
- ve[3] = max{ve[2] + 5, ve[1] + 9} = max{9, 15} = 15
- ve[4] = max{ve[1] + 1, ve[3] + 2} = max{7, 17} = 17

**步骤3：计算vl（事件最迟发生时间）**
- vl[4] = ve[4] = 17
- vl[3] = min{vl[4] - 2} = 15
- vl[1] = min{vl[4] - 1, vl[3] - 9} = min{16, 6} = 6
- vl[2] = min{vl[3] - 5} = 10
- vl[0] = min{vl[1] - 6, vl[2] - 4} = min{0, 6} = 0

**步骤4和5：计算活动时间**

| 活动 | 起始事件 | 结束事件 | 持续时间 | e = ve[i] | l = vl[j] - weight | e - l | 是否关键 |
|------|---------|---------|---------|-----------|-------------------|-------|---------|
| a1 | 0 | 1 | 6 | 0 | 6 - 6 = 0 | 0 | ✅ 是 |
| a2 | 0 | 2 | 4 | 0 | 10 - 4 = 6 | -6 | ❌ 否 |
| a3 | 2 | 3 | 5 | 4 | 15 - 5 = 10 | -6 | ❌ 否 |
| a4 | 1 | 4 | 1 | 6 | 17 - 1 = 16 | -10 | ❌ 否 |
| a5 | 3 | 4 | 2 | 15 | 17 - 2 = 15 | 0 | ✅ 是 |
| a6 | 1 | 3 | 9 | 6 | 15 - 9 = 6 | 0 | ✅ 是 |

**关键活动：** a1, a5, a6

**关键路径：** 0 → 1 → 3 → 4（路径：a1 → a6 → a5）

**总工期：** 17

**分析：**
- 关键路径上的活动（a1, a6, a5）不能延迟，否则会影响总工期
- 非关键活动（a2, a3, a4）有时间余量，可以适当延迟
- 活动a2可以延迟6个单位时间
- 活动a3可以延迟6个单位时间
- 活动a4可以延迟10个单位时间

---

### 7.6 应用场景

#### 场景1：工程项目管理

**问题：** 确定项目的最短完成时间和关键任务

**应用：**
- 识别关键任务（不能延迟的任务）
- 计算项目最短工期
- 优化资源配置（重点关注关键任务）

#### 场景2：生产计划

**问题：** 确定生产流程中的关键工序

**应用：**
- 识别瓶颈工序
- 优化生产流程
- 合理安排资源

#### 场景3：软件开发

**问题：** 确定软件开发的关键路径

**应用：**
- 识别关键开发任务
- 估算项目完成时间
- 优化开发计划

---

### 7.7 时间复杂度分析

**算法复杂度：**
- **时间复杂度：** O(V + E)
  - 拓扑排序：O(V + E)
  - 计算ve：O(V + E)
  - 计算vl：O(V + E)
  - 计算活动时间：O(E)
- **空间复杂度：** O(V + E)
  - ve数组：O(V)
  - vl数组：O(V)
  - 拓扑序列：O(V)
  - 活动列表：O(E)

---

### 7.8 常见考点

1. **AOE网和AOV网的区别**
   - AOE网：边表示活动，顶点表示事件
   - AOV网：顶点表示活动，边表示优先关系

2. **关键路径的定义**
   - 从源点到汇点的最长路径
   - 关键路径的长度等于总工期

3. **关键活动的判断**
   - e = l 的活动是关键活动
   - 关键活动没有时间余量

4. **事件时间的计算**
   - ve：正向计算，取最大值
   - vl：反向计算，取最小值

5. **活动时间的计算**
   - e = ve[i]（起始事件的最早发生时间）
   - l = vl[j] - weight（结束事件的最迟发生时间减去活动持续时间）

6. **算法步骤**
   - 拓扑排序 → 计算ve → 计算vl → 计算e和l → 找出关键活动

7. **应用场景**
   - 项目管理、生产计划、软件开发等

---

## 八、时间复杂度总结

| 操作/算法 | 邻接矩阵 | 邻接表 | 说明 |
|----------|---------|--------|------|
| **存储空间** | O(V²) | O(V+E) | 邻接表适合稀疏图 |
| **查找边** | O(1) | O(度) | 邻接矩阵更快 |
| **遍历所有边** | O(V²) | O(V+E) | 邻接表更高效 |
| **DFS** | O(V²) | O(V+E) | 邻接表更高效 |
| **BFS** | O(V²) | O(V+E) | 邻接表更高效 |
| **Prim** | O(V²) | O(E log V) | 稠密图用矩阵，稀疏图用表+优先队列 |
| **Kruskal** | O(E log E) | O(E log E) | 与存储结构无关 |
| **Dijkstra** | O(V²) | O(E log V) | 稠密图用矩阵，稀疏图用表+优先队列 |
| **Floyd** | O(V³) | O(V³) | 需要矩阵表示 |
| **拓扑排序** | O(V²) | O(V+E) | 邻接表更高效 |
| **关键路径** | O(V²) | O(V+E) | 需要拓扑排序 |

---

## 总结

```
✅ 图 = 顶点 + 边 + 多对多关系
✅ 存储结构：邻接矩阵（稠密图）、邻接表（稀疏图）
✅ 遍历：DFS（深度优先）、BFS（广度优先）
✅ 最小生成树：Prim（顶点扩展）、Kruskal（边选择）
✅ 最短路径：Dijkstra（单源）、Floyd（所有顶点对）
✅ 拓扑排序：DAG的顶点排序
✅ 关键路径：AOE网的最长路径

📌 核心应用：
   - 网络设计：最小生成树
   - 路径规划：最短路径
   - 任务调度：拓扑排序
   - 项目管理：关键路径

💡 选择建议：
   - 稠密图 → 邻接矩阵
   - 稀疏图 → 邻接表
   - 单源最短路径 → Dijkstra
   - 所有顶点对最短路径 → Floyd
```

---

**精简要点**: 图是表示多对多关系的重要数据结构。掌握图的存储、遍历和经典算法是理解复杂系统建模的关键 🌐✨

