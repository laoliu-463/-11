# 数据结构习题复习

### 如何根据现有的习题资料规划一份高效的数据结构全考点一天冲刺学习计划❓
#### *数据结构全考点一天强化复习计划*
晨间三小时应当集中攻克算法基础与线性结构。
首先需要熟练掌握时间复杂度分析以及空间复杂度的计算方法。
随后应当复习顺序表与链表的核心操作。
此时重点记忆插入删除时的平均移动次数公式。
午间两小时建议聚焦于栈、队列以及特殊矩阵。
重点练习循环队列的判满判空条件以及元素个数计算。
广义表的表头表尾提取也是高频考点。
下午四小时需要深入钻研树和图的算法应用。
二叉树的性质公式必须烂熟于心。
哈夫曼树的构造以及加权路径长度计算需要动手演练。
图的遍历序列以及最小生成树的选取顺序应多加比对。
傍晚三小时应当转向查找与排序的总结。
二分查找的判定树绘制以及散列表的冲突处理是核心。
七大排序算法的时间复杂度、稳定性和应用场景需对比记忆。
晚间最后一小时用于查漏补缺和编程填空练习。
重点回顾链表删除结点等代码逻辑以确保满分过关。
全天学习应当遵循由浅入深且重在实践的原则。
通过大量的习题巩固来强化对抽象概念的直观理解。
此时切记不要在个别偏难怪题上耗费过多精力。
保持高效的节奏是确保全书考点覆盖的关键。

---

## 📅 复习计划（1.5小时冲刺）

| 时间 | 内容 | 重点 | 题数 |
|:---|:---|:---|:---|
| **0-10min** | 算法基础+线性表 | 链表操作、插入移动次数公式 | 11题 |
| **10-25min** | 栈/队列+广义表 | 出栈序列判断、循环队列公式、表头表尾 | 8题 |
| **25-35min** | 矩阵+树 | 对称矩阵地址计算、n₀=n₂+1、哈夫曼WPL | 10题 |
| **35-50min** | 图 | DFS/BFS序列（头插法）、Kruskal边选取 | 7题 |
| **50-80min** | 查找与排序⭐ | 堆判断、BST、散列表、快排划分、二分ASL | 20题 |
| **80-90min** | 错题回顾+速查表 | 易错点强化 | - |

### 🔥 必记公式
```
顺序表插入移动: n-i+1
循环队列入队: rear = (rear+1) % size
循环队列出队: front = (front+1) % size
下三角行优先: i(i+1)/2 + j
二叉树性质: n₀ = n₂ + 1
无向图最大边: n(n-1)/2
二分查找ASL: 画判定树，(1×1 + 2×2 + 4×3 + ...) / n
```

### 🎯 易错知识点
- **头尾频繁操作** → 带尾指针的单循环链表（不是双链表）
- **不稳定排序** → 快希堆选
- **二分查找条件** → 必须顺序存储（链表不行）
- **头插法邻接表** → 后插入的边在前

---

> 按数据结构类型分类整理

---

## 一、算法基础

### 1. 算法特性
**Q**: 算法必须具备输入、输出和（）等五个特性
**A**: 可行性、确定性和有穷性

### 2. 算法分析目的
**Q**: 算法分析的目的是
**A**: 分析算法的效率以求改进

### 3. 算法复杂度
**Q**: 算法定量分析的两个主要方面是
**A**: 空间复杂性和时间复杂性

### 4. 数据结构分类
**Q**: 从逻辑上可以把数据结构分成
**A**: 线性结构和非线性结构

### 5. 存储结构区别
**Q**: 链式存储结构是通过结点的存储位置相邻来体现数据元素之间的关系（错误）
**解析**: 链式存储是通过**指针链接**体现关系，不是存储位置相邻

---

## 二、线性表

### 顺序表

#### 1. 插入移动次数
**Q**: 在长度为n的顺序表的第i个位置插入元素，移动次数为
**A**: n-i+1

#### 2. 平均移动次数
**Q**: 在顺序表中插入或删除一个元素，平均需要移动多少个元素
**A**: 表长一半

---

### 链表

#### 1. 链表特点
**Q**: 关于链表说法错误的是
**A**: 访问任何一个结点的时间复杂度为O(1) ❌
**解析**: 链表访问需要从头遍历，时间复杂度是**O(n)**

#### 2. 链表存储地址
**Q**: 链式存储结构要求内存地址
**A**: 连续或不连续都可以

#### 3. 单链表插入操作
**Q**: 在结点p之后插入新结点*s的正确操作
```c
s->next = p->next;  // 先连
p->next = s;        // 后断
```

#### 4. 删除表头结点
**Q**: 带头结点单链表L，删除表头结点的正确操作
```c
s = L->next;
L->next = s->next;
free(s);
```

#### 5. 头尾频繁操作的最佳结构
**Q**: 头和尾操作都频繁，选用哪种结构效率最高
**A**: 带尾指针的单循环链表
**解析**: 尾指针可O(1)找到尾和头

#### 6. 删除值为x的结点（代码填空）
```c
typedef int DataType;

typedef struct Node {
    DataType data;
    struct Node *next;
} LinkList;

void deleteX(LinkList *L, DataType x) {
    LinkList *p, *q;
    p = L;
    
    while(p->next && p->next->data != x)  // 条件
    {
        p = p->next;                      // 后移
    }
    
    if(!p->next) return;
    
    q = p->next;
    p->next = q->next;                    // 删除
    free(q);                              // 释放
}
```

---

## 三、栈和队列

### 栈

#### 1. 递归使用的数据结构
**Q**: 递归函数调用时使用哪种数据结构
**A**: 栈

#### 2. 合法出栈序列
**Q**: 入栈序列1,2,3,4,5，合法输出序列是
**A**: 35421
**验证**: 1入2入3入→3出，4入5入→5出，4出，2出，1出

#### 3. 栈的应用
**Q**: 关于栈和队列应用，错误的是
**A**: 队列可以实现递归 ❌ (递归用**栈**)

#### 4. Push/Pop操作序列（2020考研）
**Q**: 空栈S，入栈序列a,b,c,d,e，操作Push,Push,Pop,Push,Pop,Push,Push,Pop后，出栈序列是
**模拟**:
| 操作 | 栈内容 | 出栈 |
|:---|:---|:---|
| Push a | [a] | |
| Push b | [a,b] | |
| Pop | [a] | b |
| Push c | [a,c] | |
| Pop | [a] | c |
| Push d | [a,d] | |
| Push e | [a,d,e] | |
| Pop | [a,d] | e |

**答案**: b,c,e

#### 5. 栈容量与括号匹配（2025考研）
**Q**: 栈容量为3检查括号匹配，不能处理的是
**A**: `[a-(b+[c*(d+e)-f]+g+h)`
**解析**: 最多需要4层嵌套：`[ ( [ ( `，超过容量3

---

### 队列

#### 1. 循环队列操作
**Q**: 大小为6的循环队列，rear=5, front=2，入队1个再出队2个后
**计算**:
- 入队: rear = (5+1) % 6 = **0**
- 出队2次: front = (2+2) % 6 = **4**
**答案**: rear=0, front=4

---

## 四、广义表

#### 1. 表头与表尾
**Q**: 广义表((a,b,c),d)的表尾是
**A**: (d)
**解析**: 表头=(a,b,c)，表尾=剩余部分组成的**表**=(d)

#### 2. 表头表尾性质
**Q**: 正确说法是
**A**: 广义表的表头可以是一个广义表，也可以是一个原子

---

## 五、矩阵

#### 1. 矩阵压缩存储目的
**Q**: 矩阵压缩存储的目的
**A**: 节省存储空间

#### 2. 对称矩阵地址计算
**Q**: 10阶对称矩阵，行优先存储下三角，a00地址为1，求a53地址
**计算**:
```
前i行元素数 = 1+2+...+i = i(i+1)/2
前5行 = 5×6/2 = 15
第6行前4个 = 4
位置 = 15 + 4 = 19
```
**答案**: 19

#### 3. 上三角矩阵列优先存储（2020考研）
**Q**: 10×10对称矩阵M，列优先存储上三角(1≤i≤j≤10)到数组N，求m7,2在N中下标
**计算**:
```
列优先：前j-1列元素数 = 1+2+...+(j-1)
前1列 = 1个元素
第2列的第7个位置 = 1 + 7 - 1 = 7
C语言下标从0开始: 7 - 1 = 6... 不对

重新计算：
第1列: m1,1 → 下标0
第2列: m1,2, m2,2 → 下标1,2
...
前(j-1)列共 1+2+...+(j-1) = j(j-1)/2 个
第j列第i个: j(j-1)/2 + i - 1
m7,2: j=2, i=7 → 2×1/2 + 7 - 1 = 1 + 6 = 7... 

注意：上三角i≤j，所以m7,2是下三角元素
对称矩阵 m7,2 = m2,7
存储m2,7: j=7, i=2 → 7×6/2 + 2 - 1 = 21 + 1 = 22
```
**答案**: 22 (C语言下标)

---

## 六、树与二叉树

### 基本概念

#### 1. 二叉链表的本质
**Q**: 二叉链表是二叉树的
Ⓐ 逻辑结构
Ⓑ 存储结构
Ⓒ 关系表示
Ⓓ 层序序列
**A**: Ⓑ 存储结构
**解析**: 二叉链表是二叉树的一种**链式存储结构**，每个结点包含数据域和左右孩子指针

#### 2. 二叉树高度
**Q**: 对于有n个结点的二叉树，其高度为
Ⓐ nlog₂n
Ⓑ log₂n
Ⓒ ⌊log₂n⌋+1
Ⓓ 不确定
**A**: Ⓓ 不确定
**解析**: 
- 最小高度（完全二叉树）：⌊log₂n⌋+1
- 最大高度（单链）：n
- 所以高度范围是 [⌊log₂n⌋+1, n]，不确定

---

### 完全二叉树

#### 1. 叶结点个数计算（2022考研）
**Q**: 若一棵完全二叉树有768个结点，则该二叉树中叶结点的个数是
Ⓐ 257
Ⓑ 258
Ⓒ 384
Ⓓ 385
**A**: Ⓒ 384
**计算**:
```
完全二叉树性质：n₀ = n₂ + 1（叶结点 = 度2结点 + 1）
总结点：n = n₀ + n₁ + n₂

完全二叉树中 n₁ = 0 或 1
若 n=768（偶数），则 n₁ = 1
n₀ + 1 + n₂ = 768
n₀ + 1 + (n₀-1) = 768
2n₀ = 768
n₀ = 384
```

#### 2. 度为2的结点（性质应用）
**Q**: 具有9个叶子结点的二叉树中有（）个度为2的结点
Ⓐ 7
Ⓑ 8
Ⓒ 9
Ⓓ 10
**A**: Ⓑ 8
**解析**: 二叉树性质 **n₀ = n₂ + 1**，所以 n₂ = n₀ - 1 = 9 - 1 = **8**

---

### 哈夫曼树

#### 1. 哈夫曼树性质
**Q**: 关于哈夫曼树的说法，错误的是
Ⓐ 哈夫曼树是带权路径长度最小的二叉树
Ⓑ 哈夫曼树可以进行编码和译码
Ⓒ 哈夫曼树中包含度为1的结点
Ⓓ 哈夫曼树不唯一
**A**: Ⓒ 哈夫曼树中包含度为1的结点（错误选项）
**解析**: 哈夫曼树只有度为0和度为2的结点，**没有度为1的结点**

#### 2. WPL计算
**Q**: 给定一组数据{5，1，6，9，2，11}，构造哈夫曼树，带权路径长度WPL的值为
Ⓐ 79
Ⓑ 80
Ⓒ 54
Ⓓ 94
**A**: Ⓐ 79
**构造过程**:
```
Step1: 合并1,2 → 3     权值序列：{5,6,9,11,3}
Step2: 合并3,5 → 8     权值序列：{6,9,11,8}
Step3: 合并6,8 → 14    权值序列：{9,11,14}
Step4: 合并9,11 → 20   权值序列：{14,20}
Step5: 合并14,20 → 34  根结点

WPL = 11×2 + 9×2 + 6×3 + 5×3 + 2×4 + 1×4
    = 22 + 18 + 18 + 15 + 8 + 4 = 79
```

---

### 二叉树遍历

#### 1. 由前序+中序还原后序
**Q**: 已知一棵二叉树的前序遍历结果为ABCDEF，中序遍历结果为CBAEDF，则后序遍历的结果为
Ⓐ CBEFDA
Ⓑ FEDCBA
Ⓒ CBEDFA
Ⓓ 不定
**A**: Ⓐ CBEFDA
**还原过程**:
```
前序: A BCDEF → 根=A
中序: CB A EDF → 左子树{C,B}，右子树{E,D,F}

左子树：前序BC，中序CB → 根B，左孩子C
右子树：前序DEF，中序EDF → 根D，左孩子E，右孩子F

       A
      / \
     B   D
    /   / \
   C   E   F

后序: 左→右→根 = CBEFDA
```

---

## 七、图

### 基本概念

#### 1. 无向图边数最大值
**Q**: n个顶点的无向图中，无向边的数目最多为
Ⓐ n-1
Ⓑ n
Ⓒ n(n-1)/2
Ⓓ n(n-1)
**A**: Ⓒ n(n-1)/2
**解析**: 完全无向图每对顶点之间有一条边，共 C(n,2) = **n(n-1)/2** 条边

#### 2. 邻接矩阵对称性
**Q**: 下列哪一种图的邻接矩阵是对称矩阵？
Ⓐ 有向图
Ⓑ 无向图
Ⓒ 有向网
Ⓓ 有向无环图
**A**: Ⓑ 无向图
**解析**: 无向图边无方向，(i,j)边存在则(j,i)也存在，所以邻接矩阵对称

#### 3. 邻接矩阵边数计算
**Q**: 某无向图的邻接矩阵如下所示，则下列说法错误的是
Ⓐ 无向图的邻接矩阵对称
Ⓑ 无向图中包含6个顶点
Ⓒ 无向图包含18条边
Ⓓ 无向图中包含9条边
**A**: Ⓒ 无向图包含18条边（错误选项）
**解析**: 无向图邻接矩阵中，边数 = 非零元素个数 / 2 = 18 / 2 = **9条边**

---

### 图的遍历

#### 1. 图遍历的基本概念
**Q**: 下列关于图的遍历说法不正确的是
Ⓐ 图的遍历时，每一个顶点仅被访问一次
Ⓑ 图的深度遍历不适用于有向图
Ⓒ 图的遍历方法有：深度优先遍历和广度优先遍历
Ⓓ 图的深度优先遍历是一个递归过程
**A**: Ⓑ 图的深度遍历不适用于有向图（错误选项）
**解析**: DFS和BFS都适用于有向图和无向图

#### 2. 判断有向图是否有环
**Q**: 下面哪一方法可以判断出一个有向图是否有环（回路）
Ⓐ 深度优先遍历
Ⓑ 求最短路径
Ⓒ 拓扑排序
Ⓓ 广度优先遍历
**A**: Ⓒ 拓扑排序
**解析**: 若拓扑排序无法输出所有顶点，则图中有环

#### 3. 无向图邻接表DFS序列
**Q**: 有一无向图，按照邻接表（头插法建表）存储，依次输入各边：(v1,v2)、(v1,v4)、(v2,v3)、(v3,v4)、(v3,v5)，则从顶点v1出发的DFS序列为
Ⓐ v1v2v3v5v4
Ⓑ v1v2v5v3v4
Ⓒ v1v4v5v3v2
Ⓓ v1v4v3v5v2
**A**: Ⓓ v1v4v3v5v2
**分析**:
```
头插法建邻接表（后插入的在前）：
v1: [v4, v2]  (先插v2，再插v4，所以v4在前)
v2: [v3, v1]
v3: [v5, v4, v2]
v4: [v3, v1]
v5: [v3]

DFS从v1: v1 → v4(第一邻接点) → v3 → v5 → 回溯 → v2
序列: v1v4v3v5v2
```

#### 4. 无向图邻接矩阵BFS序列
**Q**: 若无向图采用邻接矩阵存储结构，依次输入各边：(v1,v2)、(v1,v4)、(v2,v3)、(v3,v4)、(v3,v5)，则从顶点v2出发的BFS序列为
Ⓐ v2v3v1v4v5
Ⓑ v2v1v3v4v5
Ⓒ v2v1v3v5v4
Ⓓ v2v1v4v5v3
**A**: Ⓑ v2v1v3v4v5
**分析**:
```
邻接矩阵按行号顺序访问邻接点
v2的邻接点: v1, v3（按矩阵行号顺序）
BFS: v2 → 入队v1,v3 → 出队v1，入队v4 → 出队v3，入队v5 → 出队v4 → 出队v5
序列: v2v1v3v4v5
```

#### 5. 有向图邻接表BFS序列
**Q**: 设有向图G=(V,E)，V={v1,v2,v3,v4}，依次输入各边<v2,v1>,<v2,v3>,<v4,v1>,<v1,v4>,<v4,v2>,<v4,v3>，头插法创建邻接表，从顶点v1出发的BFS序列为
Ⓐ v1v4v3v2
Ⓑ v1v3v4v2
Ⓒ v1v4v2v3
Ⓓ v1v3v2v4
**A**: Ⓐ v1v4v3v2
**分析**:
```
头插法邻接表（有向图，记录出边）：
v1: [v4]  (只有<v1,v4>)
v2: [v3, v1]
v4: [v3, v2, v1]

BFS从v1: v1 → 入队v4 → 出队v4，入队v3,v2 → 出队v3 → 出队v2
序列: v1v4v3v2
```

#### 6. 有向图邻接矩阵DFS序列
**Q**: 设有向图G=(V,E)，V={v1,v2,v3,v4}，E={<v1,v3>,<v2,v1>,<v2,v3>,<v4,v1>,<v1,v4>,<v4,v2>}，若按邻接矩阵存储，从顶点v1出发，深度优先遍历的序列为
Ⓐ v1v2v3v4
Ⓑ v1v4v2v3
Ⓒ v1v3v4v2
Ⓓ v1v2v4v3
**A**: Ⓒ v1v3v4v2
**分析**:
```
邻接矩阵按行号顺序（v1出边指向v3,v4）
DFS: v1 → v3(第一个邻接点) → v3无出边，回溯
     → v4 → v2 → v2的出边v1,v3已访问
序列: v1v3v4v2
```

---

### 最小生成树

#### 1. Kruskal算法边选取顺序（2020考研）
**Q**: 已知无向图G如下所示，使用克鲁斯卡尔（Kruskal）算法求图G的最小生成树，加入到最小生成树中的边依次是
Ⓐ (b,f)，(b,d)，(a,e)，(c,e)，(b,e)
Ⓑ (b,f)，(b,d)，(b,e)，(a,e)，(c,e)
Ⓒ (a,e)，(b,e)，(c,e)，(b,d)，(b,f)
Ⓓ (a,e)，(c,e)，(b,e)，(b,f)，(b,d)
**A**: Ⓐ (b,f)，(b,d)，(a,e)，(c,e)，(b,e)
**解析**:
```
Kruskal算法：按边权值从小到大选取，不形成环则加入
1. 选最小权边(b,f)
2. 选(b,d)
3. 选(a,e)
4. 选(c,e)
5. 选(b,e)，连通所有顶点
```

---

## 八、表达式转换（栈应用）

### 中缀转后缀（2024考研）
**Q**: 中缀表达式x+y×(z−u)/v对应的后缀表达式是
Ⓐ xyzu−∗v/+
Ⓑ xuzu−v/∗+
Ⓒ +x/∗y−zuv
Ⓓ +x∗y/−zuv
**A**: Ⓐ xyzu−∗v/+
**转换过程**:
```
x+y×(z−u)/v

分解运算顺序：
1. z−u → zu−
2. y×(z−u) → y(zu−)× → yzu−×
3. (y×(z−u))/v → (yzu−×)v/ → yzu−×v/
4. x+(y×(z−u))/v → x(yzu−×v/)+ → xyzu−×v/+

※注意：×在后缀中写作∗
答案：xyzu−∗v/+
```

---

## ❌ 错题记录

### 2025-12-18 复习错题整理（正确率74%，35题中错9题）

#### 续：第56-65题错题（本轮正确率70%，10题中错3题）

#### 21. 删除表头结点操作
**我选**: A ❌
**正确**: D. s=L->next; L->next=s->next; free(s);
**知识点**: 头结点≠表头结点，表头结点是第一个数据结点（L->next）

#### 22. 矩阵压缩存储目的
**我选**: C. 加快访问速度 ❌
**正确**: B. 节省存储空间
**知识点**: 压缩存储节省空间，但地址转换反而增加访问时间

#### 23. 上三角列优先存储
**我选**: D. 7 ❌
**正确**: B. 22
**知识点**: 对称矩阵m₇,₂=m₂,₇，公式k=j(j-1)/2+i-1

---

#### 续：第46-55题错题（本轮正确率70%，10题中错3题）

#### 18. 二叉树高度
**我选**: C. ⌊log₂n⌋+1 ❌
**正确**: D. 不确定
**知识点**: 最小高度⌊log₂n⌋+1（完全二叉树），最大高度n（单链）

#### 19. BST构造结果比较
**我选**: C ❌
**正确**: D. （100，60，80，90，120，110，130）
**知识点**: 同一组数据不同插入顺序可能产生不同BST结构

#### 20. Push/Pop操作序列
**我选**: C. c,d,e ❌
**正确**: B. b,c,e
**知识点**: 逐步模拟栈状态，Push入、Pop出

---

#### 续：第36-45题错题（本轮正确率60%，10题中错4题）

#### 14. 前序+中序还原后序
**我选**: C. CBEDFA ❌
**正确**: A. CBEFDA
**知识点**: 前序确定根，中序划分左右子树，递归还原后写后序

#### 15. 装填因子含义
**我选**: D. 空间利用率越高 ❌
**正确**: C. 空间利用率越低
**知识点**: α = 已存元素/表长，α越小表越空，利用率越低

#### 16. 稳定排序
**我选**: D. 快速排序 ❌
**正确**: B. 直接插入排序
**知识点**: 快希堆选不稳定，冒泡插入归并稳定

#### 17. 二分查找比较次数
**我选**: C. 2次 ❌
**正确**: B. 3次
**知识点**: 画判定树，比较次数=目标元素所在层数

---

### 2025-12-18 复习错题整理（正确率74%，35题中错9题）

#### 1. 顺序表平均移动次数
**我选**: C. n-1 ❌
**正确**: B. 表长一半（n/2）
**知识点**: 插入第1位移动n个，第n+1位移动0个，平均 = n/2

#### 2. 链表访问复杂度
**我选**: D. 插入删除不需要移动元素 ❌
**正确**: B. 访问任意结点O(1)是错误说法
**知识点**: 链表访问需从头遍历，时间复杂度O(n)，不是O(1)

#### 3. 单链表插入操作
**我选**: D ❌
**正确**: C. s->next=p->next; p->next=s;
**知识点**: 先连后断原则，先保存原链接，再修改指针

#### 4. 递归使用的数据结构
**我选**: A. 队列 ❌
**正确**: C. 栈
**知识点**: 递归用栈保存返回地址和局部变量，后进先出匹配递归特性

#### 5. 循环队列操作
**我选**: C ❌
**正确**: B. rear=0, front=4
**知识点**: 入队rear=(rear+1)%size，出队front=(front+1)%size

#### 6. 广义表表尾
**我选**: C. d ❌
**正确**: A. (d)
**知识点**: 表尾一定是表，不是原子，即使只有一个元素也要加括号

#### 7. 对称矩阵地址计算
**我选**: A. 16 ❌
**正确**: D. 19
**知识点**: 下三角行优先公式 k = i(i+1)/2 + j，a₅₃ = 5×6/2 + 3 + 1 = 19

#### 8. 二叉树度2结点
**我选**: D. 10 ❌
**正确**: B. 8
**知识点**: n₀ = n₂ + 1，所以 n₂ = n₀ - 1 = 9 - 1 = 8

#### 9. 哈夫曼树性质
**我选**: D. 哈夫曼树不唯一 ❌
**正确**: C. 哈夫曼树中包含度为1的结点（这是错误说法）
**知识点**: 哈夫曼树只有度0和度2的结点，无度为1的结点

#### 10. 二叉排序树存储结构
**我选**: C. 顺序 ❌
**正确**: A. 链式
**知识点**: BST用链式存储，方便动态插入删除

#### 11. 二分查找条件
**我选**: C ❌
**正确**: B. 必须有序且必须顺序存储
**知识点**: 二分查找需随机访问能力，链表不支持

#### 12. 一趟确定最终位置
**我选**: B. 直接插入排序 ❌
**正确**: D. 直接选择排序
**知识点**: 选冒快一趟定位（选择、冒泡、快速）

#### 13. 堆序列判断
**我选**: C ❌
**正确**: B. (37,41,47,56,78,84)
**知识点**: 堆验证要逐一检查每个父结点与子结点的大小关系

---

### 第12题：头尾频繁操作的最佳结构
**我选**: D. 双链表 ❌
**正确**: B. 带尾指针的单循环链表 ✓
**分析**: 
- 双链表：找头O(1)，找尾O(n)（除非也有尾指针）
- 带尾指针单循环链表：尾指针rear，找尾O(1)，找头rear->next也是O(1)
- **关键**：单循环+尾指针 = 头尾都是O(1)

---

## 📝 答案速查表

| 题目 | 答案 | 知识点 |
|:---|:---|:---|
| 算法5特性 | 可行性、确定性、有穷性 | 算法基础 |
| 链表访问复杂度 | O(n) | 链表 |
| 顺序表插入移动 | n-i+1 | 顺序表 |
| 头尾频繁操作 | 带尾指针单循环链表 | 链表 |
| 递归用什么结构 | 栈 | 栈 |
| 表尾是什么 | 剩余部分组成的表 | 广义表 |
| 循环队列入队 | rear=(rear+1)%size | 队列 |
| 循环队列出队 | front=(front+1)%size | 队列 |
| 下三角行优先 | i(i+1)/2 + j | 矩阵 |
| 上三角列优先 | j(j-1)/2 + i - 1 | 矩阵 |
| 完全二叉树叶结点 | n偶数时n₁=1，n₀=n/2 | 树 |
| 二叉树性质 | n₀ = n₂ + 1 | 树 |
| 哈夫曼树特点 | 无度为1的结点 | 树 |
| 无向图最大边数 | n(n-1)/2 | 图 |
| 判断有向图有环 | 拓扑排序 | 图 |
| 头插法邻接表 | 后插入的在前 | 图 |
---

## 九、查找与排序

### 堆

#### 1. 堆序列判断
**Q**: 下列哪组序列是堆
Ⓐ (68,41,45,56,37,84)
Ⓑ (37,41,47,56,78,84)
Ⓒ (83,78,55,46,38,64)
Ⓓ (84,38,46,40,56,79)
**A**: Ⓑ (37,41,47,56,78,84)
**解析**: 
```
小顶堆验证（父结点 ≤ 子结点）：
       37
      /  \
    41    47
   /  \   /
  56  78 84

37≤41✓ 37≤47✓ 41≤56✓ 41≤78✓ 47≤84✓
满足小顶堆性质
```
---

### 散列表（哈希表）

#### 1. 装填因子含义
**Q**: 散列表的装填因子，越小说明什么
Ⓐ 平均查找长度越大
Ⓑ 越容易出现冲突
Ⓒ 空间的利用率越低
Ⓓ 空间的利用率越高
**A**: Ⓒ 空间的利用率越低
**解析**: 装填因子 α = 已存元素数 / 表长。α越小，表越空，空间利用率越低，但冲突概率也越低
---

### 二叉排序树（BST）

#### 1. 构造结果比较
**Q**: 分别以下列序列构造二叉排序树，与用其它三个序列所构造的结果不同的是
Ⓐ （100，80，90，60，120，110，130）
Ⓑ （100，80，60，90，120，130，110）
Ⓒ （100，120，110，130，80，60，90）
Ⓓ （100，60，80，90，120，110，130）
**A**: Ⓓ （100，60，80，90，120，110，130）
**解析**: 
```
Ⓐ Ⓑ Ⓒ 构造结果相同：    Ⓓ 构造结果：
      100                   100
     /   \                 /   \
   80    120              60   120
  / \    / \               \   / \
 60 90 110 130            80 110 130
                           \
                           90
Ⓓ中60先插入，80成为60的右孩子，结构不同
```
---

### 排序算法

#### 1. 冒泡排序时间复杂度
**Q**: 在对n个元素进行起泡排序的过程中，平均的时间复杂度为
Ⓐ O(n)
Ⓑ O(n²)
Ⓒ O(nlog₂n)
Ⓓ O(1)
**A**: Ⓑ O(n²)
**解析**: 冒泡排序平均/最坏时间复杂度均为 **O(n²)**，最好情况（已有序）为O(n)

#### 2. 比较次数与初始序列的关系
**Q**: 直接插入排序和简单选择排序两种排序算法中，与排序码的比较次数与初始序列有关的是
Ⓐ 无法判定
Ⓑ 简单选择排序、直接插入排序都有关
Ⓒ 直接插入排序
Ⓓ 简单选择排序
**A**: Ⓒ 直接插入排序
**解析**: 
- **直接插入排序**：比较次数取决于元素初始位置，越有序比较越少
- **简单选择排序**：无论初始状态如何，比较次数固定为 n(n-1)/2

#### 3. 一趟排序确定最终位置
**Q**: 下列排序算法，哪个在一趟排序结束后一定能选出一个元素放在其最终位置上
Ⓐ 希尔排序
Ⓑ 直接插入排序
Ⓒ 归并排序
Ⓓ 直接选择排序
**A**: Ⓓ 直接选择排序
**解析**: 
- **直接选择排序**：每趟选出最小/最大元素放到最终位置
- **冒泡排序**也有此特性（每趟将最大元素"冒"到末尾）
- **快速排序**的基准元素也会就位
---

### 二分查找

#### 1. 7个元素的ASL计算
**Q**: 具有7个记录的有序表顺序存储，进行二分法查找，等概率情况下查找成功的平均查找长度(ASL)为
Ⓐ 17/7
Ⓑ 20/7
Ⓒ 19/7
Ⓓ 18/7
**A**: Ⓐ 17/7
**解析**: 
```
构建判定树：
        4(1次)
      /   \
    2(2次) 6(2次)
   / \    / \
  1   3  5   7
(3次)(3次)(3次)(3次)

ASL = (1×1 + 2×2 + 4×3) / 7 = (1+4+12) / 7 = 17/7
```

#### 4. 快速排序一趟划分
**Q**: 一组记录的排序码为（47，71，56，28，40，84），则利用快速排序的方法，以第一个记录为基准得到的一次划分结果为
Ⓐ (40,28,47,71,56,84)
Ⓑ (28,40,47,56,71,84)
Ⓒ (40,28,47,56,71,84)
Ⓓ (40,28,47,84,56,71)
**A**: Ⓒ (40,28,47,56,71,84)
**解析**: 
```
基准=47
原序列: 47 71 56 28 40 84
        ↑                 ↑
       low              high

1. high从右找<47的: 40  → 交换 → 40 71 56 28 [47] 84
2. low从左找>47的: 71   → 交换 → 40 [47] 56 28 71 84
3. high找<47: 28       → 交换 → 40 28 56 [47] 71 84
4. low找>47: 56        → 交换 → 40 28 [47] 56 71 84
结果: (40,28,47,56,71,84)
```

#### 2. 线性探测法查找次数
**Q**: 设散列表的长度为11，散列函数为H(k)=k%7，用线性探测法处理冲突，依次插入关键字：9，13，21，2，33，52。在建立好的散列表中，查找关键字2时需要比较的次数为
Ⓐ 2
Ⓑ 3
Ⓒ 1
Ⓓ 4
**A**: Ⓐ 2
**解析**: 
```
插入过程（H(k)=k%7）：
9:  H(9)=2   → 位置2
13: H(13)=6  → 位置6
21: H(21)=0  → 位置0
2:  H(2)=2   → 冲突，探测位置3 → 位置3
33: H(33)=5  → 位置5
52: H(52)=3  → 冲突，探测位置4 → 位置4

散列表：[21, _, 9, 2, 52, 33, 13, _, _, _, _]
         0   1  2  3   4   5   6

查找2：先查位置2(是9)→再查位置3(是2)，共比较2次
```

#### 2. 二叉排序树存储结构
**Q**: 二叉排序树是一种动态查找表，它既拥有类似折半查找的特性，又采用了（）存储结构
Ⓐ 链接
Ⓑ 索引
Ⓒ 顺序
Ⓓ 散列
**A**: Ⓐ 链接
**解析**: 二叉排序树使用**链式存储结构**，方便动态插入删除，同时保持有序性支持类似折半的查找效率

#### 3. 查找关键字比较次数
**Q**: 依次插入关键字（41，27，30，44，45）生成二叉排序树，则查找关键字值44（查找成功），需做的关键字比较次数为
Ⓐ 3
Ⓑ 4
Ⓒ 5
Ⓓ 2
**A**: Ⓓ 2
**解析**: 
```
构造BST：
    41
   /  \
  27   44
   \    \
   30   45

查找44：41(比较1次，44>41右走) → 44(比较2次，找到)
共比较2次
```

#### 3. 链地址法查找比较
**Q**: 设关键字序列为（61，2，78，22，21，16），散列函数为H(key)=key%7，采用链地址法解决冲突（用头插法向单链表中插入结点）。请问在建立好的散列表中，查找关键字78时，需要依次与哪些关键字比较
Ⓐ 21、78
Ⓑ 22、78
Ⓒ 61、78
Ⓓ 78、22
**A**: Ⓑ 22、78
**解析**: 
```
散列地址计算（H(key)=key%7）：
61%7=5, 2%7=2, 78%7=1, 22%7=1, 21%7=0, 16%7=2

链表（头插法，后插入的在前）：
0: 21
1: 22 → 78  (22后插入，在链表头部)
2: 16 → 2
5: 61

查找78：先到1号位置，比较22(不是)→比较78(找到)
依次比较：22、78
```

#### 4. 散列存储结构定义
**Q**: 若结点的存储地址与其关键字之间存在某种函数关系，则称这种存储结构为
Ⓐ 散列存储结构
Ⓑ 顺序存储结构
Ⓒ 链式存储结构
Ⓓ 索引存储结构
**A**: Ⓐ 散列存储结构
**解析**: 散列/哈希存储的核心：通过**散列函数**建立关键字与存储地址的映射关系

#### 5. 不稳定的排序算法
**Q**: 在下面的排序方法中，不稳定的排序方法为
Ⓐ 起泡排序
Ⓑ 归并排序
Ⓒ 直接插入排序
Ⓓ 快速排序
**A**: Ⓓ 快速排序
**解析**: 
- **不稳定排序**（会改变相同元素相对顺序）：快速排序、希尔排序、堆排序、选择排序
- **稳定排序**：冒泡排序、插入排序、归并排序
- 口诀：**快希堆选**不稳定

#### 6. 直接插入排序趟数
**Q**: n个记录若采用直接插入排序，需要排序多少趟
Ⓐ n+1
Ⓑ n
Ⓒ log(n)
Ⓓ n-1
**A**: Ⓓ n-1
**解析**: 直接插入排序从第2个元素开始，每趟将一个元素插入到前面有序序列中，共需 **n-1** 趟

#### 2. 5个元素的二分查找
**Q**: 在有序表（7,10,16,19,23）中，用二分法查找关键字值10（成功），需做的与关键字比较次数为
Ⓐ 4
Ⓑ 3
Ⓒ 2
Ⓓ 1
**A**: Ⓑ 3
**解析**: 
```
有序表: 7, 10, 16, 19, 23（下标1-5）
       [1] [2] [3] [4] [5]

第1次：mid=(1+5)/2=3，比较16，10<16，右边界=2
第2次：mid=(1+2)/2=1，比较7，10>7，左边界=2
第3次：mid=(2+2)/2=2，比较10，找到！
共比较3次
```

#### 3. 二分查找的条件
**Q**: 下面关于二分查找的叙述正确的是
Ⓐ 表必须有序且表中数据必须是整型，实型或字符型
Ⓑ 表必须有序，且表只能以顺序方式存储
Ⓒ 表必须有序，而且只能从小到大排列
Ⓓ 表必须有序，表可以顺序方式存储，也可以链表方式存储
**A**: Ⓑ 表必须有序，且表只能以顺序方式存储
**解析**: 二分查找需要随机访问能力（通过下标直接访问中间元素），链表不支持随机访问，因此只能用于**顺序存储**

#### 7. 平均性能最好的内排序
**Q**: 就平均性能而言，目前最好的内排序方法是
Ⓐ 起泡排序
Ⓑ 快速排序
Ⓒ 希尔排序
Ⓓ 堆排序
**A**: Ⓑ 快速排序
**解析**: 
| 排序算法 | 平均时间复杂度 | 最坏时间复杂度 |
|:---|:---|:---|
| 快速排序 | O(nlog₂n) | O(n²) |
| 堆排序 | O(nlog₂n) | O(nlog₂n) |
| 归并排序 | O(nlog₂n) | O(nlog₂n) |
| 希尔排序 | O(n^1.3) | O(n²) |

快速排序平均性能最优，常数因子小

#### 8. 归并排序特点
**Q**: 下列排序算法中，哪种排序方法是将两个或多个有序表合并成一个有序表
Ⓐ 堆排序
Ⓑ 归并排序
Ⓒ 直接选择排序
Ⓓ 起泡排序
**A**: Ⓑ 归并排序
**解析**: 归并排序（Merge Sort）的核心思想：**分治** + **合并**，将两个已排序的子表合并成一个有序表

#### 9. 稳定的排序方法
**Q**: 在直接插入排序、堆排序、希尔排序、快速排序中稳定的排序方法是
Ⓐ 希尔排序
Ⓑ 直接插入排序
Ⓒ 堆排序
Ⓓ 快速排序
**A**: Ⓑ 直接插入排序
**解析**: 四种排序中只有**直接插入排序**是稳定的，其他三种（希尔、堆、快速）都是不稳定排序

---

## 十、编程填空题

### 链表操作

#### 1. 删除值为x的结点
**题目**: 补全删除单链表中第一个值为x的结点的函数
```c
typedef int DataType;

typedef struct Node {
    DataType data;
    struct Node *next;
} LinkList;

void deleteX(LinkList *L, DataType x) {
    LinkList *p, *q;
    p = L;  // p从头结点开始
    
    while(p->next && ______①______)  // 若p后继结点的数据不是x
    {
        ______②______;  // p指针后移一步
    }
    
    if(!p->next) return;  // 空表或未找到时退出
    
    q = p->next;
    ______③______;  // 从单链表中删除x结点
    ______④______;  // 释放q所指结点的空间
}
```

**答案**:
| 空格 | 答案 | 解释 |
|:---|:---|:---|
| ① | `p->next->data != x` | 判断后继结点数据是否为x |
| ② | `p = p->next` | 指针后移 |
| ③ | `p->next = q->next` | 跳过q结点，完成删除 |
| ④ | `free(q)` | 释放被删除结点的内存 |

---

*整理时间: 2025-12-17*