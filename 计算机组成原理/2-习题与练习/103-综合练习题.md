# 103-综合练习题 (Comprehensive Exercises)

> **简介**：本文件收录了计算机体系结构、数据表示、指令系统等方面的综合练习题，包含详细解析。
> **Introduction**: This file contains comprehensive exercises on computer architecture, data representation, instruction systems, etc., with detailed explanations.
> **来源**：用户提供
> **最后更新**：2025年1月

---

## 一、单选题 (Multiple Choice Questions)

1. **假设二进制补码的长度为 4 位，哪种算术运算会导致溢出？**
   **Assuming the length of the two's complement binary number is 4 bits, which arithmetic operation will cause an overflow?**
    A. 3+4
    B. (-4)+(-4)
    C. 4-(-4)
    D. 2+4

    > **解析 (Explanation)**: 4位补码的表示范围是 -8 到 +7 (Range of 4-bit two's complement is -8 to +7)。 A: 3+4=7 (OK) B: -4+(-4)=-8 (OK, 最小负数/Minimum negative number) C: 4-(-4) = 4+4 = 8，超过了最大值 7，发生正溢出 (Exceeds max value 7, positive overflow)。 D: 2+4=6 (OK)
>


2. **以符号-数值格式表示的 (n+1) 位整数的范围是 —————。**
   **The range of an (n+1)-bit integer represented in sign-magnitude format is —————.**
    A. -2ⁿ - 1 < x < 2ⁿ - 1
    B. -2ⁿ -1 ≤ x < 2ⁿ - 1
    C. -2ⁿ -1 < x ≤ 2ⁿ - 1
    D. -2ⁿ -1 ≤ x ≤ 2ⁿ - 1

    > **解析 (Explanation)**: 符号-数值格式（原码）中，1位符号位，n位数值位 (1 sign bit, n magnitude bits)。 最大值 (Max): +(2ⁿ - 1) 最小值 (Min): -(2ⁿ - 1) 范围 (Range): -(2ⁿ - 1) ≤ x ≤ 2ⁿ - 1
>


3. **给定以下 C 程序片段：**
   **Given the following C program fragment:**
    ```c
    short si = -32767;
    unsigned short usi = si;
    ```
    **执行这两条语句后，usi 的值为 ( )。**
    **After executing these two statements, the value of usi is ( ).**
    A. -32767
    B. 32767
    C. 32768
    D. 32769

    > **解析 (Explanation)**: `short si = -32767`。在16位机器中，-32767 的补码形式为 (In 16-bit machine, two's complement of -32767 is): 原码 (Sign-Magnitude): 1111 1111 1111 1111 反码 (One's Complement): 1000 0000 0000 0000 补码 (Two's Complement): 1000 0000 0000 0001 (即 0x8001) `unsigned short usi = si`。将 0x8001 解释为无符号数 (Interpret 0x8001 as unsigned): 0x8000 = 32768 0x8001 = 32768 + 1 = 32769
>


4. **假设有符号整数用二进制补码表示。如果整型变量 x 和 y 的机器号分别为 FFFF FFDFH 和 0000 0041H，那么 x、y 的值以及 x - y 的机器号分别为————。**
   **Assume signed integers are represented in two's complement. If the machine codes for integer variables x and y are FFFF FFDFH and 0000 0041H respectively, then the values of x, y and the machine code for x - y are ————.**
    A. x = -65，y = 41，x - y 溢出的机器编号 (overflow machine code)
    B. x = -33，y = 65，x - y 的机器编号为 FFFF FF9DH
    C. x = -33，y = 65，x - y 的机器编号为 FFFF FF9EH
    D. x = -65，y = 41，x - y 的机器编号为 FFFF FF96H

    > **解析 (Explanation)**: x = FFFF FFDFH。取反加一得到绝对值 (Invert and add 1 for absolute value): 0000 0020H + 1 = 0000 0021H = 33。符号位为1，故 x = -33。 y = 0000 0041H = 65。 x - y = -33 - 65 = -98。 -98 的机器号（补码/Two's Complement）： 98 = 64 + 32 + 2 = 0x62 原码 (Sign-Magnitude): 0000 ... 0062 取反 (Invert): FFFF FF9D 加一 (Add 1): FFFF FF9E
>


5. **IEEE 754 单精度浮点数表示法：C6400000H。该数的值为_______。**
   **IEEE 754 single-precision floating-point representation: C6400000H. The value of this number is _______.**
    A. -1.5*2^13
    B. -1.5*2^12
    C. -0.5*2^13
    D. -0.5*2^12

    > **解析 (Explanation)**: C6400000H => `1 10001100 10000000000000000000000` 符号位 (Sign) S = 1 (负数/Negative) 指数位 (Exponent) E = 10001100 = 140。真实指数 (Actual Exponent) = 140 - 127 = 13。 尾数位 (Mantissa) M = 1.100... (Binary) = 1.5 (Decimal) 值 (Value) = -1.5 × 2¹³
>


6. **当CPU执行一条指令时，该指令的地址由__________提供。**
   **When the CPU executes an instruction, the address of that instruction is provided by __________.**
    A. 程序计数器（PC） (Program Counter)
    B. 指令的地址代码字段 (Address field of the instruction)
    C. 操作系统 (Operating System)
    D. 程序员 (Programmer)

    > **解析 (Explanation)**: 程序计数器 (PC) 始终存放下一条要执行指令的地址 (PC always holds the address of the next instruction to be executed)。
>


7. **每条机器指令，______都指定要执行的操作（例如 ADD、I/O）。**
   **For every machine instruction, ______ specifies the operation to be performed (e.g., ADD, I/O).**
    A. 操作代码 (Opcode)
    B. 源操作数参考 (Source Operand Reference)
    C. 结果操作数参考 (Result Operand Reference)
    D. 下一步说明参考 (Next Instruction Reference)

    > **解析 (Explanation)**: 操作码 (Opcode) 字段指定指令要执行的操作 (Opcode field specifies the operation)。
>


8. **在栈式计算机中，一些零地址指令在指令中不提供操作数地址，两个操作数来自________。**
   **In a stack computer, some zero-address instructions do not provide operand addresses in the instruction; the two operands come from ________.**
    A. 累加器和寄存器 (Accumulator and Register)
    B. 累加器和临时寄存器 (Accumulator and Temporary Register)
    C. 堆栈顶部和次顶部单元 (Top of Stack and Second Top of Stack)
    D. 堆栈顶部单元和一个临时寄存器 (Top of Stack and a Temporary Register)

    > **解析 (Explanation)**: 栈式计算机的零地址指令（如 ADD）通常隐含操作数为栈顶元素和次栈顶元素，结果压回栈顶 (Zero-address instructions implicitly use the top two elements of the stack)。
>


9. **一个计算机系统使用 32 位指令和 12 位地址码。如果定义了 250 条双地址指令，那么可能的单地址指令的数量为 ()。**
   **A computer system uses 32-bit instructions and 12-bit address codes. If 250 two-address instructions are defined, the number of possible one-address instructions is ().**
    A. 2¹²
    B. 2¹³
    C. 2¹
    D. 3 × 2¹³

    > **解析 (Explanation)**: 指令长 32 位，地址 12 位 (32-bit instruction, 12-bit address)。 双地址指令格式 (2-Addr Format): Op(8 bits) + Addr1(12 bits) + Addr2(12 bits)。 Opcode 8位共有 256 种状态。已使用 250 种。剩余 256 - 250 = 6 种前缀 (6 prefixes remaining)。 单地址指令利用 Addr2 的空间进行扩展，即多了 12 位 (Expand into Addr2 space, +12 bits)。 可用的单地址指令数 = 剩余前缀数 × 2¹² = 6 × 2¹² = 3 × 2 × 2¹² = 3 × 2¹³。
>


10. **在设计指令系统时，假设使用 16 位定长指令字格式，操作码使用扩展编码方案。地址码为 6 位，有三种指令格式：零地址、一地址和二地址。如果有 12 条二地址指令和 254 条一地址指令，那么零地址指令的最大数量是 _________。**
    **When designing an instruction system, assume a 16-bit fixed-length instruction word format is used, with the opcode using an expanding encoding scheme. The address code is 6 bits, and there are three instruction formats: zero-address, one-address, and two-address. If there are 12 two-address instructions and 254 one-address instructions, then the maximum number of zero-address instructions is _________.**
    A. 0
    B. 2
    C. 64
    D. 128

    > **解析 (Explanation)**: 16位指令，6位地址 (16-bit instruction, 6-bit address)。 双地址 (2-Addr): Op(4 bits) + A1(6) + A2(6)。Opcode 4位 (16-12=4)。剩余 16 - 12 = 4 种前缀 (4 prefixes left)。 单地址 (1-Addr): Op(10 bits) + A1(6)。可用 4 × 2⁶ = 256 种。已用 254 种。剩余 256 - 254 = 2 种前缀 (2 prefixes left)。 零地址 (0-Addr): Op(16 bits)。可用 2 × 2⁶ = 128 种。
>


11. **一台计算机使用 16 位定长指令字格式。操作码和寻址方式的位数是固定的。指令集有 48 条指令，支持四种寻址方式：直接、间接、立即和相对。在单地址指令中，使用直接寻址的可寻址范围是 _________。**
    **A computer uses a 16-bit fixed-length instruction word format. The number of bits for the opcode and the addressing mode is fixed. The instruction set has 48 instructions and supports four addressing modes: direct, indirect, immediate, and relative. In a single-address instruction, the addressable range using direct addressing is _________.**
    A. 0–255
    B. 0–1023
    C. -128–127
    D. -512–511

    > **解析 (Explanation)**: 16位指令 (16-bit instruction)。 48条指令需 6 位操作码 (2⁵=32 < 48 < 2⁶=64) (6 bits for Opcode)。 4种寻址方式需 2 位 (2 bits for Mode)。 固定位宽，故 Op+Mode 占用 6+2=8 位 (Op+Mode takes 8 bits)。 剩余地址位 = 16 - 8 = 8 位 (Remaining address bits = 8)。 直接寻址范围 2⁸ = 256 (0~255)。
>


12. **在以下寻址方式中，哪一种最适合通过下标顺序访问数组元素？**
    **Among the following addressing modes, which one is most suitable for accessing elements of an array in sequential order by index?**
    A. 相对寻址 (Relative addressing)
    B. 寄存器寻址 (Register addressing)
    C. 直接寻址 (Direct addressing)
    D. 变址寻址 (Indexed addressing)

    > **解析 (Explanation)**: 变址寻址 (Indexed Addressing) 专门用于数组访问，通过 基址+变址(下标) 计算有效地址 (Calculates effective address via Base + Index)。
>


13. **在指令寻址方式中，获取操作数最快的方式是__________。**
    **Among the instruction addressing modes, the fastest way to obtain an operand is __________.**
    A. 直接寻址 (Direct addressing)
    B. 立即寻址 (Immediate addressing)
    C. 寄存器寻址 (Register addressing)
    D. 间接寻址 (Indirect addressing)

    > **解析 (Explanation)**: 立即寻址 (Immediate Addressing) 的操作数直接包含在指令中，无需访问内存或寄存器，速度最快 (Operand is in the instruction, no memory/register access needed)。
>


14. **假设指令中的地址码提供了操作数的有效地址，那么这条指令使用的是_________。**
    **Assuming the address code in the instruction provides the effective address of the operand, then this instruction uses _________.**
    A. 直接寻址 (Direct addressing)
    B. 立即寻址 (Immediate addressing)
    C. 寄存器寻址 (Register addressing)
    D. 间接寻址 (Indirect addressing)

    > **解析 (Explanation)**: 直接寻址 (Direct Addressing) 的指令地址码字段直接给出操作数的有效地址 (Address field gives the effective address directly)。
>


15. **假设寄存器 R 中的值为 200。内存地址单元 200 和 300 的内容分别为 300 和 400。在什么寻址方式下，访问到的操作数为 200？**
    **Assume the value in register R is 200. The contents of memory address units 200 and 300 are 300 and 400, respectively. Under which addressing mode will the operand accessed be 200?**
    A. 直接寻址 (Direct addressing)
    B. 寄存器间接寻址 (Register indirect addressing)
    C. 内存间接寻址 (Memory indirect addressing)
    D. 寄存器寻址 (Register addressing)

    > **解析 (Explanation)**: R = 200。 目标操作数是 200 (Target operand is 200)。 寄存器寻址：直接取 R 的值，即 200 (Register Addressing: takes value of R directly)。
>


16. **指令流水线将一条指令分为三个阶段：取指、译码和执行，每个阶段的时间为 Δt。如果执行 12 条指令，所需的总时间是__________。**
    **The instruction pipeline divides an instruction into three stages: fetch, decode, and execute, and the time for each stage is Δt. If 12 instructions are executed, the total time required is __________.**
    A. 12Δt
    B. 14Δt
    C. 16Δt
    D. 18Δt

    > **解析 (Explanation)**: 流水线执行时间公式 (Pipeline execution time formula): T = (k + n - 1)Δt。 k=3 (级数/stages), n=12 (指令数/instructions)。 T = (3 + 12 - 1)Δt = 14Δt。
>


17. **间接周期的目的是获取 _________________。**
    **The aim of the indirect cycle is to get _________________.**
    A. 一个操作数 (an operand)
    B. 一条指令 (an instruction)
    C. 指令的地址 (an address of an instruction)
    D. 操作数的地址 (the address of an operand)

    > **解析 (Explanation)**: 间接周期 (Indirect Cycle) 的目的是为了读取存储器以获取操作数的有效地址（当使用间接寻址时）(To fetch the effective address of the operand from memory)。
>


18. **以下哪项不是 RISC 处理器的特征？______。**
    **Which is NOT a characteristic of RISC processor? ______。**
    A. 间接寻址模式 (indirect addressing mode)
    B. 寄存器到寄存器操作 (register to register operations)
    C. 单一指令大小 (a single instruction size)
    D. 简单的指令格式 (simple instruction format)

    > **解析 (Explanation)**: RISC (精简指令集) 的特点包括指令长度固定、指令格式简单、大量使用寄存器。复杂的寻址方式（如间接寻址）通常是 CISC 的特征 (Complex addressing modes like indirect addressing are typical of CISC)。
>


19. **正确的指令周期序列是 _________________ 。**
    **The correct instruction cycle sequence is _________________ .**
    A. Fetch , Indirect , Execute and Interrupt
    B. Fetch , Execute , Indirect and Interrupt
    C. Fetch , Indirect , Interrupt and Execute
    D. Indirect , Fetch , Execute and Interrupt

    > **解析 (Explanation)**: 标准的指令周期流程：取指 (Fetch) -> 间接寻址 (Indirect, 如果需要) -> 执行 (Execute) -> 中断处理 (Interrupt, 如果有)。
>


20. **在_________末尾，MBR的内容是指令。**
    **At the end of the _________, the content of MBR is an instruction.**
    A. 间接子周期 (Indirect cycle)
    B. 获取子周期 (Fetch cycle)
    C. 执行子周期 (Execute cycle)
    D. 中断子周期 (Interrupt cycle)

    > **解析 (Explanation)**: MBR (Memory Buffer Register) 在取指周期 (Fetch Cycle) 结束时，存放从内存读出的指令内容，随后传送给指令寄存器 (IR) (MBR holds the fetched instruction at the end of Fetch cycle)。
>

