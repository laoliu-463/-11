# 103-ç»¼åˆç»ƒä¹ é¢˜ (Comprehensive Exercises)

> **ç®€ä»‹**ï¼šæœ¬æ–‡ä»¶æ”¶å½•äº†è®¡ç®—æœºä½“ç³»ç»“æ„ã€æ•°æ®è¡¨ç¤ºã€æŒ‡ä»¤ç³»ç»Ÿç­‰æ–¹é¢çš„ç»¼åˆç»ƒä¹ é¢˜ï¼ŒåŒ…å«è¯¦ç»†è§£æã€‚
> **Introduction**: This file contains comprehensive exercises on computer architecture, data representation, instruction systems, etc., with detailed explanations.
> **æ¥æº**ï¼šç”¨æˆ·æä¾›
> **æœ€åæ›´æ–°**ï¼š2025å¹´1æœˆ

---

## ä¸€ã€å•é€‰é¢˜ (Multiple Choice Questions)

1. **å‡è®¾äºŒè¿›åˆ¶è¡¥ç çš„é•¿åº¦ä¸º 4 ä½ï¼Œå“ªç§ç®—æœ¯è¿ç®—ä¼šå¯¼è‡´æº¢å‡ºï¼Ÿ**
   **Assuming the length of the two's complement binary number is 4 bits, which arithmetic operation will cause an overflow?**
    A. 3+4
    B. (-4)+(-4)
    C. 4-(-4)
    D. 2+4

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): C**
> *   **è§£æ (Explanation)**:
> *   4ä½è¡¥ç çš„è¡¨ç¤ºèŒƒå›´æ˜¯ -8 åˆ° +7 (Range of 4-bit two's complement is -8 to +7)ã€‚
> *   A: 3+4=7 (OK)
> *   B: -4+(-4)=-8 (OK, æœ€å°è´Ÿæ•°/Minimum negative number)
> *   C: 4-(-4) = 4+4 = 8ï¼Œè¶…è¿‡äº†æœ€å¤§å€¼ 7ï¼Œå‘ç”Ÿæ­£æº¢å‡º (Exceeds max value 7, positive overflow)ã€‚
> *   D: 2+4=6 (OK)
</details>

2. **ä»¥ç¬¦å·-æ•°å€¼æ ¼å¼è¡¨ç¤ºçš„ (n+1) ä½æ•´æ•°çš„èŒƒå›´æ˜¯ â€”â€”â€”â€”â€”ã€‚**
   **The range of an (n+1)-bit integer represented in sign-magnitude format is â€”â€”â€”â€”â€”.**
    A. -2â¿ - 1 < x < 2â¿ - 1
    B. -2â¿ -1 â‰¤ x < 2â¿ - 1
    C. -2â¿ -1 < x â‰¤ 2â¿ - 1
    D. -2â¿ -1 â‰¤ x â‰¤ 2â¿ - 1

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): D**
> *   **è§£æ (Explanation)**:
> *   ç¬¦å·-æ•°å€¼æ ¼å¼ï¼ˆåŸç ï¼‰ä¸­ï¼Œ1ä½ç¬¦å·ä½ï¼Œnä½æ•°å€¼ä½ (1 sign bit, n magnitude bits)ã€‚
> *   æœ€å¤§å€¼ (Max): +(2â¿ - 1)
> *   æœ€å°å€¼ (Min): -(2â¿ - 1)
> *   èŒƒå›´ (Range): -(2â¿ - 1) â‰¤ x â‰¤ 2â¿ - 1
</details>

3. **ç»™å®šä»¥ä¸‹ C ç¨‹åºç‰‡æ®µï¼š**
   **Given the following C program fragment:**
    ```c
    short si = -32767;
    unsigned short usi = si;
    ```
    **æ‰§è¡Œè¿™ä¸¤æ¡è¯­å¥åï¼Œusi çš„å€¼ä¸º ( )ã€‚**
    **After executing these two statements, the value of usi is ( ).**
    A. -32767
    B. 32767
    C. 32768
    D. 32769

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): D**
> *   **è§£æ (Explanation)**:
> *   `short si = -32767`ã€‚åœ¨16ä½æœºå™¨ä¸­ï¼Œ-32767 çš„è¡¥ç å½¢å¼ä¸º (In 16-bit machine, two's complement of -32767 is):
> *   åŸç  (Sign-Magnitude): 1111 1111 1111 1111
> *   åç  (One's Complement): 1000 0000 0000 0000
> *   è¡¥ç  (Two's Complement): 1000 0000 0000 0001 (å³ 0x8001)
> *   `unsigned short usi = si`ã€‚å°† 0x8001 è§£é‡Šä¸ºæ— ç¬¦å·æ•° (Interpret 0x8001 as unsigned):
> *   0x8000 = 32768
> *   0x8001 = 32768 + 1 = 32769
</details>

4. **å‡è®¾æœ‰ç¬¦å·æ•´æ•°ç”¨äºŒè¿›åˆ¶è¡¥ç è¡¨ç¤ºã€‚å¦‚æœæ•´å‹å˜é‡ x å’Œ y çš„æœºå™¨å·åˆ†åˆ«ä¸º FFFF FFDFH å’Œ 0000 0041Hï¼Œé‚£ä¹ˆ xã€y çš„å€¼ä»¥åŠ x - y çš„æœºå™¨å·åˆ†åˆ«ä¸ºâ€”â€”â€”â€”ã€‚**
   **Assume signed integers are represented in two's complement. If the machine codes for integer variables x and y are FFFF FFDFH and 0000 0041H respectively, then the values of x, y and the machine code for x - y are â€”â€”â€”â€”.**
    A. x = -65ï¼Œy = 41ï¼Œx - y æº¢å‡ºçš„æœºå™¨ç¼–å· (overflow machine code)
    B. x = -33ï¼Œy = 65ï¼Œx - y çš„æœºå™¨ç¼–å·ä¸º FFFF FF9DH
    C. x = -33ï¼Œy = 65ï¼Œx - y çš„æœºå™¨ç¼–å·ä¸º FFFF FF9EH
    D. x = -65ï¼Œy = 41ï¼Œx - y çš„æœºå™¨ç¼–å·ä¸º FFFF FF96H

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): C**
> *   **è§£æ (Explanation)**:
> *   x = FFFF FFDFHã€‚å–ååŠ ä¸€å¾—åˆ°ç»å¯¹å€¼ (Invert and add 1 for absolute value): 0000 0020H + 1 = 0000 0021H = 33ã€‚ç¬¦å·ä½ä¸º1ï¼Œæ•… x = -33ã€‚
> *   y = 0000 0041H = 65ã€‚
> *   x - y = -33 - 65 = -98ã€‚
> *   -98 çš„æœºå™¨å·ï¼ˆè¡¥ç /Two's Complementï¼‰ï¼š
> *   98 = 64 + 32 + 2 = 0x62
> *   åŸç  (Sign-Magnitude): 0000 ... 0062
> *   å–å (Invert): FFFF FF9D
> *   åŠ ä¸€ (Add 1): FFFF FF9E
</details>

5. **IEEE 754 å•ç²¾åº¦æµ®ç‚¹æ•°è¡¨ç¤ºæ³•ï¼šC6400000Hã€‚è¯¥æ•°çš„å€¼ä¸º_______ã€‚**
   **IEEE 754 single-precision floating-point representation: C6400000H. The value of this number is _______.**
    A. -1.5*2^13
    B. -1.5*2^12
    C. -0.5*2^13
    D. -0.5*2^12

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): A**
> *   **è§£æ (Explanation)**:
> *   C6400000H => `1 10001100 10000000000000000000000`
> *   ç¬¦å·ä½ (Sign) S = 1 (è´Ÿæ•°/Negative)
> *   æŒ‡æ•°ä½ (Exponent) E = 10001100 = 140ã€‚çœŸå®æŒ‡æ•° (Actual Exponent) = 140 - 127 = 13ã€‚
> *   å°¾æ•°ä½ (Mantissa) M = 1.100... (Binary) = 1.5 (Decimal)
> *   å€¼ (Value) = -1.5 Ã— 2Â¹Â³
</details>

6. **å½“CPUæ‰§è¡Œä¸€æ¡æŒ‡ä»¤æ—¶ï¼Œè¯¥æŒ‡ä»¤çš„åœ°å€ç”±__________æä¾›ã€‚**
   **When the CPU executes an instruction, the address of that instruction is provided by __________.**
    A. ç¨‹åºè®¡æ•°å™¨ï¼ˆPCï¼‰ (Program Counter)
    B. æŒ‡ä»¤çš„åœ°å€ä»£ç å­—æ®µ (Address field of the instruction)
    C. æ“ä½œç³»ç»Ÿ (Operating System)
    D. ç¨‹åºå‘˜ (Programmer)

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): A**
> *   **è§£æ (Explanation)**: ç¨‹åºè®¡æ•°å™¨ (PC) å§‹ç»ˆå­˜æ”¾ä¸‹ä¸€æ¡è¦æ‰§è¡ŒæŒ‡ä»¤çš„åœ°å€ (PC always holds the address of the next instruction to be executed)ã€‚
</details>

7. **æ¯æ¡æœºå™¨æŒ‡ä»¤ï¼Œ______éƒ½æŒ‡å®šè¦æ‰§è¡Œçš„æ“ä½œï¼ˆä¾‹å¦‚ ADDã€I/Oï¼‰ã€‚**
   **For every machine instruction, ______ specifies the operation to be performed (e.g., ADD, I/O).**
    A. æ“ä½œä»£ç  (Opcode)
    B. æºæ“ä½œæ•°å‚è€ƒ (Source Operand Reference)
    C. ç»“æœæ“ä½œæ•°å‚è€ƒ (Result Operand Reference)
    D. ä¸‹ä¸€æ­¥è¯´æ˜å‚è€ƒ (Next Instruction Reference)

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): A**
> *   **è§£æ (Explanation)**: æ“ä½œç  (Opcode) å­—æ®µæŒ‡å®šæŒ‡ä»¤è¦æ‰§è¡Œçš„æ“ä½œ (Opcode field specifies the operation)ã€‚
</details>

8. **åœ¨æ ˆå¼è®¡ç®—æœºä¸­ï¼Œä¸€äº›é›¶åœ°å€æŒ‡ä»¤åœ¨æŒ‡ä»¤ä¸­ä¸æä¾›æ“ä½œæ•°åœ°å€ï¼Œä¸¤ä¸ªæ“ä½œæ•°æ¥è‡ª________ã€‚**
   **In a stack computer, some zero-address instructions do not provide operand addresses in the instruction; the two operands come from ________.**
    A. ç´¯åŠ å™¨å’Œå¯„å­˜å™¨ (Accumulator and Register)
    B. ç´¯åŠ å™¨å’Œä¸´æ—¶å¯„å­˜å™¨ (Accumulator and Temporary Register)
    C. å †æ ˆé¡¶éƒ¨å’Œæ¬¡é¡¶éƒ¨å•å…ƒ (Top of Stack and Second Top of Stack)
    D. å †æ ˆé¡¶éƒ¨å•å…ƒå’Œä¸€ä¸ªä¸´æ—¶å¯„å­˜å™¨ (Top of Stack and a Temporary Register)

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): C**
> *   **è§£æ (Explanation)**: æ ˆå¼è®¡ç®—æœºçš„é›¶åœ°å€æŒ‡ä»¤ï¼ˆå¦‚ ADDï¼‰é€šå¸¸éšå«æ“ä½œæ•°ä¸ºæ ˆé¡¶å…ƒç´ å’Œæ¬¡æ ˆé¡¶å…ƒç´ ï¼Œç»“æœå‹å›æ ˆé¡¶ (Zero-address instructions implicitly use the top two elements of the stack)ã€‚
</details>

9. **ä¸€ä¸ªè®¡ç®—æœºç³»ç»Ÿä½¿ç”¨ 32 ä½æŒ‡ä»¤å’Œ 12 ä½åœ°å€ç ã€‚å¦‚æœå®šä¹‰äº† 250 æ¡åŒåœ°å€æŒ‡ä»¤ï¼Œé‚£ä¹ˆå¯èƒ½çš„å•åœ°å€æŒ‡ä»¤çš„æ•°é‡ä¸º ()ã€‚**
   **A computer system uses 32-bit instructions and 12-bit address codes. If 250 two-address instructions are defined, the number of possible one-address instructions is ().**
    A. 2Â¹Â²
    B. 2Â¹Â³
    C. 2Â¹
    D. 3 Ã— 2Â¹Â³

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): D**
> *   **è§£æ (Explanation)**:
> *   æŒ‡ä»¤é•¿ 32 ä½ï¼Œåœ°å€ 12 ä½ (32-bit instruction, 12-bit address)ã€‚
> *   åŒåœ°å€æŒ‡ä»¤æ ¼å¼ (2-Addr Format): Op(8 bits) + Addr1(12 bits) + Addr2(12 bits)ã€‚
> *   Opcode 8ä½å…±æœ‰ 256 ç§çŠ¶æ€ã€‚å·²ä½¿ç”¨ 250 ç§ã€‚å‰©ä½™ 256 - 250 = 6 ç§å‰ç¼€ (6 prefixes remaining)ã€‚
> *   å•åœ°å€æŒ‡ä»¤åˆ©ç”¨ Addr2 çš„ç©ºé—´è¿›è¡Œæ‰©å±•ï¼Œå³å¤šäº† 12 ä½ (Expand into Addr2 space, +12 bits)ã€‚
> *   å¯ç”¨çš„å•åœ°å€æŒ‡ä»¤æ•° = å‰©ä½™å‰ç¼€æ•° Ã— 2Â¹Â² = 6 Ã— 2Â¹Â² = 3 Ã— 2 Ã— 2Â¹Â² = 3 Ã— 2Â¹Â³ã€‚
</details>

10. **åœ¨è®¾è®¡æŒ‡ä»¤ç³»ç»Ÿæ—¶ï¼Œå‡è®¾ä½¿ç”¨ 16 ä½å®šé•¿æŒ‡ä»¤å­—æ ¼å¼ï¼Œæ“ä½œç ä½¿ç”¨æ‰©å±•ç¼–ç æ–¹æ¡ˆã€‚åœ°å€ç ä¸º 6 ä½ï¼Œæœ‰ä¸‰ç§æŒ‡ä»¤æ ¼å¼ï¼šé›¶åœ°å€ã€ä¸€åœ°å€å’ŒäºŒåœ°å€ã€‚å¦‚æœæœ‰ 12 æ¡äºŒåœ°å€æŒ‡ä»¤å’Œ 254 æ¡ä¸€åœ°å€æŒ‡ä»¤ï¼Œé‚£ä¹ˆé›¶åœ°å€æŒ‡ä»¤çš„æœ€å¤§æ•°é‡æ˜¯ _________ã€‚**
    **When designing an instruction system, assume a 16-bit fixed-length instruction word format is used, with the opcode using an expanding encoding scheme. The address code is 6 bits, and there are three instruction formats: zero-address, one-address, and two-address. If there are 12 two-address instructions and 254 one-address instructions, then the maximum number of zero-address instructions is _________.**
    A. 0
    B. 2
    C. 64
    D. 128

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): D**
> *   **è§£æ (Explanation)**:
> *   16ä½æŒ‡ä»¤ï¼Œ6ä½åœ°å€ (16-bit instruction, 6-bit address)ã€‚
> *   åŒåœ°å€ (2-Addr): Op(4 bits) + A1(6) + A2(6)ã€‚Opcode 4ä½ (16-12=4)ã€‚å‰©ä½™ 16 - 12 = 4 ç§å‰ç¼€ (4 prefixes left)ã€‚
> *   å•åœ°å€ (1-Addr): Op(10 bits) + A1(6)ã€‚å¯ç”¨ 4 Ã— 2â¶ = 256 ç§ã€‚å·²ç”¨ 254 ç§ã€‚å‰©ä½™ 256 - 254 = 2 ç§å‰ç¼€ (2 prefixes left)ã€‚
> *   é›¶åœ°å€ (0-Addr): Op(16 bits)ã€‚å¯ç”¨ 2 Ã— 2â¶ = 128 ç§ã€‚
</details>

11. **ä¸€å°è®¡ç®—æœºä½¿ç”¨ 16 ä½å®šé•¿æŒ‡ä»¤å­—æ ¼å¼ã€‚æ“ä½œç å’Œå¯»å€æ–¹å¼çš„ä½æ•°æ˜¯å›ºå®šçš„ã€‚æŒ‡ä»¤é›†æœ‰ 48 æ¡æŒ‡ä»¤ï¼Œæ”¯æŒå››ç§å¯»å€æ–¹å¼ï¼šç›´æ¥ã€é—´æ¥ã€ç«‹å³å’Œç›¸å¯¹ã€‚åœ¨å•åœ°å€æŒ‡ä»¤ä¸­ï¼Œä½¿ç”¨ç›´æ¥å¯»å€çš„å¯å¯»å€èŒƒå›´æ˜¯ _________ã€‚**
    **A computer uses a 16-bit fixed-length instruction word format. The number of bits for the opcode and the addressing mode is fixed. The instruction set has 48 instructions and supports four addressing modes: direct, indirect, immediate, and relative. In a single-address instruction, the addressable range using direct addressing is _________.**
    A. 0â€“255
    B. 0â€“1023
    C. -128â€“127
    D. -512â€“511

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): A**
> *   **è§£æ (Explanation)**:
> *   16ä½æŒ‡ä»¤ (16-bit instruction)ã€‚
> *   48æ¡æŒ‡ä»¤éœ€ 6 ä½æ“ä½œç  (2âµ=32 < 48 < 2â¶=64) (6 bits for Opcode)ã€‚
> *   4ç§å¯»å€æ–¹å¼éœ€ 2 ä½ (2 bits for Mode)ã€‚
> *   å›ºå®šä½å®½ï¼Œæ•… Op+Mode å ç”¨ 6+2=8 ä½ (Op+Mode takes 8 bits)ã€‚
> *   å‰©ä½™åœ°å€ä½ = 16 - 8 = 8 ä½ (Remaining address bits = 8)ã€‚
> *   ç›´æ¥å¯»å€èŒƒå›´ 2â¸ = 256 (0~255)ã€‚
</details>

12. **åœ¨ä»¥ä¸‹å¯»å€æ–¹å¼ä¸­ï¼Œå“ªä¸€ç§æœ€é€‚åˆé€šè¿‡ä¸‹æ ‡é¡ºåºè®¿é—®æ•°ç»„å…ƒç´ ï¼Ÿ**
    **Among the following addressing modes, which one is most suitable for accessing elements of an array in sequential order by index?**
    A. ç›¸å¯¹å¯»å€ (Relative addressing)
    B. å¯„å­˜å™¨å¯»å€ (Register addressing)
    C. ç›´æ¥å¯»å€ (Direct addressing)
    D. å˜å€å¯»å€ (Indexed addressing)

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): D**
> *   **è§£æ (Explanation)**: å˜å€å¯»å€ (Indexed Addressing) ä¸“é—¨ç”¨äºæ•°ç»„è®¿é—®ï¼Œé€šè¿‡ åŸºå€+å˜å€(ä¸‹æ ‡) è®¡ç®—æœ‰æ•ˆåœ°å€ (Calculates effective address via Base + Index)ã€‚
</details>

13. **åœ¨æŒ‡ä»¤å¯»å€æ–¹å¼ä¸­ï¼Œè·å–æ“ä½œæ•°æœ€å¿«çš„æ–¹å¼æ˜¯__________ã€‚**
    **Among the instruction addressing modes, the fastest way to obtain an operand is __________.**
    A. ç›´æ¥å¯»å€ (Direct addressing)
    B. ç«‹å³å¯»å€ (Immediate addressing)
    C. å¯„å­˜å™¨å¯»å€ (Register addressing)
    D. é—´æ¥å¯»å€ (Indirect addressing)

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): B**
> *   **è§£æ (Explanation)**: ç«‹å³å¯»å€ (Immediate Addressing) çš„æ“ä½œæ•°ç›´æ¥åŒ…å«åœ¨æŒ‡ä»¤ä¸­ï¼Œæ— éœ€è®¿é—®å†…å­˜æˆ–å¯„å­˜å™¨ï¼Œé€Ÿåº¦æœ€å¿« (Operand is in the instruction, no memory/register access needed)ã€‚
</details>

14. **å‡è®¾æŒ‡ä»¤ä¸­çš„åœ°å€ç æä¾›äº†æ“ä½œæ•°çš„æœ‰æ•ˆåœ°å€ï¼Œé‚£ä¹ˆè¿™æ¡æŒ‡ä»¤ä½¿ç”¨çš„æ˜¯_________ã€‚**
    **Assuming the address code in the instruction provides the effective address of the operand, then this instruction uses _________.**
    A. ç›´æ¥å¯»å€ (Direct addressing)
    B. ç«‹å³å¯»å€ (Immediate addressing)
    C. å¯„å­˜å™¨å¯»å€ (Register addressing)
    D. é—´æ¥å¯»å€ (Indirect addressing)

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): A**
> *   **è§£æ (Explanation)**: ç›´æ¥å¯»å€ (Direct Addressing) çš„æŒ‡ä»¤åœ°å€ç å­—æ®µç›´æ¥ç»™å‡ºæ“ä½œæ•°çš„æœ‰æ•ˆåœ°å€ (Address field gives the effective address directly)ã€‚
</details>

15. **å‡è®¾å¯„å­˜å™¨ R ä¸­çš„å€¼ä¸º 200ã€‚å†…å­˜åœ°å€å•å…ƒ 200 å’Œ 300 çš„å†…å®¹åˆ†åˆ«ä¸º 300 å’Œ 400ã€‚åœ¨ä»€ä¹ˆå¯»å€æ–¹å¼ä¸‹ï¼Œè®¿é—®åˆ°çš„æ“ä½œæ•°ä¸º 200ï¼Ÿ**
    **Assume the value in register R is 200. The contents of memory address units 200 and 300 are 300 and 400, respectively. Under which addressing mode will the operand accessed be 200?**
    A. ç›´æ¥å¯»å€ (Direct addressing)
    B. å¯„å­˜å™¨é—´æ¥å¯»å€ (Register indirect addressing)
    C. å†…å­˜é—´æ¥å¯»å€ (Memory indirect addressing)
    D. å¯„å­˜å™¨å¯»å€ (Register addressing)

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): D**
> *   **è§£æ (Explanation)**:
> *   R = 200ã€‚
> *   ç›®æ ‡æ“ä½œæ•°æ˜¯ 200 (Target operand is 200)ã€‚
> *   å¯„å­˜å™¨å¯»å€ï¼šç›´æ¥å– R çš„å€¼ï¼Œå³ 200 (Register Addressing: takes value of R directly)ã€‚
</details>

16. **æŒ‡ä»¤æµæ°´çº¿å°†ä¸€æ¡æŒ‡ä»¤åˆ†ä¸ºä¸‰ä¸ªé˜¶æ®µï¼šå–æŒ‡ã€è¯‘ç å’Œæ‰§è¡Œï¼Œæ¯ä¸ªé˜¶æ®µçš„æ—¶é—´ä¸º Î”tã€‚å¦‚æœæ‰§è¡Œ 12 æ¡æŒ‡ä»¤ï¼Œæ‰€éœ€çš„æ€»æ—¶é—´æ˜¯__________ã€‚**
    **The instruction pipeline divides an instruction into three stages: fetch, decode, and execute, and the time for each stage is Î”t. If 12 instructions are executed, the total time required is __________.**
    A. 12Î”t
    B. 14Î”t
    C. 16Î”t
    D. 18Î”t

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): B**
> *   **è§£æ (Explanation)**: æµæ°´çº¿æ‰§è¡Œæ—¶é—´å…¬å¼ (Pipeline execution time formula): T = (k + n - 1)Î”tã€‚
> *   k=3 (çº§æ•°/stages), n=12 (æŒ‡ä»¤æ•°/instructions)ã€‚
> *   T = (3 + 12 - 1)Î”t = 14Î”tã€‚
</details>

17. **é—´æ¥å‘¨æœŸçš„ç›®çš„æ˜¯è·å– _________________ã€‚**
    **The aim of the indirect cycle is to get _________________.**
    A. ä¸€ä¸ªæ“ä½œæ•° (an operand)
    B. ä¸€æ¡æŒ‡ä»¤ (an instruction)
    C. æŒ‡ä»¤çš„åœ°å€ (an address of an instruction)
    D. æ“ä½œæ•°çš„åœ°å€ (the address of an operand)

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): D**
> *   **è§£æ (Explanation)**: é—´æ¥å‘¨æœŸ (Indirect Cycle) çš„ç›®çš„æ˜¯ä¸ºäº†è¯»å–å­˜å‚¨å™¨ä»¥è·å–æ“ä½œæ•°çš„æœ‰æ•ˆåœ°å€ï¼ˆå½“ä½¿ç”¨é—´æ¥å¯»å€æ—¶ï¼‰(To fetch the effective address of the operand from memory)ã€‚
</details>

18. **ä»¥ä¸‹å“ªé¡¹ä¸æ˜¯ RISC å¤„ç†å™¨çš„ç‰¹å¾ï¼Ÿ______ã€‚**
    **Which is NOT a characteristic of RISC processor? ______ã€‚**
    A. é—´æ¥å¯»å€æ¨¡å¼ (indirect addressing mode)
    B. å¯„å­˜å™¨åˆ°å¯„å­˜å™¨æ“ä½œ (register to register operations)
    C. å•ä¸€æŒ‡ä»¤å¤§å° (a single instruction size)
    D. ç®€å•çš„æŒ‡ä»¤æ ¼å¼ (simple instruction format)

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): A**
> *   **è§£æ (Explanation)**: RISC (ç²¾ç®€æŒ‡ä»¤é›†) çš„ç‰¹ç‚¹åŒ…æ‹¬æŒ‡ä»¤é•¿åº¦å›ºå®šã€æŒ‡ä»¤æ ¼å¼ç®€å•ã€å¤§é‡ä½¿ç”¨å¯„å­˜å™¨ã€‚å¤æ‚çš„å¯»å€æ–¹å¼ï¼ˆå¦‚é—´æ¥å¯»å€ï¼‰é€šå¸¸æ˜¯ CISC çš„ç‰¹å¾ (Complex addressing modes like indirect addressing are typical of CISC)ã€‚
</details>

19. **æ­£ç¡®çš„æŒ‡ä»¤å‘¨æœŸåºåˆ—æ˜¯ _________________ ã€‚**
    **The correct instruction cycle sequence is _________________ .**
    A. Fetch , Indirect , Execute and Interrupt
    B. Fetch , Execute , Indirect and Interrupt
    C. Fetch , Indirect , Interrupt and Execute
    D. Indirect , Fetch , Execute and Interrupt

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): A**
> *   **è§£æ (Explanation)**: æ ‡å‡†çš„æŒ‡ä»¤å‘¨æœŸæµç¨‹ï¼šå–æŒ‡ (Fetch) -> é—´æ¥å¯»å€ (Indirect, å¦‚æœéœ€è¦) -> æ‰§è¡Œ (Execute) -> ä¸­æ–­å¤„ç† (Interrupt, å¦‚æœæœ‰)ã€‚
</details>

20. **åœ¨_________æœ«å°¾ï¼ŒMBRçš„å†…å®¹æ˜¯æŒ‡ä»¤ã€‚**
    **At the end of the _________, the content of MBR is an instruction.**
    A. é—´æ¥å­å‘¨æœŸ (Indirect cycle)
    B. è·å–å­å‘¨æœŸ (Fetch cycle)
    C. æ‰§è¡Œå­å‘¨æœŸ (Execute cycle)
    D. ä¸­æ–­å­å‘¨æœŸ (Interrupt cycle)

    <details>
<summary><strong>ğŸ’¡ æŸ¥çœ‹ç­”æ¡ˆä¸è§£æ (View Answer & Explanation)</strong></summary>

> *   **ç­”æ¡ˆ (Answer): B**
> *   **è§£æ (Explanation)**: MBR (Memory Buffer Register) åœ¨å–æŒ‡å‘¨æœŸ (Fetch Cycle) ç»“æŸæ—¶ï¼Œå­˜æ”¾ä»å†…å­˜è¯»å‡ºçš„æŒ‡ä»¤å†…å®¹ï¼Œéšåä¼ é€ç»™æŒ‡ä»¤å¯„å­˜å™¨ (IR) (MBR holds the fetched instruction at the end of Fetch cycle)ã€‚
</details>
