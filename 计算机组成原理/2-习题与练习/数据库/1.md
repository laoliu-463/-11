# 数据库习题集

---

## 📋 模板速查区

### 关系代数 ↔ SQL 符号对照

| 关系代数 | SQL | 含义 |
|----------|-----|------|
| π (投影) | SELECT | 选列 |
| σ (选择) | WHERE | 选行 |
| ⋈ (连接) | JOIN ON | 连接表 |
| − (差集) | NOT IN | 排除 |
| ∪ (并集) | UNION | 合并 |
| Γ (分组) | GROUP BY | 分组聚合 |

### 模板A：单表条件查询
> 适用：题1, 8, 9, 10, 12

| 关系代数 | SQL |
|----------|-----|
| π列(σ条件(表)) | SELECT 列 FROM 表 WHERE 条件 |

### 模板B：多表连接查询
> 适用：题2, 13, 14, 15

| 关系代数 | SQL |
|----------|-----|
| π列(表1 ⋈ 表2 ⋈ σ条件(表3)) | SELECT 列 FROM 表1 JOIN 表2 ON 键=键 JOIN 表3 ON 键=键 WHERE 条件 |

### 模板C：否定查询（没有/不存在）
> 适用：题3, 11

| 关系代数 | SQL |
|----------|-----|
| π列(表) − π列(表⋈表) | SELECT 列 FROM 表 WHERE 键 NOT IN (SELECT 键 FROM 表) |

### 模板D：分组聚合
> 适用：题16, 17, 18

| 关系代数 | SQL |
|----------|-----|
| Γ分组列,COUNT/SUM(表) | SELECT 分组列, COUNT/SUM FROM 表 GROUP BY 分组列 |

### 模板E：分组+筛选
> 适用：题4, 19

| 关系代数 | SQL |
|----------|-----|
| π列(σ条件(Γ分组,COUNT(表))) | SELECT 列 FROM 表 GROUP BY 列 HAVING COUNT(*)>N |

### 模板F：DDL操作（详细版）

#### F1：创建表 + 主键 + 外键（题1）
```sql
CREATE TABLE 表名 (
    列1 CHAR(10),
    列2 CHAR(12),
    列3 INT,
    PRIMARY KEY (列1, 列2),              -- 可以是单列或复合主键
    FOREIGN KEY (列1) REFERENCES 父表(父表主键)
)
```
**关键点**：
- 复合主键：`PRIMARY KEY (列1, 列2, 列3)`
- 外键格式：`FOREIGN KEY (本表列) REFERENCES 父表(父表列)`

#### F2：创建视图（题5, 6）
```sql
-- 普通视图（题5）
CREATE VIEW 视图名 AS
SELECT 表1.列 AS 中文别名, 表2.列 AS 中文别名
FROM 表1
JOIN 表2 ON 表1.键 = 表2.键
JOIN 表3 ON 表2.键 = 表3.键

-- 带聚合的视图（题6）
CREATE VIEW 视图名 AS
SELECT 表.列 AS 别名, COUNT(DISTINCT 列) AS 数量别名
FROM 表1 JOIN 表2 ON 表1.键 = 表2.键
GROUP BY 表.列
```
**关键点**：
- `AS 别名`：给列起中文名
- 视图可包含JOIN、GROUP BY、聚合函数

#### F3：创建索引（题7）
```sql
CREATE UNIQUE INDEX 索引名 ON 表名(列名 ASC)
```
**关键点**：
- `UNIQUE`：索引值不允许重复
- `ASC/DESC`：升序/降序

---

### 模板G：DML操作（详细版）

#### G1：插入数据（题2）
```sql
INSERT INTO 表名 VALUES ('值1', '值2', 100)
```
**关键点**：
- 字符串用**单引号**
- 按表列顺序填值

#### G2：更新数据（题3）
```sql
UPDATE 表名 SET 列 = 列 + 5 WHERE 条件列 = '值'
```
**关键点**：
- `SET 列 = 表达式`：可以用计算表达式
- 必须写`WHERE`，否则更新全部！

#### G3：删除数据（题4）
```sql
DELETE FROM 表名 WHERE 条件列 = '值'
```
**关键点**：
- 必须写`WHERE`，否则删除全部！

---

### 模板G2：排序查询（题13）

```sql
SELECT 列1, 列2
FROM 表1
JOIN 表2 ON 表1.键 = 表2.键
WHERE 条件
ORDER BY 列 DESC  -- DESC降序，ASC升序（默认）
```

---

### 模板G3：模糊查询（题10）

```sql
SELECT 列 FROM 表 WHERE 列 LIKE '模式'
```
**通配符**：
- `%`：匹配任意多个字符（包括0个）
- `_`：匹配恰好1个字符

**示例**：
- `LIKE 'J210_%'`：以J210_开头，后面至少1个字符
- `LIKE '%红%'`：包含"红"字
- `LIKE 'S_'`：S开头，后面恰好1个字符

---

### 模板G4：嵌套子查询（题14, 15）

#### 单层嵌套（题14）
```sql
SELECT 列 FROM 表1
WHERE 键 IN (SELECT 键 FROM 表2 WHERE 条件)
```

#### 多层嵌套（题15）
```sql
SELECT 列 FROM 表1
WHERE 键 IN (
    SELECT 键 FROM 表2
    WHERE 键 IN (SELECT 键 FROM 表3 WHERE 条件)
)
```
**执行顺序**：从最内层开始，逐层向外

### 模板H：存储过程（详细版）

#### H1：基础存储过程（题20）
```sql
CREATE PROCEDURE 过程名 @参数名 参数类型
AS
BEGIN
    SELECT * FROM 表名 WHERE 列 = @参数名
END

-- 调用方式
EXEC 过程名 '参数值'
```

**关键点**：
- `@参数名`：输入参数，以@开头
- `AS BEGIN ... END`：过程体
- `EXEC`：调用存储过程

#### H2：带输出参数的存储过程（题21）
```sql
CREATE PROCEDURE 过程名 @输入参数 类型, @输出参数 类型 OUTPUT
AS
BEGIN
    SELECT @输出参数 = COUNT(DISTINCT 列) 
    FROM 表 
    WHERE 条件列 = @输入参数
END

-- 调用方式（三步走）
DECLARE @结果变量 类型           -- 第1步：声明变量
EXEC 过程名 '输入值', @结果变量 OUTPUT  -- 第2步：调用（必须加OUTPUT）
SELECT @结果变量                 -- 第3步：查看结果
```

**关键点**：
- `OUTPUT`关键字：声明和调用时都要写
- `SELECT @变量 = 聚合函数`：给变量赋值
- 调用时先`DECLARE`再`EXEC`再`SELECT`

#### H3：带条件判断的存储过程（题22）
```sql
CREATE PROCEDURE 过程名 @参数 类型
AS
BEGIN
    -- 1.声明局部变量
    DECLARE @变量 类型
    
    -- 2.计算并赋值（可能涉及JOIN）
    SELECT @变量 = SUM(数值列) 
    FROM 表1 JOIN 表2 ON 表1.键 = 表2.键 
    WHERE 表1.列 = @参数
    
    -- 3.处理NULL
    IF @变量 IS NULL SET @变量 = 0
    
    -- 4.条件判断输出
    IF @变量 < 阈值
        PRINT '消息A'
    ELSE
        PRINT '消息B：' + CAST(@变量 AS VARCHAR(10))
END

-- 调用方式
EXEC 过程名 '参数值'
```

**关键点**：
- `DECLARE @变量 类型`：声明局部变量
- `IF ... IS NULL`：判断空值
- `CAST(数值 AS VARCHAR)`：数值转字符串（PRINT只能输出字符串）
- 字符串拼接用 `+`

---

### 模板I：触发器（详细版）

#### 核心概念：inserted 和 deleted 表

| 操作 | inserted表 | deleted表 |
|------|------------|-----------|
| INSERT | 新插入的行 | 空 |
| DELETE | 空 | 被删除的行 |
| UPDATE | 更新后的行 | 更新前的行 |

#### I1：INSERT触发器-统计行数（题23）
```sql
CREATE TRIGGER 触发器名 ON 表名
AFTER INSERT
AS
BEGIN
    DECLARE @cnt INT
    SELECT @cnt = COUNT(*) FROM inserted  -- inserted存放新插入的行
    PRINT '已插入 ' + CAST(@cnt AS VARCHAR(10)) + ' 行'
END

-- 触发方式：对表执行INSERT时自动触发
INSERT INTO 表名 VALUES (...)
```

**关键点**：
- `AFTER INSERT`：插入完成后触发
- `inserted`：临时表，自动存放刚插入的所有行

#### I2：约束触发器-拒绝非法操作（题24）
```sql
CREATE TRIGGER 触发器名 ON 表名
AFTER INSERT
AS
BEGIN
    -- 检查inserted表中是否有违规数据
    IF EXISTS (SELECT 1 FROM inserted WHERE 违规条件)
    BEGIN
        PRINT '操作失败：错误原因'
        ROLLBACK  -- 撤销本次INSERT
    END
END

-- 触发测试
INSERT INTO 表名 VALUES (违规数据)  -- 会被拒绝
```

**关键点**：
- `IF EXISTS (SELECT 1 FROM ...)`：判断是否存在满足条件的记录
- `ROLLBACK`：撤销当前事务，使INSERT失效
- `BEGIN...END`：多条语句必须用块包裹

#### I3：业务规则触发器-复杂约束（题25）
```sql
CREATE TRIGGER 触发器名 ON 表名
AFTER INSERT, UPDATE  -- 对INSERT和UPDATE都触发
AS
BEGIN
    -- 检查业务规则（可能涉及聚合查询）
    IF EXISTS (
        SELECT 分组列 
        FROM 表名 
        GROUP BY 分组列 
        HAVING SUM(数量列) > 阈值
    )
    BEGIN
        PRINT '操作失败：超过业务限制'
        ROLLBACK
    END
END

-- 触发测试
INSERT INTO 表名 VALUES (...)   -- 如果导致超限会被拒绝
UPDATE 表名 SET 列=值 WHERE ... -- 如果导致超限会被拒绝
```

**关键点**：
- `AFTER INSERT, UPDATE`：对多种操作都触发
- 触发器内可以使用`GROUP BY`、`HAVING`等复杂查询
- 检查的是**操作后**整张表的状态

### 模板J：范式分析（应用题1）

```
1. 函数依赖：根据语义写 X → Y
2. 候选键：找只在左边的属性
3. 判断范式：有部分依赖→1NF；有传递依赖→2NF；都没有→3NF
4. 分解：每个FD对应一个关系模式
```

### 模板K：E-R图转换（应用题2）

```
1:N联系 → 合并到N端（加外键+联系属性）
M:N联系 → 独立建表（双外键做联合主键）
外键 → 引用父表主键
```

---

## SPJ 数据库结构

> 以下第二、三大题均基于此数据库

### S（设备供应商）
| 字段名 | SNO | SNAME | STATUS | CITY |
|--------|-----|-------|--------|------|
| 数据类型 | char(10) | char(12) | char(2) | char(8) |
| 描述 | 供应商编号 | 供应商名称 | 供应状态 | 所在城市 |

### P（零件）
| 字段名 | PNO | PNAME | COLOR | WEIGHT |
|--------|-----|-------|-------|--------|
| 数据类型 | char(10) | char(12) | char(5) | Integer |
| 描述 | 零件编号 | 零件名称 | 零件颜色 | 零件重量 |

### J（工程项目）
| 字段名 | JNO | JNAME | CITY |
|--------|-----|-------|------|
| 数据类型 | char(10) | char(10) | char(8) |
| 描述 | 工程编号 | 工程名 | 所在城市 |

### SPJ（供应情况）
| 字段名 | SNO | PNO | JNO | QTY |
|--------|-----|-----|-----|-----|
| 数据类型 | char(10) | char(10) | char(10) | Integer |
| 描述 | 供应商编号 | 零件编号 | 工程编号 | 供应数量 |

---

## 一、关系代数运算

设有三个关系如下图所示：

**R**
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 5 | 6 | 7 |
| 7 | 8 | 9 |

**S**
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |
| 3 | 4 | 5 |
| 7 | 8 | 9 |

**T**
| B | C | D |
|---|---|---|
| 1 | 2 | 4 |
| 5 | 6 | 7 |
| 5 | 6 | 8 |
| 7 | 8 | 9 |

计算：R∪S、R∩S、R−S、R×T、R⋈T、πA(R)、σB>3(R)

**答案**：

**R∪S（并集）**
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 5 | 6 | 7 |
| 7 | 8 | 9 |
| 3 | 4 | 5 |

**R∩S（交集）**
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |
| 7 | 8 | 9 |

**R−S（差集）**
| A | B | C |
|---|---|---|
| 4 | 5 | 6 |
| 5 | 6 | 7 |

**πA(R)（投影A列）**
| A |
|---|
| 1 |
| 4 |
| 5 |
| 7 |

**σB>3(R)（选择B>3的行）**
| A | B | C |
|---|---|---|
| 4 | 5 | 6 |
| 5 | 6 | 7 |
| 7 | 8 | 9 |

**R×T（笛卡尔积）**：R的4行 × T的4行 = 16行，每行7列(A,B,C,B',C',D)

**R⋈T（自然连接，按B,C）**
| A | B | C | D |
|---|---|---|---|
| 5 | 6 | 7 | 7 |
| 5 | 6 | 7 | 8 |
| 7 | 8 | 9 | 9 |

---

## 二、关系代数表达式查询

1. 检索颜色为红色且重量超过50克的零件的零件名
2. 检索项目"三建"使用的零件编号和零件名
3. 查询没给任何工程项目供应零件的供应商名
4. 查询至少使用两种以上零件的工程项目号

**答案**（关系代数表达式）：

1. π<sub>PNAME</sub>(σ<sub>COLOR='红' ∧ WEIGHT>50</sub>(P))

2. π<sub>PNO,PNAME</sub>(P ⋈ (π<sub>PNO</sub>(SPJ ⋈ σ<sub>JNAME='三建'</sub>(J))))

3. π<sub>SNAME</sub>(S) − π<sub>SNAME</sub>(S ⋈ SPJ)

4. π<sub>JNO</sub>(σ<sub>cnt≥2</sub>(γ<sub>JNO, COUNT(PNO)→cnt</sub>(SPJ)))

---

## 三、T-SQL 操作

### 表操作
1. 创建SPJ表，设置供应商编号、零件编号和工程编号一起做主键，且各自分别为外键参照供应商表、零件表和工程项目表的对应编号
```sql
CREATE TABLE SPJ (
    SNO CHAR(10),
    PNO CHAR(10),
    JNO CHAR(10),
    QTY INT,
    PRIMARY KEY (SNO, PNO, JNO),
    FOREIGN KEY (SNO) REFERENCES S(SNO),
    FOREIGN KEY (PNO) REFERENCES P(PNO),
    FOREIGN KEY (JNO) REFERENCES J(JNO)
)
```
2. 向spj表插入一条新纪录，供应商为：s8 零件号为：p8 工程号为：j8 数量为100
```sql
INSERT INTO SPJ VALUES ('s8', 'p8', 'j8', 100)
```
3. 将所有红色零件的重量加5克
```sql
UPDATE P SET WEIGHT = WEIGHT + 5 WHERE COLOR = '红'
```
4. 删除所有上海的工程项目信息
```sql
DELETE FROM J WHERE CITY = '上海'
```

### 视图与索引
5. 建立一个供应情况的视图v_spj，视图中包括供应商名、项目名，零件名和供应数量，给每一列都起一个中文名字
```sql
CREATE VIEW v_spj AS
SELECT S.SNAME AS 供应商名, J.JNAME AS 项目名, P.PNAME AS 零件名, SPJ.QTY AS 供应数量
FROM SPJ
JOIN S ON SPJ.SNO = S.SNO
JOIN P ON SPJ.PNO = P.PNO
JOIN J ON SPJ.JNO = J.JNO
```
6. 建立一个视图v_ssum，在视图中统计每个项目的供应商数量，给出项目名和供应商数量
```sql
CREATE VIEW v_ssum AS
SELECT J.JNAME AS 项目名, COUNT(DISTINCT SPJ.SNO) AS 供应商数量
FROM J JOIN SPJ ON J.JNO = SPJ.JNO
GROUP BY J.JNAME
```
7. 为供应商表建立唯一索引，要求按照供应商名升序索引
```sql
CREATE UNIQUE INDEX idx_sname ON S(SNAME ASC)
```

### 基础查询
8. 查询所有供应商的姓名和所在城市
```sql
SELECT SNAME, CITY FROM S
```
9. 查询重量大于50g的所有红色零件的名称
```sql
SELECT PNAME FROM P WHERE COLOR = '红' AND WEIGHT > 50
```
10. 查询工程编号以"J210_"开头的所有工程的工程号和所在城市
```sql
SELECT JNO, CITY FROM J WHERE JNO LIKE 'J210_%'
```
11. 查询没给任何工程供应零件的设备供应商号
```sql
-- 方法1：NOT IN
SELECT SNO FROM S WHERE SNO NOT IN (SELECT SNO FROM SPJ)
-- 方法2：NOT EXISTS
SELECT SNO FROM S WHERE NOT EXISTS (SELECT 1 FROM SPJ WHERE SPJ.SNO = S.SNO)
```
12. 查询使用供应商S1（供应商号）所供应零件的工程号码
```sql
SELECT JNO FROM SPJ WHERE SNO = 'S1'
```
13. 查询工程J2（工程编号）使用的各种零件的名称及其数量，并按数量降序排序
```sql
SELECT PNAME, QTY FROM P JOIN SPJ ON P.PNO = SPJ.PNO WHERE JNO = 'J2' ORDER BY QTY DESC
```
14. 查询上海厂商供应的所有零件编号（要求使用子查询完成）
```sql
SELECT PNO FROM SPJ WHERE SNO IN (SELECT SNO FROM S WHERE CITY = '上海')
```
15. 查询使用上海产的零件的工程名称
```sql
SELECT JNAME FROM J 
WHERE JNO IN (
    SELECT JNO FROM SPJ 
    WHERE SNO IN (SELECT SNO FROM S WHERE CITY = '上海')
)
```

### 聚合与分组
16. 查询上海供应商的数量
```sql
SELECT COUNT(*) FROM S WHERE CITY = '上海'
```
17. 查询每个城市的工程数量，给出城市名和数量
```sql
SELECT CITY, COUNT(*) FROM J GROUP BY CITY
```
18. 查询每项工程使用的零件总数，给出工程名和零件的总数
```sql
SELECT JNAME, SUM(QTY) FROM J JOIN SPJ ON J.JNO = SPJ.JNO GROUP BY JNAME
```
19. 查询使用3种以上零件的工程号
```sql
SELECT JNO FROM SPJ GROUP BY JNO HAVING COUNT(DISTINCT PNO) > 3
```

### 存储过程
20. 编写一个存储过程p_scity，给定一个城市，返回该城市所有供应商信息；调用该存储过程
```sql
CREATE PROCEDURE p_scity @city CHAR(8)
AS
BEGIN
    SELECT * FROM S WHERE CITY = @city
END
-- 调用
EXEC p_scity '上海'
```
21. 编写一个存储过程p_jsum，给定一个供应商编号，查询由他供应零件的项目数量，将其以参数形式返回；调用该存储过程
```sql
CREATE PROCEDURE p_jsum @sno CHAR(10), @cnt INT OUTPUT
AS
BEGIN
    SELECT @cnt = COUNT(DISTINCT JNO) FROM SPJ WHERE SNO = @sno
END
-- 调用
DECLARE @result INT
EXEC p_jsum 'S1', @result OUTPUT
SELECT @result
```
22. 编写一个存储过程p_pqty，给定一个零件名，查询该种零件的总供应量，若该数量低于50则提示用户该种零件属于滞销零件，否则提示用户该零件的总数；调用该存储过程
```sql
CREATE PROCEDURE p_pqty @pname CHAR(12)
AS
BEGIN
    DECLARE @total INT
    SELECT @total = SUM(QTY) FROM P JOIN SPJ ON P.PNO = SPJ.PNO WHERE P.PNAME = @pname
    IF @total IS NULL SET @total = 0
    IF @total < 50
        PRINT '该种零件属于滞销零件'
    ELSE
        PRINT '该零件的总供应量为: ' + CAST(@total AS VARCHAR(10))
END
-- 调用
EXEC p_pqty '螺母'
```

### 触发器
23. 创建供应商表S上的触发器tr_ins_s，当对S表进行插入时触发，提示用户已经插入表中的行数
```sql
CREATE TRIGGER tr_ins_s ON S
AFTER INSERT
AS
BEGIN
    DECLARE @cnt INT
    SELECT @cnt = COUNT(*) FROM inserted  -- inserted是临时表，存放刚插入的行
    PRINT '已插入 ' + CAST(@cnt AS VARCHAR(10)) + ' 行'
END

-- 触发该触发器
INSERT INTO S VALUES ('S8', '新供应商', '10', '深圳')
-- 预期输出：已插入 1 行
```
24. 创建零件表p上的触发器tr_ins_p，当向表S中插入新行时，如果是红色零件且重量超过50克，则撤销该插入操作并提示用户操作失败；触发该触发器
```sql
CREATE TRIGGER tr_ins_p ON P
AFTER INSERT
AS
BEGIN
    IF EXISTS (SELECT 1 FROM inserted WHERE COLOR = '红' AND WEIGHT > 50)
    BEGIN
        PRINT '操作失败：不能插入红色且重量超过50克的零件'
        ROLLBACK
    END
END

-- 触发该触发器（非法插入，会被拒绝）
INSERT INTO P VALUES ('P9', '非法零件', '红', 60)
-- 预期输出：操作失败：不能插入红色且重量超过50克的零件
-- INSERT被ROLLBACK撤销
```
25. 创建一个触发器tr_spj，当插入或更新spj表时触发，判断若该项目使用的零件总数超过500个，则拒绝此次插入或更新。触发该触发器
```sql
CREATE TRIGGER tr_spj ON SPJ
AFTER INSERT, UPDATE
AS
BEGIN
    IF EXISTS (
        SELECT JNO FROM SPJ 
        GROUP BY JNO 
        HAVING SUM(QTY) > 500
    )
    BEGIN
        PRINT '操作失败：该项目零件总数超过500个'
        ROLLBACK
    END
END

-- 触发该触发器（INSERT方式）
INSERT INTO SPJ VALUES ('S1', 'P1', 'J1', 600)
-- 预期输出：操作失败：该项目零件总数超过500个

-- 触发该触发器（UPDATE方式）
UPDATE SPJ SET QTY = 600 WHERE JNO = 'J1' AND SNO = 'S1'
-- 预期输出：操作失败：该项目零件总数超过500个
```

---

## 四、应用题

### 题1：范式分析

设有关系模式 R（EmpNo，TDate，DAmount，Dept，Manager）

属性含义：
- EmpNo - 职工编号
- TDate - 日期
- DAmount - 日营业额
- Dept - 部门名
- Manager - 部门经理

约束条件：
- 每个职工每天只有一个营业额
- 每个职工只在一个部门工作
- 每个部门只有一个经理

**问题：**
1. 根据上述规定，写出关系模式R的基本函数依赖
2. 找出关系模式R的候选键
3. 判断关系模式R最高达到第几范式，说明理由
4. 若关系模式R不属于3NF，将其分解成3NF模式集（只需要分解的结果）

**答案：**

**1. 基本函数依赖：**
- (EmpNo, TDate) → DAmount （每个职工每天只有一个营业额）
- EmpNo → Dept （每个职工只在一个部门工作）
- Dept → Manager （每个部门只有一个经理）

**2. 候选键：**
- 候选键为 **(EmpNo, TDate)**
- 分析：EmpNo和TDate不在任何函数依赖的右边出现，必须包含在候选键中；(EmpNo, TDate)可推导出所有属性，故为候选键

**3. 最高达到第几范式：**
- R最高达到 **1NF**
- 理由：存在非主属性对候选键的部分函数依赖
  - EmpNo → Dept，而EmpNo是候选键(EmpNo, TDate)的一部分
  - 违反了2NF的定义（非主属性必须完全函数依赖于候选键）

**4. 分解成3NF模式集：**
- R1(**EmpNo**, TDate, DAmount) — 职工日营业额
- R2(**EmpNo**, Dept) — 职工部门
- R3(**Dept**, Manager) — 部门经理

---

### 题2：E-R图设计

设某商业集团数据库中有四个实体集：

**实体集：**
- 商店（商店编号、商店名、地址）
- 商品（商品编码、商品名、规格、单价）
- 职工（职工编号、姓名、性别、业绩）
- 类别（类别编号、类别名称）

**联系：**
- 商店与商品：销售（M:N），属性：销售量
- 商店与职工：聘用（1:N），属性：聘期、月薪
- 类别与商品：包含（1:N）

**问题：**
1. 试画出E-R图，并在图上注明属性、联系的类型
2. 再转换成关系模式集，要求关系模式尽可能少
3. 指出每个关系模式的主键和外键

**答案：**

**1. E-R图（文字描述）：**

```
┌─────────┐          ┌─────────┐
│  商店   │──M:N────│  商品   │
│ (矩形)  │  销售   │ (矩形)  │
└────┬────┘ (菱形)  └────┬────┘
     │     销售量        │
     │                   │
    1:N               1:N
   聘用                包含
  (菱形)              (菱形)
 聘期,月薪              │
     │                   │
     N                   N
┌─────────┐          ┌─────────┐
│  职工   │          │  类别   │
│ (矩形)  │          │ (矩形)  │
└─────────┘          └─────────┘
```

各实体属性（椭圆形）：
- 商店：**商店编号**（下划线表示主键）、商店名、地址
- 商品：**商品编码**、商品名、规格、单价
- 职工：**职工编号**、姓名、性别、业绩
- 类别：**类别编号**、类别名称

**2. 转换成关系模式集（尽可能少）：**

- **商店**（商店编号, 商店名, 地址）
- **商品**（商品编码, 商品名, 规格, 单价, 类别编号）— 1:N联系"包含"合并到N端
- **职工**（职工编号, 姓名, 性别, 业绩, 商店编号, 聘期, 月薪）— 1:N联系"聘用"合并到N端
- **类别**（类别编号, 类别名称）
- **销售**（商店编号, 商品编码, 销售量）— M:N联系需独立建表

**3. 主键和外键：**

| 关系模式 | 主键 | 外键 |
|----------|------|------|
| 商店 | 商店编号 | 无 |
| 商品 | 商品编码 | 类别编号 → 类别(类别编号) |
| 职工 | 职工编号 | 商店编号 → 商店(商店编号) |
| 类别 | 类别编号 | 无 |
| 销售 | (商店编号, 商品编码) | 商店编号 → 商店(商店编号), 商品编码 → 商品(商品编码) |

---

## 统计

| 大题 | 题数 |
|------|------|
| 一、关系代数运算 | 7个运算 |
| 二、关系代数表达式 | 4题 |
| 三、T-SQL操作 | 25题 |
| 四、应用题 | 2题 |
