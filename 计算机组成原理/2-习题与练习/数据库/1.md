# 数据库习题集

## SPJ 数据库结构

> 以下第二、三大题均基于此数据库

### S（设备供应商）
| 字段名 | SNO | SNAME | STATUS | CITY |
|--------|-----|-------|--------|------|
| 数据类型 | char(10) | char(12) | char(2) | char(8) |
| 描述 | 供应商编号 | 供应商名称 | 供应状态 | 所在城市 |

### P（零件）
| 字段名 | PNO | PNAME | COLOR | WEIGHT |
|--------|-----|-------|-------|--------|
| 数据类型 | char(10) | char(12) | char(5) | Integer |
| 描述 | 零件编号 | 零件名称 | 零件颜色 | 零件重量 |

### J（工程项目）
| 字段名 | JNO | JNAME | CITY |
|--------|-----|-------|------|
| 数据类型 | char(10) | char(10) | char(8) |
| 描述 | 工程编号 | 工程名 | 所在城市 |

### SPJ（供应情况）
| 字段名 | SNO | PNO | JNO | QTY |
|--------|-----|-----|-----|-----|
| 数据类型 | char(10) | char(10) | char(10) | Integer |
| 描述 | 供应商编号 | 零件编号 | 工程编号 | 供应数量 |

---

## 一、关系代数运算

设有三个关系如下图所示：

**R**
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 5 | 6 | 7 |
| 7 | 8 | 9 |

**S**
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |
| 3 | 4 | 5 |
| 7 | 8 | 9 |

**T**
| B | C | D |
|---|---|---|
| 1 | 2 | 4 |
| 5 | 6 | 7 |
| 5 | 6 | 8 |
| 7 | 8 | 9 |

计算：R∪S、R∩S、R−S、R×T、R⋈T、πA(R)、σB>3(R)

**答案**：

**R∪S（并集）**
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |
| 4 | 5 | 6 |
| 5 | 6 | 7 |
| 7 | 8 | 9 |
| 3 | 4 | 5 |

**R∩S（交集）**
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |
| 7 | 8 | 9 |

**R−S（差集）**
| A | B | C |
|---|---|---|
| 4 | 5 | 6 |
| 5 | 6 | 7 |

**πA(R)（投影A列）**
| A |
|---|
| 1 |
| 4 |
| 5 |
| 7 |

**σB>3(R)（选择B>3的行）**
| A | B | C |
|---|---|---|
| 4 | 5 | 6 |
| 5 | 6 | 7 |
| 7 | 8 | 9 |

**R×T（笛卡尔积）**：R的4行 × T的4行 = 16行，每行7列(A,B,C,B',C',D)

**R⋈T（自然连接，按B,C）**
| A | B | C | D |
|---|---|---|---|
| 5 | 6 | 7 | 7 |
| 5 | 6 | 7 | 8 |
| 7 | 8 | 9 | 9 |

---

## 二、关系代数表达式查询

1. 检索颜色为红色且重量超过50克的零件的零件名
2. 检索项目"三建"使用的零件编号和零件名
3. 查询没给任何工程项目供应零件的供应商名
4. 查询至少使用两种以上零件的工程项目号

**答案**（关系代数表达式）：

1. π<sub>PNAME</sub>(σ<sub>COLOR='红' ∧ WEIGHT>50</sub>(P))

2. π<sub>PNO,PNAME</sub>(P ⋈ (π<sub>PNO</sub>(SPJ ⋈ σ<sub>JNAME='三建'</sub>(J))))

3. π<sub>SNAME</sub>(S) − π<sub>SNAME</sub>(S ⋈ SPJ)

4. π<sub>JNO</sub>(σ<sub>cnt≥2</sub>(γ<sub>JNO, COUNT(PNO)→cnt</sub>(SPJ)))

---

## 三、T-SQL 操作

### 表操作
1. 创建SPJ表，设置供应商编号、零件编号和工程编号一起做主键，且各自分别为外键参照供应商表、零件表和工程项目表的对应编号
```sql
CREATE TABLE SPJ (
    SNO CHAR(10),
    PNO CHAR(10),
    JNO CHAR(10),
    QTY INT,
    PRIMARY KEY (SNO, PNO, JNO),
    FOREIGN KEY (SNO) REFERENCES S(SNO),
    FOREIGN KEY (PNO) REFERENCES P(PNO),
    FOREIGN KEY (JNO) REFERENCES J(JNO)
)
```
2. 向spj表插入一条新纪录，供应商为：s8 零件号为：p8 工程号为：j8 数量为100
```sql
INSERT INTO SPJ VALUES ('s8', 'p8', 'j8', 100)
```
3. 将所有红色零件的重量加5克
```sql
UPDATE P SET WEIGHT = WEIGHT + 5 WHERE COLOR = '红'
```
4. 删除所有上海的工程项目信息
```sql
DELETE FROM J WHERE CITY = '上海'
```

### 视图与索引
5. 建立一个供应情况的视图v_spj，视图中包括供应商名、项目名，零件名和供应数量，给每一列都起一个中文名字
```sql
CREATE VIEW v_spj AS
SELECT S.SNAME AS 供应商名, J.JNAME AS 项目名, P.PNAME AS 零件名, SPJ.QTY AS 供应数量
FROM SPJ
JOIN S ON SPJ.SNO = S.SNO
JOIN P ON SPJ.PNO = P.PNO
JOIN J ON SPJ.JNO = J.JNO
```
6. 建立一个视图v_ssum，在视图中统计每个项目的供应商数量，给出项目名和供应商数量
```sql
CREATE VIEW v_ssum AS
SELECT J.JNAME AS 项目名, COUNT(DISTINCT SPJ.SNO) AS 供应商数量
FROM J JOIN SPJ ON J.JNO = SPJ.JNO
GROUP BY J.JNAME
```
7. 为供应商表建立唯一索引，要求按照供应商名升序索引
```sql
CREATE UNIQUE INDEX idx_sname ON S(SNAME ASC)
```

### 基础查询
8. 查询所有供应商的姓名和所在城市
```sql
SELECT SNAME, CITY FROM S
```
9. 查询重量大于50g的所有红色零件的名称
```sql
SELECT PNAME FROM P WHERE COLOR = '红' AND WEIGHT > 50
```
10. 查询工程编号以"J210_"开头的所有工程的工程号和所在城市
```sql
SELECT JNO, CITY FROM J WHERE JNO LIKE 'J210_%'
```
11. 查询没给任何工程供应零件的设备供应商号
```sql
-- 方法1：NOT IN
SELECT SNO FROM S WHERE SNO NOT IN (SELECT SNO FROM SPJ)
-- 方法2：NOT EXISTS
SELECT SNO FROM S WHERE NOT EXISTS (SELECT 1 FROM SPJ WHERE SPJ.SNO = S.SNO)
```
12. 查询使用供应商S1（供应商号）所供应零件的工程号码
```sql
SELECT JNO FROM SPJ WHERE SNO = 'S1'
```
13. 查询工程J2（工程编号）使用的各种零件的名称及其数量，并按数量降序排序
```sql
SELECT PNAME, QTY FROM P JOIN SPJ ON P.PNO = SPJ.PNO WHERE JNO = 'J2' ORDER BY QTY DESC
```
14. 查询上海厂商供应的所有零件编号（要求使用子查询完成）
```sql
SELECT PNO FROM SPJ WHERE SNO IN (SELECT SNO FROM S WHERE CITY = '上海')
```
15. 查询使用上海产的零件的工程名称
```sql
SELECT JNAME FROM J 
WHERE JNO IN (
    SELECT JNO FROM SPJ 
    WHERE SNO IN (SELECT SNO FROM S WHERE CITY = '上海')
)
```

### 聚合与分组
16. 查询上海供应商的数量
```sql
SELECT COUNT(*) FROM S WHERE CITY = '上海'
```
17. 查询每个城市的工程数量，给出城市名和数量
```sql
SELECT CITY, COUNT(*) FROM J GROUP BY CITY
```
18. 查询每项工程使用的零件总数，给出工程名和零件的总数
```sql
SELECT JNAME, SUM(QTY) FROM J JOIN SPJ ON J.JNO = SPJ.JNO GROUP BY JNAME
```
19. 查询使用3种以上零件的工程号
```sql
SELECT JNO FROM SPJ GROUP BY JNO HAVING COUNT(DISTINCT PNO) > 3
```

### 存储过程
20. 编写一个存储过程p_scity，给定一个城市，返回该城市所有供应商信息；调用该存储过程
```sql
CREATE PROCEDURE p_scity @city CHAR(8)
AS
BEGIN
    SELECT * FROM S WHERE CITY = @city
END
-- 调用
EXEC p_scity '上海'
```
21. 编写一个存储过程p_jsum，给定一个供应商编号，查询由他供应零件的项目数量，将其以参数形式返回；调用该存储过程
```sql
CREATE PROCEDURE p_jsum @sno CHAR(10), @cnt INT OUTPUT
AS
BEGIN
    SELECT @cnt = COUNT(DISTINCT JNO) FROM SPJ WHERE SNO = @sno
END
-- 调用
DECLARE @result INT
EXEC p_jsum 'S1', @result OUTPUT
SELECT @result
```
22. 编写一个存储过程p_pqty，给定一个零件名，查询该种零件的总供应量，若该数量低于50则提示用户该种零件属于滞销零件，否则提示用户该零件的总数；调用该存储过程
```sql
CREATE PROCEDURE p_pqty @pname CHAR(12)
AS
BEGIN
    DECLARE @total INT
    SELECT @total = SUM(QTY) FROM P JOIN SPJ ON P.PNO = SPJ.PNO WHERE P.PNAME = @pname
    IF @total IS NULL SET @total = 0
    IF @total < 50
        PRINT '该种零件属于滞销零件'
    ELSE
        PRINT '该零件的总供应量为: ' + CAST(@total AS VARCHAR(10))
END
-- 调用
EXEC p_pqty '螺母'
```

### 触发器
23. 创建供应商表S上的触发器tr_ins_s，当对S表进行插入时触发，提示用户已经插入表中的行数
```sql
CREATE TRIGGER tr_ins_s ON S
AFTER INSERT
AS
BEGIN
    DECLARE @cnt INT
    SELECT @cnt = COUNT(*) FROM inserted  -- inserted是临时表，存放刚插入的行
    PRINT '已插入 ' + CAST(@cnt AS VARCHAR(10)) + ' 行'
END
```
24. 创建零件表p上的触发器tr_ins_p，当向表S中插入新行时，如果是红色零件且重量超过50克，则撤销该插入操作并提示用户操作失败；触发该触发器
```sql
CREATE TRIGGER tr_ins_p ON P
AFTER INSERT
AS
BEGIN
    IF EXISTS (SELECT 1 FROM inserted WHERE COLOR = '红' AND WEIGHT > 50)
    BEGIN
        PRINT '操作失败：不能插入红色且重量超过50克的零件'
        ROLLBACK
    END
END
```
25. 创建一个触发器tr_spj，当插入或更新spj表时触发，判断若该项目使用的零件总数超过500个，则拒绝此次插入或更新。触发该触发器
```sql
CREATE TRIGGER tr_spj ON SPJ
AFTER INSERT, UPDATE
AS
BEGIN
    IF EXISTS (
        SELECT JNO FROM SPJ 
        GROUP BY JNO 
        HAVING SUM(QTY) > 500
    )
    BEGIN
        PRINT '操作失败：该项目零件总数超过500个'
        ROLLBACK
    END
END
```

---

## 四、应用题

### 题1：范式分析

设有关系模式 R（EmpNo，TDate，DAmount，Dept，Manager）

属性含义：
- EmpNo - 职工编号
- TDate - 日期
- DAmount - 日营业额
- Dept - 部门名
- Manager - 部门经理

约束条件：
- 每个职工每天只有一个营业额
- 每个职工只在一个部门工作
- 每个部门只有一个经理

**问题：**
1. 根据上述规定，写出关系模式R的基本函数依赖
2. 找出关系模式R的候选键
3. 判断关系模式R最高达到第几范式，说明理由
4. 若关系模式R不属于3NF，将其分解成3NF模式集（只需要分解的结果）

**答案：**

**1. 基本函数依赖：**
- (EmpNo, TDate) → DAmount （每个职工每天只有一个营业额）
- EmpNo → Dept （每个职工只在一个部门工作）
- Dept → Manager （每个部门只有一个经理）

**2. 候选键：**
- 候选键为 **(EmpNo, TDate)**
- 分析：EmpNo和TDate不在任何函数依赖的右边出现，必须包含在候选键中；(EmpNo, TDate)可推导出所有属性，故为候选键

**3. 最高达到第几范式：**
- R最高达到 **1NF**
- 理由：存在非主属性对候选键的部分函数依赖
  - EmpNo → Dept，而EmpNo是候选键(EmpNo, TDate)的一部分
  - 违反了2NF的定义（非主属性必须完全函数依赖于候选键）

**4. 分解成3NF模式集：**
- R1(**EmpNo**, TDate, DAmount) — 职工日营业额
- R2(**EmpNo**, Dept) — 职工部门
- R3(**Dept**, Manager) — 部门经理

---

### 题2：E-R图设计

设某商业集团数据库中有四个实体集：

**实体集：**
- 商店（商店编号、商店名、地址）
- 商品（商品编码、商品名、规格、单价）
- 职工（职工编号、姓名、性别、业绩）
- 类别（类别编号、类别名称）

**联系：**
- 商店与商品：销售（M:N），属性：销售量
- 商店与职工：聘用（1:N），属性：聘期、月薪
- 类别与商品：包含（1:N）

**问题：**
1. 试画出E-R图，并在图上注明属性、联系的类型
2. 再转换成关系模式集，要求关系模式尽可能少
3. 指出每个关系模式的主键和外键

**答案：**

**1. E-R图（文字描述）：**

```
┌─────────┐          ┌─────────┐
│  商店   │──M:N────│  商品   │
│ (矩形)  │  销售   │ (矩形)  │
└────┬────┘ (菱形)  └────┬────┘
     │     销售量        │
     │                   │
    1:N               1:N
   聘用                包含
  (菱形)              (菱形)
 聘期,月薪              │
     │                   │
     N                   N
┌─────────┐          ┌─────────┐
│  职工   │          │  类别   │
│ (矩形)  │          │ (矩形)  │
└─────────┘          └─────────┘
```

各实体属性（椭圆形）：
- 商店：**商店编号**（下划线表示主键）、商店名、地址
- 商品：**商品编码**、商品名、规格、单价
- 职工：**职工编号**、姓名、性别、业绩
- 类别：**类别编号**、类别名称

**2. 转换成关系模式集（尽可能少）：**

- **商店**（商店编号, 商店名, 地址）
- **商品**（商品编码, 商品名, 规格, 单价, 类别编号）— 1:N联系"包含"合并到N端
- **职工**（职工编号, 姓名, 性别, 业绩, 商店编号, 聘期, 月薪）— 1:N联系"聘用"合并到N端
- **类别**（类别编号, 类别名称）
- **销售**（商店编号, 商品编码, 销售量）— M:N联系需独立建表

**3. 主键和外键：**

| 关系模式 | 主键 | 外键 |
|----------|------|------|
| 商店 | 商店编号 | 无 |
| 商品 | 商品编码 | 类别编号 → 类别(类别编号) |
| 职工 | 职工编号 | 商店编号 → 商店(商店编号) |
| 类别 | 类别编号 | 无 |
| 销售 | (商店编号, 商品编码) | 商店编号 → 商店(商店编号), 商品编码 → 商品(商品编码) |

---

## 统计

| 大题 | 题数 |
|------|------|
| 一、关系代数运算 | 7个运算 |
| 二、关系代数表达式 | 4题 |
| 三、T-SQL操作 | 25题 |
| 四、应用题 | 2题 |
