# 110-期末计算题汇总 (Final Calculation Questions Summary)

> **说明**：本文件收录了用户提供的期末考试 **PART B (非选择题/计算题)** 的详细解答与解析。
> **来源**：用户输入
> **时间**：2025-11-30

## II. 海明码计算题 (Hamming Code Problem)

**题目 (Question):**
For the 8-bit data `10110101` stored in memory, suppose the data is read from memory and the calculated check bit is `1101`. Please answer the following questions using Hamming algorithm (12 points):
对于存储在内存中的 8 位数据 `10110101`，假设从内存中读取该数据后，计算出的校验位是 `1101`，请使用海明算法回答下列问题：

1.  **What is old check bit?** (旧的校验位是多少？)
2.  **What is new check bit?** (新的校验位是多少？)
3.  **What is the data read from memory?** (从内存中读出的数据是什么？)

---

### 详细解答与计算过程 (Detailed Solution)

#### 第一步：数据位与校验位的布局 (Layout)

对于 8 位数据 ($n=8$)，我们需要 4 位校验位 ($k=4$)，满足 $2^k - 1 \ge n + k$ ($15 \ge 12$)。
总码长为 12 位。校验位位于 $2^0, 2^1, 2^2, 2^3$ 即位置 1, 2, 4, 8。

| 位置 (Pos) | 12 | 11 | 10 | 9 | **8** | 7 | 6 | 5 | **4** | 3 | **2** | **1** |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| **位名称** | D8 | D7 | D6 | D5 | **C8** | D4 | D3 | D2 | **C4** | D1 | **C2** | **C1** |
| **原始值** | **1** | **0** | **1** | **1** | **?** | **0** | **1** | **0** | **?** | **1** | **?** | **?** |

#### 1. 计算旧校验位 (Calculate Old Check Bit)

采用**偶校验 (Even Parity)**：

*   **C1** (Pos 1, 3, 5, 7, 9, 11): $D1 \oplus D2 \oplus D4 \oplus D5 \oplus D7 = 1 \oplus 0 \oplus 0 \oplus 1 \oplus 0 = 0$
*   **C2** (Pos 2, 3, 6, 7, 10, 11): $D1 \oplus D3 \oplus D4 \oplus D6 \oplus D7 = 1 \oplus 1 \oplus 0 \oplus 1 \oplus 0 = 1$ (需补1)
*   **C4** (Pos 4, 5, 6, 7, 12): $D2 \oplus D3 \oplus D4 \oplus D8 = 0 \oplus 1 \oplus 0 \oplus 1 = 0$
*   **C8** (Pos 8, 9, 10, 11, 12): $D5 \oplus D6 \oplus D7 \oplus D8 = 1 \oplus 1 \oplus 0 \oplus 1 = 1$ (需补1)

> **结论 1 (Answer 1):**
> 旧的校验位是 **`1010`** (顺序 C8 C4 C2 C1)。

#### 2. 新的校验位 (New Check Bit)

题目直接给出：“calculated check bit is 1101”。这意味着系统读取数据后重新计算的校验位结果。

> **结论 2 (Answer 2):**
> 新的校验位是 **`1101`**。

#### 3. 从内存中读出的数据 (Data Read from Memory)

*   **计算故障字 (Syndrome Word):**
    $$S = P_{old} \oplus P_{new} = 1010 \oplus 1101 = 0111$$
    二进制 `0111` = 十进制 **7**。
    说明第 **7** 号位置出错。

*   **定位与修正 (Locate & Fix):**
    *   第 7 号位置对应数据位 **D4**。
    *   原始 D4 为 `0`，出错后变为 `1`。
    *   原始数据：`10110101`
    *   读出数据：`1011`**`1`**`101` (D4 翻转)

> **结论 3 (Answer 3):**
> 从内存中读出的数据是 **`10111101`**。

---

### 知识点链接
*   [08-舍入与误差.md](file:///d:/我的笔记/计算机组成原理/1-核心笔记/精简版/08-舍入与误差.md) (海明码原理)

## III. 寻址方式简答题 (Addressing Modes Short Answer)

**题目 (Question):**
Describe the process of getting operand using "Immediate Addressing" and "Indirect Addressing", and give their advantages and disadvantages. (12 points)
描述使用“立即寻址”和“间接寻址”获取操作数的过程，并分析它们的优缺点。

---

### 详细解答 (Detailed Solution)

#### 1. 立即寻址 (Immediate Addressing)

*   **获取操作数的过程 (Process):**
    *   操作数直接包含在指令中。
    *   当 CPU 取出指令放入指令寄存器（IR）后，指令的地址字段（Address Field）里存放的不再是地址，而是**实际的操作数本身**。
    *   **公式：** `Operand = A` (其中 A 是指令地址字段的内容)。
    *   **步骤：** CPU 取指 -> 译码 -> 直接从指令寄存器中获取数据进行计算（无需再次访问内存）。

*   **优点 (Advantages):**
    *   **速度快：** 在取指之后，不需要额外的内存访问（Memory Reference）来获取数据，节省了总线周期。
    *   **简单：** 硬件实现简单。

*   **缺点 (Disadvantages):**
    *   **数值范围受限：** 操作数的大小受到指令中地址字段位数的限制。例如，如果指令只有 8 位留给地址字段，那么只能表示 -128 到 +127 之间的常数。
    *   **不够灵活：** 只能用于常数，无法在程序运行过程中修改该数值（除了修改代码本身）。

#### 2. 间接寻址 (Indirect Addressing)

*   **获取操作数的过程 (Process):**
    *   指令中的地址字段给出的不是操作数的地址，而是**存放操作数有效地址的内存地址**（即“地址的地址”）。
    *   **公式：** `EA = (A)`, `Operand = (EA)` (其中 A 是指令中的地址，EA 是有效地址)。
    *   **步骤：**
        1.  CPU 根据指令中的地址 A，去访问内存。
        2.  从内存地址 A 处读出一个新的地址（有效地址 EA）。
        3.  CPU 再次利用这个 EA 去访问内存，读出实际的操作数。

*   **优点 (Advantages):**
    *   **扩大寻址范围：** 可以寻址的内存空间取决于存储字长（通常很大），而不受指令中地址字段位数的限制。
    *   **灵活（支持指针）：** 非常适合实现指针（Pointers）和复杂的数据结构（如链表），便于编程。

*   **缺点 (Disadvantages):**
    *   **速度慢：** 需要**两次**访问内存才能获取操作数（一次读地址，一次读数据），导致指令执行速度变慢。

### 知识点对比总结表

| 特性 | 立即寻址 (Immediate) | 间接寻址 (Indirect) |
| :--- | :--- | :--- |
| **操作数位置** | 在指令内部 | 在内存中 (通过指针找到) |
| **访存次数 (取数据)** | 0 次 | 2 次 |
| **主要优点** | 速度最快 | 寻址范围大，支持指针 |
| **主要缺点** | 数值范围小 | 速度慢 (多次访存) |
| **符号表示** | `#100` (汇编示例) | `(100)` 或 `[100]` |

### 知识点链接
*   [10-寻址方式.md](file:///d:/我的笔记/计算机组成原理/1-核心笔记/精简版/10-寻址方式.md)

## IV. MESI 协议分析题 (MESI Protocol Analysis)

**题目 (Question):**
In a multiprocessor system, the MESI protocol is used to solve the cache coherence problem. (12 points)
在多处理器系统中，MESI 协议被用来解决缓存一致性问题。

1.  **This is the case of \_\_\_\_\_\_.** (这是 \_\_\_\_\_\_ 的情况。)
2.  **Please complete this figure.** (请补全这个状态转换图。)
3.  **With this case, please fill best answers into following table.** (结合这种情况，请在下表中填入最佳答案。)

---

### 详细解答 (Detailed Solution)

#### 1. 第一问：情况识别 (Case Identification)

*   **现象**：Initial 处理器从 **I (Invalid)** 状态转变为 **M (Modified)** 状态。
*   **含义**：处理器原本没有数据，现在想要写入数据。
*   **答案**：**Write Miss** (写失效 / 写未命中)。

#### 2. 第二问：补全状态图 (Complete Figure)

*   **逻辑**：当一个处理器要独占修改数据 (变为 M) 时，其他处理器 (Snoopy) 必须作废自己的副本。
*   **画图操作**：
    *   在 Snoopy 侧，所有状态 (**S**, **E**, **M**) 都必须指向 **I (Invalid)**。
    *   箭头方向：$S \rightarrow I$, $E \rightarrow I$, $M \rightarrow I$。

#### 3. 第三问：填写表格 (Fill Table)

| The states in begin (开始状态) | Where is Valid data? (有效数据在哪？) | Actions (动作) | The states in end (结束状态) |
| :--- | :--- | :--- | :--- |
| **Initial:** I (无效)<br>**Snoopy:** S/E (共享/独占) | **Main Memory**<br>(主存) | 1. **Bus Upgr / RWITM** (总线发出“读并意图修改”信号)<br>2. **Snoopy invalidates** (监听者作废自己的副本)<br>3. **Memory sends data** (内存发送数据给 Initial)<br>4. **Initial writes data** (Initial 写入数据) | **Initial:** M (修改)<br>**Snoopy:** I (无效) |

### 核心知识点复习 (MESI)

*   **M (Modified)**: 已修改。独占且脏 (Dirty)。
*   **E (Exclusive)**: 独占。独占且干净 (Clean)。
*   **S (Shared)**: 共享。多份且干净 (Clean)。
*   **I (Invalid)**: 无效。

**口诀：** 谁要变 **M** (写)，别人就得变 **I** (滚)。

### 知识点链接
*   [19-Cache技术.md](file:///d:/我的笔记/计算机组成原理/1-核心笔记/精简版/19-Cache技术.md)
