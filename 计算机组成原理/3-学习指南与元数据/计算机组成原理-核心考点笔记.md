# I/O 系统复习笔记 (I/O System Review Notes)

> **简介**：本笔记基于 `101-I-O系统练习题.md` 中的习题整理而成，提炼了核心考点与易错点。
> **来源**：习题解析整理
> **最后更新**：2025年1月

[TOC]

## 1. I/O 控制方式 (I/O Control Methods)

### 1.1 程序查询方式 (Programmed I/O / Polling)
*   **核心特征**：CPU **忙等 (Busy Waiting)**。
*   **工作流程**：CPU 向 I/O 模块发出命令后，进入一个循环，**定期读取并检查** I/O 模块的状态寄存器，直到操作完成。
*   **缺点**：CPU 效率极低，无法并行工作。
*   **考点**：“等待”意味着 CPU 在执行查询指令，并未停止运行。

### 1.2 中断驱动 I/O (Interrupt-driven I/O)
*   **核心特征**：**CPU 与外设并行工作**。
*   **工作流程**：
    1.  CPU 发出 I/O 命令后，继续执行其他程序。
    2.  I/O 模块准备好后，向 CPU 发送 **中断请求 (Interrupt Request)**。
    3.  CPU 在当前指令周期结束后响应中断，暂停当前程序，保存现场，跳转到 **中断服务程序 (ISR)**。
*   **关键点**：
    *   **中断请求信号**：是 I/O 发给 CPU 的，不是 I/O 模块与设备之间交换的信息。
    *   **中断响应时机**：指令执行周期结束时。

### 1.3 直接存储器访问 (DMA)
*   **核心特征**：**硬件接管总线，不经过 CPU**。
*   **工作流程**：
    1.  CPU 初始化 DMA 控制器（告知源/目地址、计数）。
    2.  DMA 控制器向 CPU 申请总线控制权 (**Bus Request**)。
    3.  获得总线后，DMA 直接控制内存与外设的数据传输。
    4.  传输结束（一整块数据传完）后，DMA 发送中断通知 CPU。
*   **关键技术**：**周期窃取 (Cycle Stealing)** —— DMA 优先占用存取周期。
*   **与中断的区别**：
    *   中断方式：CPU 参与数据搬运（指令级干预）。
    *   DMA 方式：CPU 不参与数据搬运（硬件级传输），仅在开始和结束参与。
    *   *注意*："直接 I/O 访问 (Direct I/O Access)" 不是标准的计算机组成原理 I/O 控制方式术语。
*   **DMA 效率更高的原因**：
    *   **减少中断次数**：DMA 仅在**整块**数据传输完成后中断一次；而中断驱动方式每传输一个**字**就要中断一次。
    *   **减少上下文切换开销**：中断次数减少 => 保存/恢复现场 (PC/寄存器) 的次数大幅减少。
    *   **无需指令干预**：数据传输由硬件直接完成，CPU 不需执行 `MOV` 等搬运指令。
*   **优先级比较**：**DMA 请求 > 中断请求**。
    *   *原因*：DMA 处理的是高速数据传输，若不及时响应会导致数据丢失（溢出）；而中断处理的是程序逻辑，晚一点响应后果较轻。

## 2. I/O 编址方式 (Addressing Modes)

### 2.1 统一编址 (Memory-Mapped I/O)
*   **原理**：I/O 端口占用内存地址空间。
*   **区分**：通过 **不同的地址范围** 来区分内存和 I/O。
*   **优点**：指令统一，编程灵活。
*   **缺点**：占用内存容量。

### 2.2 独立编址 (Isolated I/O)
*   **原理**：I/O 拥有独立的地址空间。
*   **区分**：通过 **专门的控制线** 和 **专用指令 (IN/OUT)**。

## 3. I/O 模块结构

*   **内部寄存器**：
    *   **控制寄存器 (Control Register)**：接收 CPU 命令。
    *   **状态寄存器 (Status Register)**：反馈设备状态 (Ready/Busy/Error)。
    *   **数据缓冲寄存器 (Data Buffer Register)**：暂存数据。
    *   *(注：指令寄存器 IR 和 内存地址寄存器 MAR 属于 CPU，不在 I/O 模块中)*

### 3.1 接口信号流向 (Signal Flow)
*   **模块 <-> 设备**：数据、控制、状态。
*   **模块 -> CPU**：中断请求 (INTR)。
*   *易错点*：设备不直接发中断给 CPU，也不发给模块（通常体现为状态位的变化）。

### 3.2 总线复用 (Bus Multiplexing)
*   **数据总线 (Data Bus)** 传输的内容不仅是数据，还包括：
    *   **命令词 (Command)**：CPU 发给 I/O 的指令。
    *   **状态字 (Status)**：I/O 发给 CPU 的状态。
    *   **中断类型号/向量 (Interrupt Vector)**：I/O 发给 CPU 的中断 ID。

## 4. 中断系统进阶

### 4.1 中断处理流程
1.  **中断请求**：外设 -> CPU。
2.  **中断判优**：硬件或软件决定响应哪个中断。
3.  **中断响应**：CPU 发送 INTA 信号，关中断，保存断点 (PC, PSW)。
4.  **中断服务 (ISR)**：保护现场 (寄存器) -> 服务 -> 恢复现场。
5.  **中断返回**：恢复断点，开中断。

### 4.2 堆栈的作用
*   **保存现场**：PC (程序计数器)、PSW (程序状态字)、通用寄存器。
*   **目的**：为了在中断处理结束后，能够准确地**恢复**原程序的执行状态。

### 4.3 中断优先级与掩码 (Mask)
*   **硬件优先级**：固定不可变。
*   **中断屏蔽字 (Mask)**：通过软件设置，可以动态改变**中断响应优先级**（实际是改变了处理顺序）。
*   **规则**：屏蔽位为 `1` 表示屏蔽（不响应），`0` 表示允许。

### 4.4 中断掩码与多重中断计算 (必考大题)
*   **掩码字计算公式**：
    *   对于某个中断源 $i$，其掩码字 $M_i$ 应屏蔽掉：
        1.  **自身** (避免递归)。
        2.  所有**目标优先级**比 $i$ 低的中断源。
*   **多重中断时间轴画法**：
    *   **抢占原则**：新中断优先级 > 当前正在执行的中断优先级 => **立即抢占**（嵌套）。
    *   **等待原则**：新中断优先级 < 当前正在执行的中断优先级 => **等待**当前中断结束。
    *   **恢复原则**：中断结束 -> 返回上一层（可能是主程序，也可能是被中断的低优先级 ISR）。
