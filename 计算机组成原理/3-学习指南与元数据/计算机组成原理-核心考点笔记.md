# I/O 系统复习笔记 (I/O System Review Notes)

> **简介**：本笔记基于 `101-I-O系统练习题.md` 中的习题整理而成，提炼了核心考点与易错点。
> **来源**：习题解析整理
> **最后更新**：2025年1月

[TOC]

## 1. I/O 控制方式 (I/O Control Methods)

### 1.1 程序查询方式 (Programmed I/O / Polling)
*   **核心特征**：CPU **忙等 (Busy Waiting)**。
*   **工作流程**：CPU 向 I/O 模块发出命令后，进入一个循环，**定期读取并检查** I/O 模块的状态寄存器，直到操作完成。
*   **缺点**：CPU 效率极低，无法并行工作。
*   **考点**：“等待”意味着 CPU 在执行查询指令，并未停止运行。

### 1.2 中断驱动 I/O (Interrupt-driven I/O)
*   **核心特征**：**CPU 与外设并行工作**。
*   **工作流程**：
    1.  CPU 发出 I/O 命令后，继续执行其他程序。
    2.  I/O 模块准备好后，向 CPU 发送 **中断请求 (Interrupt Request)**。
    3.  CPU 在当前指令周期结束后响应中断，暂停当前程序，保存现场，跳转到 **中断服务程序 (ISR)**。
*   **关键点**：
    *   **中断请求信号**：是 I/O 发给 CPU 的，不是 I/O 模块与设备之间交换的信息。
    *   **中断响应时机**：指令执行周期结束时。

### 1.3 直接存储器访问 (DMA)
*   **核心特征**：**硬件接管总线，不经过 CPU**。
*   **工作流程**：
    1.  CPU 初始化 DMA 控制器（告知源/目地址、计数）。
    2.  DMA 控制器向 CPU 申请总线控制权 (**Bus Request**)。
    3.  获得总线后，DMA 直接控制内存与外设的数据传输。
    4.  传输结束（一整块数据传完）后，DMA 发送中断通知 CPU。
*   **关键技术**：**周期窃取 (Cycle Stealing)** —— DMA 优先占用存取周期。
*   **与中断的区别**：
    *   中断方式：CPU 参与数据搬运（指令级干预）。
    *   DMA 方式：CPU 不参与数据搬运（硬件级传输），仅在开始和结束参与。
    *   *注意*："直接 I/O 访问 (Direct I/O Access)" 不是标准的计算机组成原理 I/O 控制方式术语。
*   **DMA 效率更高的原因**：
    *   **减少中断次数**：DMA 仅在**整块**数据传输完成后中断一次；而中断驱动方式每传输一个**字**就要中断一次。
    *   **减少上下文切换开销**：中断次数减少 => 保存/恢复现场 (PC/寄存器) 的次数大幅减少。
    *   **无需指令干预**：数据传输由硬件直接完成，CPU 不需执行 `MOV` 等搬运指令。
*   **优先级比较**：**DMA 请求 > 中断请求**。
    *   *原因*：DMA 处理的是高速数据传输，若不及时响应会导致数据丢失（溢出）；而中断处理的是程序逻辑，晚一点响应后果较轻。

## 2. I/O 编址方式 (Addressing Modes)

### 2.1 统一编址 (Memory-Mapped I/O)
*   **原理**：I/O 端口占用内存地址空间。
*   **区分**：通过 **不同的地址范围** 来区分内存和 I/O。
*   **优点**：指令统一，编程灵活。
*   **缺点**：占用内存容量。

### 2.2 独立编址 (Isolated I/O)
*   **原理**：I/O 拥有独立的地址空间。
*   **区分**：通过 **专门的控制线** 和 **专用指令 (IN/OUT)**。

## 3. I/O 模块结构

*   **内部寄存器**：
    *   **控制寄存器 (Control Register)**：接收 CPU 命令。
    *   **状态寄存器 (Status Register)**：反馈设备状态 (Ready/Busy/Error)。
    *   **数据缓冲寄存器 (Data Buffer Register)**：暂存数据。
    *   *(注：指令寄存器 IR 和 内存地址寄存器 MAR 属于 CPU，不在 I/O 模块中)*

### 3.1 接口信号流向 (Signal Flow)
*   **模块 <-> 设备**：数据、控制、状态。
*   **模块 -> CPU**：中断请求 (INTR)。
*   *易错点*：设备不直接发中断给 CPU，也不发给模块（通常体现为状态位的变化）。

### 3.2 总线复用 (Bus Multiplexing)
*   **数据总线 (Data Bus)** 传输的内容不仅是数据，还包括：
    *   **命令词 (Command)**：CPU 发给 I/O 的指令。
    *   **状态字 (Status)**：I/O 发给 CPU 的状态。
    *   **中断类型号/向量 (Interrupt Vector)**：I/O 发给 CPU 的中断 ID。

## 4. 中断系统进阶

### 4.1 中断处理流程
1.  **中断请求**：外设 -> CPU。
2.  **中断判优**：硬件或软件决定响应哪个中断。
3.  **中断响应**：CPU 发送 **INTA (中断确认)** 信号，关中断，保存断点 (PC, PSW)。
    *   *时机*：指令执行周期结束时。
4.  **中断服务 (ISR)**：保护现场 (通用寄存器) -> 服务 -> 恢复现场。
5.  **中断返回**：恢复断点，开中断。

### 4.2 堆栈的作用
*   **保存现场 (Context Saving)**：
    *   **PC (程序计数器)**：记录下一条指令地址（硬件自动保存）。
    *   **PSW (程序状态字)**：记录状态标志（硬件自动保存）。
    *   **通用寄存器 (GPRs)**：记录中间计算结果（软件/ISR保存）。
*   **目的**：为了在中断处理结束后，能够准确地**恢复**原程序的执行状态。

### 4.3 中断优先级与掩码 (Mask)
*   **硬件优先级**：固定不可变。
*   **中断屏蔽字 (Mask)**：通过软件设置，可以动态改变**中断响应优先级**（实际是改变了处理顺序）。
*   **规则**：屏蔽位为 `1` 表示屏蔽（不响应），`0` 表示允许。

### 4.4 中断掩码与多重中断计算 (必考大题)
*   **掩码字计算公式**：
    *   对于某个中断源 $i$，其掩码字 $M_i$ 应屏蔽掉：
        1.  **自身** (避免递归)。
        2.  所有**目标优先级**比 $i$ 低的中断源。
*   **多重中断时间轴画法**：
    *   **抢占原则**：新中断优先级 > 当前正在执行的中断优先级 => **立即抢占**（嵌套）。
    *   **等待原则**：新中断优先级 < 当前正在执行的中断优先级 => **等待**当前中断结束。
    *   **恢复原则**：中断结束 -> 返回上一层（可能是主程序，也可能是被中断的低优先级 ISR）。

---
    *   $2^{32} = 2^2 \times 2^{30} = 4 \times 1G = 4G$
*   **易错点**：
    *   地址是**无符号整数 (Unsigned Integer)**，范围从 0 到 $2^k-1$。
    *   不存在负数地址（排除 -2G 到 2G 这种选项）。

### 1.2 冯·诺依曼架构 (Von Neumann Architecture)
*   **五大特点**：
    1.  **二进制**：指令和数据均以二进制形式表示。
    2.  **存储程序**：程序和数据预先存入内存。
    3.  **顺序执行**：指令按序执行。
    4.  **不区分指令/数据**：在内存中无区别，靠 CPU **访问阶段** (取指 vs 执行) 来区分。
    5.  **五大部件**：运算器、控制器、存储器、输入设备、输出设备。

### 1.3 指令周期 (Instruction Cycle)
*   **最简形式**：**取指 (Fetch)** + **执行 (Execute)**。
*   **完整形式**：取指 -> 间接 (Indirect) -> 执行 -> 中断 (Interrupt)。

### 1.4 字长 (Word Length)
*   **定义**：CPU 一次能处理的二进制数据的位数。
*   **单位换算**：
    *   1 Byte (字节) = 8 bits (位)。
    *   4B = 32 bits。
*   **意义**：字长决定了 CPU 的运算精度和通用寄存器的宽度。

### 1.5 存储层次结构 (Memory Hierarchy)
*   **定义**：计算机内存系统不仅仅是内存条，而是一个多级层次结构。
*   **金字塔结构** (从上到下：速度变慢，容量变大，价格变低)：
    1.  **寄存器 (Registers)**：CPU 内部，最快。
    2.  **高速缓存 (Cache)**：SRAM，缓解 CPU 与主存速度差异。
    3.  **主存储器 (Main Memory)**：DRAM，存放运行中的程序和数据。
    4.  **辅助存储器 (Auxiliary Memory)**：磁盘/SSD，永久存储。

### 1.6 CPU 访问权限 (CPU Access)
*   **直接访问**：寄存器、Cache、主存 (Main Memory)。
    *   CPU 可以通过地址总线直接读写这些存储器中的数据。
*   **无法直接访问**：辅助存储器 (硬盘/SSD/光盘)。
    *   **必须先加载到主存**：CPU 想要处理硬盘上的数据，必须先由 I/O 系统（如 DMA）把数据搬到内存里，CPU 才能从内存里读。

## 2. Cache 存储系统 (Cache Memory)

### 2.0 核心目的 (Core Purpose)
*   **解决矛盾**：**CPU 速度** 与 **主存速度** 不匹配（CPU 太快，内存太慢）。
*   **误区**：Cache 不能解决主存容量不足的问题（那是虚拟内存的事）。

### 2.1 映射方式 (Mapping Techniques)
*   **全相联映射 (Associative Mapping)**：
    *   **规则**：主存的**任意一块**可以映射到 Cache 的**任意一行**。
    *   **特点**：灵活性最高，冲突概率最低，但比较电路最复杂（成本高）。
    *   **适用**：小容量 Cache。

### 2.2 Cache 参数计算 (Calculation)
*   **行数计算公式**：
    $$ \text{行数 (Lines)} = \frac{\text{Cache 总容量 (Cache Size)}}{\text{行大小 (Line Size)}} $$
*   **注意单位统一**：
    *   通常将容量和行大小都换算成 **Byte (字节)**。
    *   1 Word (字) = 4 Bytes (通常情况，除非题目另有说明)。

### 2.3 寻址方式与容量计算 (Addressing Calculation)
*   **核心公式**：
    $$ \text{可寻址单元数} = \frac{\text{总容量 (Total Capacity)}}{\text{编址单位大小 (Unit Size)}} $$
*   **常见单位**：
    *   **按字节编址 (Byte Addressing)**：Unit Size = 1 Byte。
    *   **按字编址 (Word Addressing)**：Unit Size = 字长 (Word Length)。
    *   **按半字编址 (Half-word Addressing)**：Unit Size = 字长 / 2。
*   **例题 Q8 实战**：
    *   容量 16MB ($2^{24}$ B)，字长 32位 (4B)。
    *   半字大小 = 2B。
    *   单元数 = $2^{24} / 2 = 2^{23}$。

### 2.4 组相联映射计算 (Set Associative Calculation)
*   **组数 (Sets) 计算**：
    $$ \text{组数} = \frac{\text{Cache 总行数}}{\text{路数 (Ways)}} $$
*   **组索引 (Set Index) 计算**：
    1.  先算**主存块号 (Block Address)**：$\lfloor \text{内存地址} / \text{块大小} \rfloor$
    2.  再算**组号**：$\text{主存块号} \pmod{\text{组数}}$
*   **例题 Q9 实战**：
    *   16 行，2 路 => 8 组。
    *   地址 129，块大小 32B => 块号 = $129 // 32 = 4$。
    *   地址 129，块大小 32B => 块号 = $129 // 32 = 4$。
    *   组号 = $4 \pmod 8 = 4$。

### 2.5 写策略 (Write Policy)
*   **通写式 (Write-through)**：
    *   **原理**：数据同时写入 Cache 和主存。
    *   **优点**：实现简单，主存与 Cache 数据时刻保持一致。
    *   **缺点**：写操作慢（受限于主存速度），总线流量大。
*   **写回式 (Write-back)**：
    *   **原理**：数据只写入 Cache，只有当该行被**替换**出去时，才写回主存。
    *   **优点**：写操作快（只写 Cache），减少总线流量。
    *   **缺点**：控制复杂，需要 **Dirty Bit (脏位)** 标记是否被修改过。

### 2.6 映射方式的统一视角 (Unified View)
*   假设 Cache 总行数为 $M$，每组行数（路数）为 $K$：
    *   **直接映射 (Direct Mapping)**：$K = 1$ (每组只有 1 行，对号入座)。
    *   **全相联映射 (Fully Associative)**：$K = M$ (只有 1 个组，包含所有行，随意停)。
    *   **组相联映射 (Set Associative)**：$1 < K < M$ (折中方案)。

## 3. 存储器类型 (Memory Types)

### 3.1 RAM (随机存取存储器)
*   **易失性 (Volatile)**：断电后数据丢失。
*   **SRAM (静态 RAM)**：
    *   速度快，价格贵，集成度低。
    *   用途：**Cache**。
    *   原理：触发器 (Flip-flop)，无需刷新。
*   **DRAM (动态 RAM)**：
    *   速度慢，价格便宜，集成度高。
    *   用途：**主存 (Main Memory)**。
    *   原理：电容 (Capacitor)，需要**定期刷新 (Refresh)**。

### 3.4 SRAM vs DRAM 对比表 (必考)
| 特性 | SRAM (静态) | DRAM (动态) |
| :--- | :--- | :--- |
| **存储元件** | 触发器 (Flip-flop) | 电容 (Capacitor) |
| **集成度** | 低 (6个晶体管/bit) | 高 (1个晶体管/bit) |
| **速度** | **快** | 慢 (需要刷新) |
| **成本** | **高** | 低 |
| **刷新** | 不需要 | **需要** |
| **用途** | Cache | 主存 |

### 3.2 ROM (只读存储器)
*   **非易失性 (Non-volatile)**：断电后数据不丢失。
*   **PROM (可编程 ROM)**：一次性写入，**写完后不可更改** (Permanent)。
*   **EPROM (可擦除 PROM)**：可用紫外线擦除并重写。
*   **EEPROM / Flash**：可用电擦除并重写 (如 SSD, U盘)。
*   **字扩展 (Word Expansion)**：增加**容量** (地址线)。
    *   *做法*：将芯片的**地址线**和**数据线**并联，用**片选信号 (CS)** 区分。
    *   *例子*：用 2 个 $16\text{K} \times 8$ 位芯片组成 $32\text{K} \times 8$ 位存储器。
*   **字位同时扩展**：既加长又加宽。
    *   *例题 Q16*：4 个 $16\text{K} \times 8$ 位芯片 => $32\text{K} \times 16$ 位。
    *   (2 个一组做位扩展得到 $16\text{K} \times 16$，再把这两组做字扩展得到 $32\text{K} \times 16$)。
*   **总时间** = **寻道时间** + **旋转延迟** + **传输时间**。
*   **寻道时间 (Seek Time)**：磁头移动到**目标磁道 (Track)** 所需的时间。（最耗时，机械运动）
*   **旋转延迟 (Rotational Delay/Latency)**：**目标扇区 (Sector)** 旋转到磁头下方所需的时间。（平均为旋转半圈的时间）
    *   *公式*：$\text{平均延迟} = \frac{1}{2} \times \frac{60}{\text{转速 (RPM)}}$。
    *   *结论*：转速加倍 => 延迟减半。
*   **传输时间 (Transfer Time)**：磁头读写数据所需的时间。
*   **传输时间 (Transfer Time)**：磁头读写数据所需的时间。

### 4.2 RAID (独立磁盘冗余阵列)
*   **核心概念**：
    *   **条带化 (Striping)**：提高**速度** (并行读写)。
    *   **冗余 (Redundancy)**：提高**可靠性** (容错)。
*   **常见级别**：
    *   **RAID 0**：只有条带化，速度最快，无冗余（坏一块盘全完）。
    *   **RAID 1**：镜像 (Mirroring)，冗余度最高，成本高。
    *   **RAID 5**：分布式奇偶校验，兼顾速度与可靠性。

### 4.3 磁盘读写单位 (Access Unit)
*   **最小单位**：**扇区 (Sector)**。
*   **注意**：
    *   磁盘是**块设备 (Block Device)**，不能像内存那样按字节 (Byte) 读写。
    *   即使你只想改 1 个字节，也必须把整个扇区（通常 512B 或 4KB）读出来，改完后再整个写回去。
    *   *格式化容量 < 未格式化容量*：因为扇区里除了数据，还要存头信息、尾信息、校验码 (ECC) 等。

### 4.4 DRAM 地址复用 (Address Multiplexing)
*   **原理**：DRAM 容量大，地址线太多会导致芯片引脚太多，封装困难。
*   **解决方案**：将地址分为 **行地址 (Row Address)** 和 **列地址 (Column Address)**，分两次通过同一组引脚传输。
*   **计算公式**：
    *   **地址引脚数** = $\text{总地址位数} / 2$。
    *   **数据引脚数** = 数据位数 (不变)。
*   **例题 Q22 实战**：
    *   容量 $1024 \times 8$ 位。
    *   地址位数：$1024 = 2^{10}$ => 10 位。
    *   **地址引脚**：$10 / 2 = \mathbf{5}$ 根。
    *   **数据引脚**：$\mathbf{8}$ 根。
    *   **总数**：$5 + 8 = 13$ 根。

### 4.5 存取方式 (Access Methods)
*   **随机存取 (Random Access)**：访问时间与位置无关（如 RAM）。
*   **顺序存取 (Sequential Access)**：必须按顺序找（如磁带）。
*   **直接存取 (Direct Access)**：先跳到附近，再顺序找（如磁盘）。
    *   *磁盘特性*：既有寻道（随机），又有旋转（顺序），混合体。

### 2.7 Cache 地址结构计算 (Address Format)
*   **地址结构**：
    $$ \text{主存地址} = \text{标记 (Tag)} + \text{组索引 (Set Index)} + \text{块内偏移 (Offset)} $$
*   **各部分位数计算**：
    1.  **Offset**：由 **块大小 (Line Size)** 决定。$2^n$ Bytes => $n$ 位。
    2.  **Set Index**：由 **组数 (Sets)** 决定。$2^m$ Sets => $m$ 位。
    3.  **Tag**：剩下的位数。$\text{总位数} - \text{Set} - \text{Offset}$。
*   **例题 Q23 实战**：
    *   **条件**：128KB, 16B/行, 8路。地址 `1234567H`。
    *   **Offset**：16B = $2^4$ => **4 bits**。
    *   **Set**：行数 = 128KB/16B = 8K。组数 = 8K/8 = 1K = $2^{10}$ => **10 bits**。
    *   **Tag**：地址右移 (10+4=14) 位。
    *   **计算**：`1234567H` >> 14。
        *   `7` (4位) 是 Offset。
        *   `56` 和 `4` 的低2位 (共10位) 是 Set。
        *   剩下的高位是 Tag => `048DH`。

### 2.8 综合计算大题实战 (Q26)
*   **题目**：地址 `DEF5C6AH`，格式 `Tag(15)|Set(9)|Offset(4)`。
*   **第一步：拆解十六进制**
    *   `A` = `1010` (最后 4 位) => **Offset = A**。
*   **第二步：提取 Set (9位)**
    *   看 `A` 前面的 `6` (`0110`) 和 `C` (`1100`) 和 `5` (`0101`)。
    *   取 `6` (4位) + `C` (4位) + `5` 的最后 1 位 (`1`)。
    *   拼起来：`1 1100 0110` = **1C6H** => **Set Index**。
*   **第三步：提取 Tag (15位)**
    *   剩下的位：`D` (`1101`) `E` (`1110`) `F` (`1111`) `5` 的前 3 位 (`010`)。
    *   拼起来：`1101 1110 1111 010`。
    *   重组 Hex：`110 1111 0111 1010` = **6F7AH** => **Tag**。

### 3.6 存储扩展设计实战 (Q27)
*   **题目**：目标 64K $\times$ 8位，芯片 16K $\times$ 8位。
*   **扩展方式**：
    *   宽度 (8位) 不变 => **无需位扩展**。
    *   深度 (16K -> 64K) 增加 => **字扩展**。
*   **芯片数量**：$64\text{K} / 16\text{K} = \mathbf{4}$ 片。
*   **片选逻辑 (Chip Select)**：
    *   需要区分 4 个芯片 => 需要 **2 根** 高位地址线 ($2^2=4$)。
    *   通常接 **2-4 译码器**。
*   **寻址范围分配**：
    *   **Chip 0**: `0000H - 3FFFH` (0~16K-1)
    *   **Chip 1**: `4000H - 7FFFH` (16K~32K-1)
    *   **Chip 2**: `8000H - BFFFH` (32K~48K-1)
    *   **Chip 3**: `C000H - FFFFH` (48K~64K-1)

---

# 模块一：数据的表示与运算 (Data Representation)

## 1. 整数表示 (Integer Representation)

### 1.1 补码 (Two's Complement)
*   **核心优势**：将减法转化为加法，符号位参与运算。
*   **表示范围 (n位)**：$-2^{n-1} \sim +2^{n-1}-1$。
    *   *注意*：负数比正数多一个 (如 8位：-128 ~ +127)。
*   **溢出判断 (Overflow)**：
    *   **正溢出**：两个正数相加，结果变成负数。
    *   **负溢出**：两个负数相加，结果变成正数。
    *   *口诀*：**“正正得负，负负得正”** (指符号位)。
    *   *例题 Q1*：4位补码 (范围 -8 ~ +7)。
        *   `4 + (-4) = 0` (正常)。
        *   `4 - (-4) = 4 + 4 = 8` (>7，**溢出**)。

### 1.2 原码 (Sign-Magnitude)
*   **定义**：最高位为符号位 (0正1负)，其余位表示数值的绝对值。
*   **表示范围 (n+1 位)**：
    *   1 位符号 + n 位数值。
    *   最大值：$+(2^n - 1)$。
    *   最小值：$-(2^n - 1)$。
    *   *范围*：$-(2^n - 1) \le x \le +(2^n - 1)$。
*   **特点**：
    *   有两个 0 (+0 和 -0)。
    *   计算复杂 (加减法要先判断符号)。
    *   *例题 Q2*：(n+1) 位原码范围 => 选 D。

### 1.3 C 语言类型转换 (Type Conversion)
*   **核心原则**：**位模式不变，解释方式改变**。
    *   当 `signed` 转 `unsigned` (或反之) 时，内存里的 **0/1 串完全不动**，只是 CPU 看它的眼光变了。
*   **例题 Q3 实战**：
    *   `short si = -32767`。
        *   原码：`1111...1111` (符号位1, 数值32767)。
        *   补码：`1000...0001` (0x8001)。
    *   `unsigned short usi = si`。
        *   内存里还是 `0x8001`。
        *   当无符号数读：$1 \times 2^{15} + 1 = 32768 + 1 = \mathbf{32769}$。

### 1.4 机器数运算实战 (Q4)
*   **题目**：$x = \text{FFFFFFDFH}, y = 00000041\text{H}$。求 $x, y$ 及 $x-y$ 的机器号。
*   **步骤 1：求真值**
    *   $x$ (负数)：取反加一。
        *   $\sim x = 00000020\text{H}$。
        *   $+1 = 00000021\text{H} = 33$。
        *   所以 $x = -33$。
    *   $y$ (正数)：直接读。$41\text{H} = 4 \times 16 + 1 = 65$。
*   **步骤 2：求差值**
    *   $x - y = -33 - 65 = -98$。
*   **步骤 3：求结果的机器号**
    *   $-98$ 的补码：
        *   $98 = 64 + 32 + 2 = 01100010$。
        *   $-98 = 10011101 + 1 = \mathbf{10011110}$ (`9EH`)。

---

# 模块三：指令系统与 CPU (Instruction Set & CPU)

## 1. 指令格式与寻址
### 1.1 零地址指令 (Zero-Address Instruction)
*   **应用场景**：**栈式计算机 (Stack Computer)** (如 Java 虚拟机)。
*   **特点**：指令中 **没有操作数地址** (如 `ADD`)。
*   **操作数来源**：默认来自 **栈顶 (Top of Stack)** 和 **次栈顶**。
*   **结果去向**：压回 **栈顶**。
*   *例题 Q8*：零地址指令的操作数来自？ => **栈顶和次栈顶**。

### 1.2 操作码扩展技术 (Opcode Expansion)
*   **原理**：利用低位地址码字段的空间，来增加高位操作码的数量。
*   **计算公式 (剩多少，乘多少)**：
    $$ N_{next} = (N_{total} - N_{used}) \times 2^{\text{AddrBits}} $$
*   **例题 Q9 实战**：
    *   32位指令，12位地址。250条二地址指令。
    *   剩余前缀 = $256 - 250 = 6$。
    *   单地址数量 = $6 \times 2^{12} = \mathbf{3 \times 2^{13}}$。

### 1.3 寻址方式 (Addressing Modes)
*   **立即寻址 (Immediate)**：操作数在指令中。**速度最快**。缺点：位数受限。
*   **直接寻址 (Direct)**：指令给有效地址 EA。
*   **间接寻址 (Indirect)**：指令给地址 A，EA = (A)。**最慢** (多次访存)。
*   **寄存器寻址 (Register)**：EA = R。无访存。
*   **寄存器间接寻址 (Register Indirect)**：EA = (R)。**比间接寻址快** (少一次访存)。
*   **变址寻址 (Indexed)**：EA = (IX) + A。**适合数组访问**。

## 2. CPU 结构与流水线
### 2.1 指令周期 (Instruction Cycle)
*   **四个阶段**：
    1.  **Fetch (取指)**：取指令，PC+1。
    2.  **Indirect (间址)**：取操作数有效地址 (如果需要)。
    3.  **Execute (执行)**：执行操作。
    4.  **Interrupt (中断)**：检查并响应中断。
*   **MBR 内容**：取指结束时，MBR 里是 **指令**。

### 2.2 流水线 (Pipeline)
*   **性能公式**：$T = (k + n - 1) \times \Delta t$。
*   **冒险 (Hazards)**：
    *   **结构冒险**：资源冲突 (如同时访存)。
    *   **数据冒险**：数据依赖 (RAW)。
    *   **控制冒险**：**条件分支 (Conditional Branch)** (最严重，需清空流水线)。
*   **超标量 (Superscalar)**：多条流水线并行发射。

### 2.3 RISC vs CISC
*   **RISC (精简指令集)**：
    *   指令简单，长度固定。
    *   **寻址方式少** (不搞复杂的间接寻址)。
    *   **寄存器多** (减少访存)。
    *   Load/Store 结构。

---

# 期末综合练习精选 (Final Comprehensive Review)
> *源自 `104-期末综合练习题.md`*

## 1. 核心概念速记
*   **存储程序**：冯·诺依曼提出。
*   **分支指令**：修改 **PC**。
*   **SRAM**：**6T** 结构；**DRAM**：1T1C。
*   **I/O**：中断请求发给 CPU；DMA 请求优先级 > 中断。
*   **总线**：同一时刻 **只能有一个** 主设备控制。

## 2. 易错计算题
*   **补码溢出 (Q23)**：$103 - (-25) = 128$ (溢出)。
*   **补码最小值 (Q14)**：3个1，5个0 => `10000011` (-125)。
*   **Cache 映射 (Q11)**：
    *   32行，4路 => 8组。
    *   地址 64，块 32 => 块号 2。
    *   组号 = $2 \pmod 8 = \mathbf{2}$。

## 3. 高级协议
*   **MESI 协议**：写失效 (Write-Invalidate)。写未命中时，其他 Cache 置 Invalid。
*   **RAID**：
    *   RAID 4/5/6：**独立访问** (高 I/O 率)。
    *   RAID 2/3：并行访问 (高带宽)。

---

# 补充复习资料 (Supplementary Review)
> *源自 `111/113-期末在线作业`*

## 1. 海明码计算 (Hamming Code)
*   **必考大题**：
    *   **校验位**：$1, 2, 4, 8$。
    *   **故障字 (Syndrome)**：$P_8 P_4 P_2 P_1$。
    *   **纠错**：故障字指出的位取反。

## 2. Cache 映射大题
*   **地址拆分**：
    *   **Offset**：由块大小决定 ($2^n \to n$位)。
    *   **Set**：由组数决定 ($2^m \to m$位)。
    *   **Tag**：剩余高位。
*   **例题**：256MB 内存, 4MB Cache, 64B 块, 2路。
    *   Offset=6, Set=15, Tag=7。

## 3. 中断全流程
1.  **Request**: I/O 发请求。
2.  **Acknowledge**: CPU 响应。
3.  **Save Context**: 压栈 **PC** 和 **PSW**。
4.  **Load ISR**: 加载入口地址。
5.  **Execute**: 服务。
6.  **Restore**: 弹栈。
7.  **Resume**: 返回。
