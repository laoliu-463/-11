# I/O 系统复习笔记 (I/O System Review Notes)

> **简介**：本笔记基于 `101-I-O系统练习题.md` 中的习题整理而成，提炼了核心考点与易错点。
> **来源**：习题解析整理
> **最后更新**：2025年1月

[TOC]

## 1. I/O 控制方式 (I/O Control Methods)

### 1.1 程序查询方式 (Programmed I/O / Polling)
*   **核心特征**：CPU **忙等 (Busy Waiting)**。
*   **工作流程**：CPU 向 I/O 模块发出命令后，进入一个循环，**定期读取并检查** I/O 模块的状态寄存器，直到操作完成。
*   **缺点**：CPU 效率极低，无法并行工作。
*   **考点**：“等待”意味着 CPU 在执行查询指令，并未停止运行。

### 1.2 中断驱动 I/O (Interrupt-driven I/O)
*   **核心特征**：**CPU 与外设并行工作**。
*   **工作流程**：
    1.  CPU 发出 I/O 命令后，继续执行其他程序。
    2.  I/O 模块准备好后，向 CPU 发送 **中断请求 (Interrupt Request)**。
    3.  CPU 在当前指令周期结束后响应中断，暂停当前程序，保存现场，跳转到 **中断服务程序 (ISR)**。
*   **关键点**：
    *   **中断请求信号**：是 I/O 发给 CPU 的，不是 I/O 模块与设备之间交换的信息。
    *   **中断响应时机**：指令执行周期结束时。

### 1.3 直接存储器访问 (DMA)
*   **核心特征**：**硬件接管总线，不经过 CPU**。
*   **工作流程**：
    1.  CPU 初始化 DMA 控制器（告知源/目地址、计数）。
    2.  DMA 控制器向 CPU 申请总线控制权 (**Bus Request**)。
    3.  获得总线后，DMA 直接控制内存与外设的数据传输。
    4.  传输结束（一整块数据传完）后，DMA 发送中断通知 CPU。
*   **关键技术**：**周期窃取 (Cycle Stealing)** —— DMA 优先占用存取周期。
*   **与中断的区别**：
    *   中断方式：CPU 参与数据搬运（指令级干预）。
    *   DMA 方式：CPU 不参与数据搬运（硬件级传输），仅在开始和结束参与。
    *   *注意*："直接 I/O 访问 (Direct I/O Access)" 不是标准的计算机组成原理 I/O 控制方式术语。
*   **DMA 效率更高的原因**：
    *   **减少中断次数**：DMA 仅在**整块**数据传输完成后中断一次；而中断驱动方式每传输一个**字**就要中断一次。
    *   **减少上下文切换开销**：中断次数减少 => 保存/恢复现场 (PC/寄存器) 的次数大幅减少。
    *   **无需指令干预**：数据传输由硬件直接完成，CPU 不需执行 `MOV` 等搬运指令。
*   **优先级比较**：**DMA 请求 > 中断请求**。
    *   *原因*：DMA 处理的是高速数据传输，若不及时响应会导致数据丢失（溢出）；而中断处理的是程序逻辑，晚一点响应后果较轻。

## 2. I/O 编址方式 (Addressing Modes)

### 2.1 统一编址 (Memory-Mapped I/O)
*   **原理**：I/O 端口占用内存地址空间。
*   **区分**：通过 **不同的地址范围** 来区分内存和 I/O。
*   **优点**：指令统一，编程灵活。
*   **缺点**：占用内存容量。

### 2.2 独立编址 (Isolated I/O)
*   **原理**：I/O 拥有独立的地址空间。
*   **区分**：通过 **专门的控制线** 和 **专用指令 (IN/OUT)**。

## 3. I/O 模块结构

*   **内部寄存器**：
    *   **控制寄存器 (Control Register)**：接收 CPU 命令。
    *   **状态寄存器 (Status Register)**：反馈设备状态 (Ready/Busy/Error)。
    *   **数据缓冲寄存器 (Data Buffer Register)**：暂存数据。
    *   *(注：指令寄存器 IR 和 内存地址寄存器 MAR 属于 CPU，不在 I/O 模块中)*

### 3.1 接口信号流向 (Signal Flow)
*   **模块 <-> 设备**：数据、控制、状态。
*   **模块 -> CPU**：中断请求 (INTR)。
*   *易错点*：设备不直接发中断给 CPU，也不发给模块（通常体现为状态位的变化）。

### 3.2 总线复用 (Bus Multiplexing)
*   **数据总线 (Data Bus)** 传输的内容不仅是数据，还包括：
    *   **命令词 (Command)**：CPU 发给 I/O 的指令。
    *   **状态字 (Status)**：I/O 发给 CPU 的状态。
    *   **中断类型号/向量 (Interrupt Vector)**：I/O 发给 CPU 的中断 ID。

## 4. 中断系统进阶

### 4.1 中断处理流程
1.  **中断请求**：外设 -> CPU。
2.  **中断判优**：硬件或软件决定响应哪个中断。
3.  **中断响应**：CPU 发送 **INTA (中断确认)** 信号，关中断，保存断点 (PC, PSW)。
    *   *时机*：指令执行周期结束时。
4.  **中断服务 (ISR)**：保护现场 (通用寄存器) -> 服务 -> 恢复现场。
5.  **中断返回**：恢复断点，开中断。

### 4.2 堆栈的作用
*   **保存现场 (Context Saving)**：
    *   **PC (程序计数器)**：记录下一条指令地址（硬件自动保存）。
    *   **PSW (程序状态字)**：记录状态标志（硬件自动保存）。
    *   **通用寄存器 (GPRs)**：记录中间计算结果（软件/ISR保存）。
*   **目的**：为了在中断处理结束后，能够准确地**恢复**原程序的执行状态。

### 4.3 中断优先级与掩码 (Mask)
*   **硬件优先级**：固定不可变。
*   **中断屏蔽字 (Mask)**：通过软件设置，可以动态改变**中断响应优先级**（实际是改变了处理顺序）。
*   **规则**：屏蔽位为 `1` 表示屏蔽（不响应），`0` 表示允许。

### 4.4 中断掩码与多重中断计算 (必考大题)
*   **掩码字计算公式**：
    *   对于某个中断源 $i$，其掩码字 $M_i$ 应屏蔽掉：
        1.  **自身** (避免递归)。
        2.  所有**目标优先级**比 $i$ 低的中断源。
*   **多重中断时间轴画法**：
    *   **抢占原则**：新中断优先级 > 当前正在执行的中断优先级 => **立即抢占**（嵌套）。
    *   **等待原则**：新中断优先级 < 当前正在执行的中断优先级 => **等待**当前中断结束。
    *   **恢复原则**：中断结束 -> 返回上一层（可能是主程序，也可能是被中断的低优先级 ISR）。

---

# 模块二：存储系统 (Memory System)

## 1. 基础概念

### 1.1 寻址范围 (Addressing Range)
*   **公式**：$N = 2^k$
    *   $k$：地址线位数 (Address bits)。
    *   $N$：可寻址的单元总数 (Total addressable units)。
*   **单位换算**：
    *   $2^{10} = 1K = 1,024$
    *   $2^{20} = 1M = 1,048,576$
    *   $2^{30} = 1G = 1,073,741,824$
    *   $2^{32} = 2^2 \times 2^{30} = 4 \times 1G = 4G$
*   **易错点**：
    *   地址是**无符号整数 (Unsigned Integer)**，范围从 0 到 $2^k-1$。
    *   不存在负数地址（排除 -2G 到 2G 这种选项）。

### 1.2 冯·诺依曼架构 (Von Neumann Architecture)
*   **五大特点**：
    1.  **二进制**：指令和数据均以二进制形式表示。
    2.  **存储程序**：程序和数据预先存入内存。
    3.  **顺序执行**：指令按序执行。
    4.  **不区分指令/数据**：在内存中无区别，靠 CPU **访问阶段** (取指 vs 执行) 来区分。
    5.  **五大部件**：运算器、控制器、存储器、输入设备、输出设备。

### 1.3 指令周期 (Instruction Cycle)
*   **最简形式**：**取指 (Fetch)** + **执行 (Execute)**。
*   **完整形式**：取指 -> 间接 (Indirect) -> 执行 -> 中断 (Interrupt)。

### 1.4 字长 (Word Length)
*   **定义**：CPU 一次能处理的二进制数据的位数。
*   **单位换算**：
    *   1 Byte (字节) = 8 bits (位)。
    *   4B = 32 bits。
*   **意义**：字长决定了 CPU 的运算精度和通用寄存器的宽度。

### 1.5 存储层次结构 (Memory Hierarchy)
*   **定义**：计算机内存系统不仅仅是内存条，而是一个多级层次结构。
*   **金字塔结构** (从上到下：速度变慢，容量变大，价格变低)：
    1.  **寄存器 (Registers)**：CPU 内部，最快。
    2.  **高速缓存 (Cache)**：SRAM，缓解 CPU 与主存速度差异。
    3.  **主存储器 (Main Memory)**：DRAM，存放运行中的程序和数据。
    4.  **辅助存储器 (Auxiliary Memory)**：磁盘/SSD，永久存储。

### 1.6 CPU 访问权限 (CPU Access)
*   **直接访问**：寄存器、Cache、主存 (Main Memory)。
    *   CPU 可以通过地址总线直接读写这些存储器中的数据。
*   **无法直接访问**：辅助存储器 (硬盘/SSD/光盘)。
    *   **必须先加载到主存**：CPU 想要处理硬盘上的数据，必须先由 I/O 系统（如 DMA）把数据搬到内存里，CPU 才能从内存里读。

## 2. Cache 存储系统 (Cache Memory)

### 2.1 映射方式 (Mapping Techniques)
*   **全相联映射 (Associative Mapping)**：
    *   **规则**：主存的**任意一块**可以映射到 Cache 的**任意一行**。
    *   **特点**：灵活性最高，冲突概率最低，但比较电路最复杂（成本高）。
    *   **适用**：小容量 Cache。

### 2.2 Cache 参数计算 (Calculation)
*   **行数计算公式**：
    $$ \text{行数 (Lines)} = \frac{\text{Cache 总容量 (Cache Size)}}{\text{行大小 (Line Size)}} $$
*   **注意单位统一**：
    *   通常将容量和行大小都换算成 **Byte (字节)**。
    *   1 Word (字) = 4 Bytes (通常情况，除非题目另有说明)。

### 2.3 寻址方式与容量计算 (Addressing Calculation)
*   **核心公式**：
    $$ \text{可寻址单元数} = \frac{\text{总容量 (Total Capacity)}}{\text{编址单位大小 (Unit Size)}} $$
*   **常见单位**：
    *   **按字节编址 (Byte Addressing)**：Unit Size = 1 Byte。
    *   **按字编址 (Word Addressing)**：Unit Size = 字长 (Word Length)。
    *   **按半字编址 (Half-word Addressing)**：Unit Size = 字长 / 2。
*   **例题 Q8 实战**：
    *   容量 16MB ($2^{24}$ B)，字长 32位 (4B)。
    *   半字大小 = 2B。
    *   单元数 = $2^{24} / 2 = 2^{23}$。

### 2.4 组相联映射计算 (Set Associative Calculation)
*   **组数 (Sets) 计算**：
    $$ \text{组数} = \frac{\text{Cache 总行数}}{\text{路数 (Ways)}} $$
*   **组索引 (Set Index) 计算**：
    1.  先算**主存块号 (Block Address)**：$\lfloor \text{内存地址} / \text{块大小} \rfloor$
    2.  再算**组号**：$\text{主存块号} \pmod{\text{组数}}$
*   **例题 Q9 实战**：
    *   16 行，2 路 => 8 组。
    *   地址 129，块大小 32B => 块号 = $129 // 32 = 4$。
    *   地址 129，块大小 32B => 块号 = $129 // 32 = 4$。
    *   组号 = $4 \pmod 8 = 4$。

### 2.5 写策略 (Write Policy)
*   **通写式 (Write-through)**：
    *   **原理**：数据同时写入 Cache 和主存。
    *   **优点**：实现简单，主存与 Cache 数据时刻保持一致。
    *   **缺点**：写操作慢（受限于主存速度），总线流量大。
*   **写回式 (Write-back)**：
    *   **原理**：数据只写入 Cache，只有当该行被**替换**出去时，才写回主存。
    *   **优点**：写操作快（只写 Cache），减少总线流量。
    *   **缺点**：控制复杂，需要 **Dirty Bit (脏位)** 标记是否被修改过。

### 2.6 映射方式的统一视角 (Unified View)
*   假设 Cache 总行数为 $M$，每组行数（路数）为 $K$：
    *   **直接映射 (Direct Mapping)**：$K = 1$ (每组只有 1 行，对号入座)。
    *   **全相联映射 (Fully Associative)**：$K = M$ (只有 1 个组，包含所有行，随意停)。
    *   **组相联映射 (Set Associative)**：$1 < K < M$ (折中方案)。

## 3. 存储器类型 (Memory Types)

### 3.1 RAM (随机存取存储器)
*   **易失性 (Volatile)**：断电后数据丢失。
*   **SRAM (静态 RAM)**：
    *   速度快，价格贵，集成度低。
    *   用途：**Cache**。
    *   原理：触发器 (Flip-flop)，无需刷新。
*   **DRAM (动态 RAM)**：
    *   速度慢，价格便宜，集成度高。
    *   用途：**主存 (Main Memory)**。
    *   原理：电容 (Capacitor)，需要**定期刷新 (Refresh)**。

### 3.2 ROM (只读存储器)
*   **非易失性 (Non-volatile)**：断电后数据不丢失。
*   **PROM (可编程 ROM)**：一次性写入，**写完后不可更改** (Permanent)。
*   **EPROM (可擦除 PROM)**：可用紫外线擦除并重写。
*   **EEPROM / Flash**：可用电擦除并重写 (如 SSD, U盘)。
