# 10-寻址方式

> 指令中如何指定操作数的位置  
> 最后更新：2025年1月

---

## 📑 目录

- [一、什么是寻址方式？](#一什么是寻址方式)
- [二、8种基本寻址方式](#二8种基本寻址方式)
- [三、寻址方式对比](#三寻址方式对比)
- [四、实际应用](#四实际应用)a
- [五、总结](#五总结)

---

## 一、什么是寻址方式？

### 定义

**定义：** 寻址方式是指指令中如何指定操作数的位置，包括立即寻址、寄存器寻址、直接寻址、间接寻址等多种方式。

**通俗理解：** 寻址方式就像"如何找到操作数"，就像快递地址的不同格式（门牌号、坐标、参照物）对应不同的寻址方式。

### 核心要点

```
寻址方式 = 告诉CPU去哪里找数据

类比：
  立即寻址 = 地址直接写在快递单上
  寄存器寻址 = 数据在快递柜里
  直接寻址 = 直接给门牌号
  间接寻址 = 先到一个地址，再找真正的地址
```

---

## 二、8种基本寻址方式

### 1. 立即寻址 (Immediate Addressing)

**通俗理解：** 立即寻址就像"操作数就在指令里"，操作数直接包含在指令中，无需访问内存、执行速度快，但立即数范围受限。

```
格式: 操作码 + 立即数

示例: MOV R0, #100
  ┌──────────┬──────────────┐
  │ 操作码   │  立即数100   │
  └──────────┴──────────────┘
         │
         └─→ 操作数=100（直接使用）

特点:
  ✓ 操作数在指令中，无需访问内存
  ✓ 执行速度快
  ✗ 立即数范围受限（指令长度限制）

有效地址: 无（数据直接给出）
```

### 2. 寄存器寻址 (Register Addressing)

**通俗理解：** 寄存器寻址就像"操作数在寄存器里"，操作数在寄存器中，访问速度最快、不需要访问内存，但寄存器数量有限。

```
格式: 操作码 + 寄存器号

示例: ADD R0, R1, R2
  ┌──────────┬──────┬──────┐
  │ 操作码   │ R1   │ R2   │
  └──────────┴──────┴──────┘
         │      │      │
         │      └──────┼─→ 从寄存器读取
         └─────────────┘

特点:
  ✓ 访问速度最快（寄存器在CPU内部）
  ✓ 不需要访问内存
  ✗ 寄存器数量有限

有效地址: 无（数据在寄存器中）
```

### 3. 直接寻址 (Direct Addressing)

**通俗理解：** 直接寻址就像"直接给门牌号"，地址直接包含在指令中，可以访问任意内存位置，但指令较长。

```
格式: 操作码 + 内存地址

示例: LOAD R0, [0x1000]
  ┌──────────┬──────────────┐
  │ 操作码   │  地址0x1000  │
  └──────────┴──────────────┘
         │
         └─→ 从内存0x1000读取

特点:
  ✓ 可以访问任意内存位置
  ✗ 指令较长（需要包含完整地址）
  ✗ 地址空间受限（受指令长度限制）

有效地址: EA = 指令中的地址
```

### 4. 寄存器间接寻址 (Register Indirect Addressing)

**通俗理解：** 寄存器间接寻址就像"寄存器里存的是地址"，寄存器中存储的是内存地址，通过寄存器找到真正的数据。

```
格式: 操作码 + 寄存器（存地址）

示例: LOAD R0, [R1]
  ┌──────────┬──────┐
  │ 操作码   │ R1   │
  └──────────┴──────┘
         │      │
         │      └─→ R1中存的是地址
         │          └─→ 从该地址读取数据

特点:
  ✓ 地址可变（通过修改寄存器）
  ✓ 指令短（只需寄存器号）
  ✓ 适合访问数组、指针

有效地址: EA = R[寄存器]
```

### 5. 基址寻址 (Base Addressing)

**通俗理解：** 基址寻址就像"基址+偏移量"，用基址寄存器（如栈指针）加上偏移量来访问数据，适合访问局部变量、数组元素。

```
格式: 操作码 + 基址寄存器 + 偏移量

示例: LOAD R0, [R1 + #100]
  ┌──────────┬──────┬────────┐
  │ 操作码   │ R1   │ 偏移100│
  └──────────┴──────┴────────┘
         │      │      │
         │      └──────┼─→ 基址 + 偏移 = 地址
         │             │
         └─────────────┘

特点:
  ✓ 适合访问局部变量（基址=栈指针）
  ✓ 适合访问数组（基址=数组首地址）
  ✓ 地址可计算

有效地址: EA = 基址寄存器 + 偏移量
```

### 6. 变址寻址 (Index Addressing)

**通俗理解：** 变址寻址就像"基址+变址寄存器"，用固定基址加上变址寄存器（索引）来访问数据，适合访问数组元素。

```
格式: 操作码 + 基址 + 变址寄存器

示例: LOAD R0, [0x1000 + R2]
  ┌──────────┬────────┬──────┐
  │ 操作码   │ 0x1000 │ R2   │
  └──────────┴────────┴──────┘
         │      │      │
         │      └──────┼─→ 基址 + 变址 = 地址
         │             │
         └─────────────┘

特点:
  ✓ 适合访问数组（R2=索引）
  ✓ 地址可计算
  ✓ 灵活（索引可变）

有效地址: EA = 基址 + 变址寄存器
```

### 7. 相对寻址 (Relative Addressing)

**通俗理解：** 相对寻址就像"相对于当前位置的偏移"，用程序计数器（PC）加上偏移量来访问数据，适合跳转指令、访问代码段数据。

```
格式: 操作码 + 偏移量

示例: BEQ offset  (如果相等，跳转到PC+offset)
  ┌──────────┬──────────────┐
  │ 操作码   │  偏移量      │
  └──────────┴──────────────┘
         │      │
         │      └─→ PC + offset = 目标地址
         │
         └─→ 当前PC值

特点:
  ✓ 指令短（只需偏移量）
  ✓ 代码可重定位（相对地址）
  ✓ 适合跳转指令

有效地址: EA = PC + 偏移量
```

### 8. 栈寻址 (Stack Addressing)

**通俗理解：** 栈寻址就像"通过栈指针访问"，通过栈指针（SP）访问栈中的数据，适合函数调用、参数传递。

```
格式: 操作码 + 栈操作

示例: PUSH R0, POP R1
  PUSH: SP ← SP - 4, M[SP] ← R0
  POP:  R1 ← M[SP], SP ← SP + 4

特点:
  ✓ 适合函数调用（保存/恢复寄存器）
  ✓ 适合参数传递
  ✓ LIFO（后进先出）

有效地址: EA = SP（栈指针）
```

---

## 三、寻址方式对比

### 对比表

| 寻址方式 | 有效地址计算 | 优点 | 缺点 | 应用 |
|---------|------------|------|------|------|
| **立即寻址** | 无（数据在指令中） | 速度快 | 范围受限 | 常量赋值 |
| **寄存器寻址** | 无（数据在寄存器） | 最快 | 数量有限 | 寄存器运算 |
| **直接寻址** | EA = 指令中的地址 | 简单直接 | 地址空间受限 | 全局变量 |
| **寄存器间接** | EA = R[寄存器] | 地址可变 | 需先加载地址 | 指针、数组 |
| **基址寻址** | EA = 基址 + 偏移 | 灵活 | 需基址寄存器 | 局部变量 |
| **变址寻址** | EA = 基址 + 变址 | 适合数组 | 需变址寄存器 | 数组访问 |
| **相对寻址** | EA = PC + 偏移 | 代码可重定位 | 范围受限 | 跳转指令 |
| **栈寻址** | EA = SP | 适合函数调用 | 只能访问栈顶 | 函数调用 |

### 寻址方式选择

```
选择原则：
  • 常量 → 立即寻址
  • 频繁使用的数据 → 寄存器寻址
  • 全局变量 → 直接寻址
  • 数组元素 → 变址寻址或基址寻址
  • 局部变量 → 基址寻址（基址=栈指针）
  • 跳转指令 → 相对寻址
  • 函数调用 → 栈寻址
```

---

## 四、实际应用

### 数组访问

**示例：访问 array[i]**

```
使用变址寻址：
  • 基址 = array的首地址（0x1000）
  • 变址 = i（索引）
  • 地址 = 0x1000 + i × 4（每个元素4字节）

指令序列：
  LOAD R1, #0x1000      // 基址
  LOAD R2, i            // 索引
  SLL R2, R2, #2        // i × 4（左移2位）
  ADD R1, R1, R2        // 计算地址
  LOAD R0, [R1]         // 读取array[i]
```

### 函数参数传递

**示例：通过栈传递参数**

```
调用函数：
  PUSH param1    // 参数1入栈
  PUSH param2    // 参数2入栈
  CALL function  // 调用函数

函数内部：
  LOAD R0, [SP + 8]  // 访问参数1（基址寻址）
  LOAD R1, [SP + 4]  // 访问参数2
```

---

## 五、总结

### 核心要点

```
✅ 寻址方式 = 告诉CPU去哪里找数据
✅ 8种基本寻址方式：立即、寄存器、直接、间接、基址、变址、相对、栈
✅ 不同寻址方式适用于不同场景
✅ 有效地址计算方式不同
✅ 选择合适的寻址方式可以提高效率
```

### 关键理解

- **立即寻址**：数据在指令中，最快但范围受限
- **寄存器寻址**：数据在寄存器，最快但数量有限
- **直接寻址**：地址在指令中，简单但空间受限
- **间接寻址**：通过地址找地址，灵活但需额外访问
- **基址/变址**：适合数组和局部变量
- **相对寻址**：适合跳转，代码可重定位
- **栈寻址**：适合函数调用

### 选择指南

```
常量 → 立即寻址
频繁使用 → 寄存器寻址
全局变量 → 直接寻址
数组 → 变址/基址寻址
局部变量 → 基址寻址
跳转 → 相对寻址
函数调用 → 栈寻址
```

---

**最后更新：** 2025年1月


