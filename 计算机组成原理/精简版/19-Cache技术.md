# 19-Cache技术

> Cache映射、替换算法、写策略、性能分析  
> 最后更新：2025年1月

---

## 📑 目录

- [一、什么是Cache？](#一什么是cache)
- [二、Cache映射方式](#二cache映射方式)
- [三、替换算法](#三替换算法)
- [四、写策略](#四写策略)
- [五、Cache性能](#五cache性能)
- [六、总结](#六总结)

---

## 一、什么是Cache？

### 定义

**定义：** Cache（高速缓存）是位于CPU和主存之间的高速存储器，用于存储最近访问的数据，提高访问速度。

**通俗理解：** Cache就像"桌子上的常用文件夹"，把最常用的数据放在CPU附近，这样访问时就不需要跑到远处的"大仓库"（主存）去拿，大大提高了速度。

### Cache工作流程

```
CPU访存请求
    ↓
查找Cache
    ↓
┌────┴────┐
│  命中?   │
└────┬────┘
是 ↙   ↘ 否
  ↓      ↓
直接返回  访问主存
(快)     (慢)
         ↓
      加载到Cache
```

### Cache结构

```
Cache行（Cache Line）结构：
┌──────┬──────┬──────┬──────────┐
│ Tag  │Valid │Dirty │   Data   │
└──────┴──────┴──────┴──────────┘
标记位  有效位  脏位    数据块

• Tag：标记，用于匹配
• Valid：有效位，表示数据是否有效
• Dirty：脏位，表示数据是否被修改
• Data：实际数据块
```

---

## 二、Cache映射方式

### 映射方式总览

**通俗理解：** 映射方式决定"主存的块放在Cache的哪里"，就像"图书馆的书放在哪个书架"。

```
三种映射方式：
  1. 直接映射：一个地址只能放在一个固定位置
  2. 组相联：一个地址可以放在一组中的任意位置
  3. 全相联：一个地址可以放在任意位置
```

### 1. 直接映射 (Direct Mapped)

**通俗理解：** 就像"一个地址只能放在一个固定位置"，简单但可能冲突。

```
映射规则：
  主存块 i → Cache行 (i % Cache行数)

地址划分：
┌─────┬───────┬───────┐
│ Tag │ Index │Offset │
└─────┴───────┴───────┘
标记   索引    偏移

示例：
  Cache有8行（Index 3位）
  主存块0 → Cache行0
  主存块8 → Cache行0（冲突！）
  主存块1 → Cache行1

优点：
  ✓ 简单，硬件成本低
  ✓ 查找快（直接定位）

缺点：
  ✗ 容易冲突（多个块映射到同一行）
  ✗ 命中率较低
```

### 2. 组相联映射 (Set-Associative) ⭐常用

**通俗理解：** 就像"一个地址可以放在一组中的任意位置"，更灵活，冲突少。

```
映射规则：
  主存块 i → 第(i % 组数)组
         → 组内N个位置任选（N路组相联）

地址划分：
┌─────┬───────┬───────┐
│ Tag │ Index │Offset │
└─────┴───────┴───────┘
标记   组号    偏移

示例（4路组相联）：
  Cache有8组，每组4行
  主存块0 → 组0（组内4个位置任选）
  主存块8 → 组0（组内4个位置任选，不冲突）
  主存块1 → 组1

优点：
  ✓ 灵活，冲突少
  ✓ 命中率较高
  ✓ 平衡了复杂度和性能

缺点：
  ✗ 硬件复杂度中等
  ✗ 需要替换算法
```

### 3. 全相联映射 (Full-Associative)

**通俗理解：** 就像"一个地址可以放在任意位置"，最灵活，但硬件复杂。

```
映射规则：
  主存块 i → Cache任意位置

地址划分：
┌─────┬───────┐
│ Tag │Offset │
└─────┴───────┘
标记   偏移

示例：
  主存块可以放在Cache任意行
  需要比较所有行的Tag

优点：
  ✓ 最灵活，冲突最少
  ✓ 命中率最高

缺点：
  ✗ 硬件复杂（需要比较所有行）
  ✗ 成本高
  ✗ 速度慢（查找时间长）
```

### 映射方式对比

| 映射方式 | 地址划分 | 优点 | 缺点 | 应用 |
|---------|---------|------|------|------|
| **直接映射** | Tag-Index-Offset | 简单、快速 | 冲突多 | 小Cache |
| **组相联** | Tag-Index-Offset | 平衡性能 | 中等复杂度 | 常用 |
| **全相联** | Tag-Offset | 冲突少 | 复杂、慢 | 小Cache |

---

## 三、替换算法

### 什么是替换算法？

**通俗理解：** 当Cache满了，需要替换旧数据时，替换算法决定"替换哪个"，就像"书架满了，决定扔掉哪本书"。

### LRU (Least Recently Used) ⭐最常用

**通俗理解：** 替换"最长时间未使用的"，就像"扔掉最久没看的书"。

```
原理：
  记录每行的访问时间
  替换最久未访问的行

实现：
  • 使用计数器：访问时计数器=0，其他行+1
  • 使用访问时间：记录最后访问时间
  • 使用矩阵：记录访问顺序

优点：
  ✓ 符合局部性原理
  ✓ 命中率较高

缺点：
  ✗ 硬件实现较复杂
```

### FIFO (First In First Out)

**通俗理解：** 替换"最早进入的"，就像"先来的先走"。

```
原理：
  记录每行的进入顺序
  替换最早进入的行

实现：
  • 使用队列：新行加入队尾，替换队头

优点：
  ✓ 实现简单

缺点：
  ✗ 可能替换常用数据
  ✗ 命中率较低
```

### 随机替换 (Random)

**通俗理解：** 随机选择一个替换，就像"随机扔一本书"。

```
原理：
  随机选择一行替换

优点：
  ✓ 实现最简单

缺点：
  ✗ 命中率最低
  ✗ 性能不稳定
```

### 替换算法对比

| 算法 | 原理 | 优点 | 缺点 | 命中率 |
|------|------|------|------|--------|
| **LRU** | 最久未使用 | 符合局部性 | 实现复杂 | 高 |
| **FIFO** | 先进先出 | 实现简单 | 可能替换常用数据 | 中 |
| **随机** | 随机选择 | 最简单 | 性能差 | 低 |

---

## 四、写策略

### 什么是写策略？

**通俗理解：** 写策略决定"写入数据时如何处理Cache和主存"，就像"记笔记时，是只记在本子上，还是同时记在电脑上"。

### 写回 (Write-Back) ⭐性能好

**通俗理解：** 就像"先记在本子上，最后再整理"，只写Cache，需要时才写回主存，快但复杂。

```
策略：
  • 只写Cache，置dirty位
  • 替换时才写回主存（如果dirty）

流程：
  写入 → Cache（dirty=1）→ 替换时 → 主存

优点：
  ✓ 性能好（减少主存访问）
  ✓ 适合写操作多的场景

缺点：
  ✗ 需要dirty位
  ✗ 替换时需要写回
  ✗ 一致性复杂
```

### 写直达 (Write-Through)

**通俗理解：** 就像"同时记在本子和电脑上"，同时写Cache和主存，一致性好但慢。

```
策略：
  • 同时写Cache和主存
  • 立即更新主存

流程：
  写入 → Cache + 主存（同时）

优点：
  ✓ 一致性好
  ✓ 实现简单

缺点：
  ✗ 性能差（每次都要写主存）
  ✗ 主存带宽压力大
```

### 写策略对比

| 策略 | 写入位置 | 优点 | 缺点 | 应用 |
|------|---------|------|------|------|
| **写回** | 只写Cache | 性能好 | 一致性复杂 | 常用 |
| **写直达** | Cache+主存 | 一致性好 | 性能差 | 小Cache |

---

## 五、Cache性能

### 核心性能指标

```
【平均访存时间 AMAT】
AMAT = 命中时间 + 缺失率 × 缺失惩罚
     = HitTime + MissRate × MissPenalty

【有效访问时间】
有效访问时间 = 命中率 × Cache访问时间 
             + (1-命中率) × 主存访问时间
             = HitRate × CacheTime + (1-HitRate) × MemoryTime

【命中率与缺失率】
命中率 = 命中次数 / 总访问次数
缺失率 = 1 - 命中率 = 缺失次数 / 总访问次数
```

### 性能计算示例

**示例1：基本AMAT计算**

```
假设：
  Cache访问时间 = 1ns
  Cache命中率 = 95%
  主存访问时间 = 100ns

计算：
  缺失率 = 1 - 0.95 = 0.05
  AMAT = 1 + 0.05 × 100 = 6ns

vs 无Cache: 100ns
加速比: 100/6 ≈ 16.7倍
```

**示例2：多级Cache**

```
假设：
  L1 Cache: 1ns, 命中率90%
  L2 Cache: 5ns, 命中率95%（L1缺失时）
  主存: 100ns

计算：
  L1命中: 1ns
  L1缺失但L2命中: 5ns
  L1和L2都缺失: 100ns
  
  AMAT = 0.9 × 1 + 0.1 × 0.95 × 5 + 0.1 × 0.05 × 100
       = 0.9 + 0.475 + 0.5
       = 1.875ns
```

### 影响Cache性能的因素

```
1. Cache大小
   • 越大，命中率越高，但成本越高

2. 块大小
   • 越大，空间局部性越好，但缺失惩罚越大

3. 相联度
   • 越高，冲突越少，但硬件越复杂

4. 替换算法
   • LRU通常最好，但实现复杂

5. 写策略
   • 写回性能好，写直达一致性好
```

---

## 六、总结

### 核心要点

```
✅ Cache = CPU和主存之间的高速缓存
✅ 三种映射：直接、组相联、全相联
✅ 替换算法：LRU最常用
✅ 写策略：写回性能好，写直达一致性好
✅ 性能指标：AMAT = 命中时间 + 缺失率 × 缺失惩罚
```

### 关键理解

- **Cache**通过存储常用数据提高访问速度
- **映射方式**决定主存块放在Cache哪里
- **替换算法**决定替换哪个旧数据
- **写策略**决定写入时如何处理
- **AMAT**是衡量Cache性能的关键指标

### 优化建议

```
提高命中率：
  • 增大Cache容量
  • 提高相联度
  • 使用LRU替换算法
  • 优化程序访问模式（提高局部性）

降低缺失惩罚：
  • 使用多级Cache
  • 增大块大小（但要权衡）
  • 预取技术
```

---

**最后更新：** 2025年1月


