# 06-二进制运算

> 二进制加法、减法、乘法、除法算法  
> 最后更新：2025年1月

---

## 📑 目录

- [一、二进制加法](#一二进制加法)
- [二、二进制减法](#二二进制减法)
- [三、二进制乘法](#三二进制乘法)
- [四、二进制除法](#四二进制除法)
- [五、快速算法](#五快速算法)
- [六、总结](#六总结)

---

## 一、二进制加法

### 基本规则

**通俗理解：** 二进制加法就像"十进制加法的简化版"，只有0和1，规则更简单。

```
基本规则：
  0 + 0 = 0
  0 + 1 = 1
  1 + 0 = 1
  1 + 1 = 10（进位1）

类比：
  就像十进制：5 + 5 = 10（进位1）
  二进制：1 + 1 = 10（进位1）
```

### 加法示例

**示例1：5 + 3 = 8**

```
    101  (5)
  +  11  (3)
  -----
   1000  (8)

逐位计算：
  第0位：1 + 1 = 10（写0，进1）
  第1位：0 + 1 + 1 = 10（写0，进1）
  第2位：1 + 0 + 1 = 10（写0，进1）
  第3位：0 + 0 + 1 = 1（写1）
  结果：1000₂ = 8
```

**示例2：13 + 7 = 20**

```
    1101  (13)
  +  111  (7)
  ------
   10100  (20)

逐位计算：
  第0位：1 + 1 = 10（写0，进1）
  第1位：0 + 1 + 1 = 10（写0，进1）
  第2位：1 + 1 + 1 = 11（写1，进1）
  第3位：1 + 0 + 1 = 10（写0，进1）
  第4位：0 + 0 + 1 = 1（写1）
  结果：10100₂ = 20
```

### 全加器

**通俗理解：** 全加器就像"计算器的一个按键"，能处理两个数加上一个进位。

```
全加器功能：
  输入：A, B, Cin（进位输入）
  输出：S（和）, Cout（进位输出）

真值表：
  A  B  Cin |  S  Cout
  ─────────┼─────────
  0  0   0  |  0   0
  0  0   1  |  1   0
  0  1   0  |  1   0
  0  1   1  |  0   1
  1  0   0  |  1   0
  1  0   1  |  0   1
  1  1   0  |  0   1
  1  1   1  |  1   1

公式：
  S = A ⊕ B ⊕ Cin
  Cout = (A ∧ B) ∨ (Cin ∧ (A ⊕ B))
```

---

## 二、二进制减法

### 基本规则

**通俗理解：** 二进制减法可以通过补码转换为加法，就像"用加法做减法"。

```
基本规则：
  0 - 0 = 0
  0 - 1 = 1（借位1）
  1 - 0 = 1
  1 - 1 = 0

补码减法：
  A - B = A + (-B) = A + B的补码
```

### 减法示例

**示例1：8 - 3 = 5**

```
方法1：直接减法
    1000  (8)
  -  0011  (3)
  -----
     0101  (5)

方法2：补码加法
  8 - 3 = 8 + (-3)
  -3的补码 = 1111 1101
    1000  (8)
  + 1101  (-3的补码)
  -----
   1 0101  (5，忽略最高位进位)
```

**示例2：5 - 7 = -2**

```
使用补码：
  5 - 7 = 5 + (-7)
  -7的补码 = 1111 1001
    0101  (5)
  + 1001  (-7的补码)
  -----
   1110  (-2的补码)
  
  验证：1110的补码 = 0010 = 2，所以1110 = -2 ✓
```

---

## 三、二进制乘法

### 乘法原理

**通俗理解：** 二进制乘法就像"简化版的十进制乘法"，因为只有0和1，所以规则很简单：乘数某位是1就写被乘数，是0就写0，然后左移对齐，最后加起来。

```
核心思想:
  • 乘数为1 → 写被乘数
  • 乘数为0 → 写0
  • 每次左移一位
  • 所有部分积相加

关键公式:
  A × B = Σ(A << i), 当B的第i位为1
```

### 乘法示例

**示例1：5 × 3 = 15**

```
      101  (5)
    ×  11  (3)
    -----
      101  (5×1，位置0)
     101   (5×1，位置1，左移1位)
    -----
     1111  (15) ✓

分析:
  第0位是1: 101 (5)
  第1位是1: 1010 (10，左移1位)
  相加: 5 + 10 = 15 ✓
```

**示例2：6 × 5 = 30**

```
      110  (6)
    ×  101  (5)
    ------
      110  (6×1，位置0)
     000   (6×0，位置1)
    110    (6×1，位置2，左移2位)
   ------
    11110  (30) ✓

验证: 6 + 0 + 24 = 30 ✓
```

### 乘法算法

```
算法步骤：
  1. 初始化：乘积 = 0
  2. 逐位检查乘数：
     • 如果当前位是1：乘积 += 被乘数
     • 被乘数左移1位（相当于×2）
     • 乘数右移1位（检查下一位）
  3. 重复直到乘数为0

示例：5 × 3
  初始：乘积=0, 被乘数=5, 乘数=3
  
  第0位：乘数=3(11₂)，最低位=1
    → 乘积 += 5 = 5
    → 被乘数 << 1 = 10
    → 乘数 >> 1 = 1
  
  第1位：乘数=1(1₂)，最低位=1
    → 乘积 += 10 = 15
    → 被乘数 << 1 = 20
    → 乘数 >> 1 = 0
  
  结束：乘积 = 15 ✓
```

---

## 四、二进制除法

### 除法原理

**通俗理解：** 二进制除法就像"长除法"，通过试商和减法来完成。

```
核心思想:
  • 从高位开始
  • 试商：被除数能否减去除数
  • 能减：商为1，做减法
  • 不能减：商为0，不减
  • 左移，继续下一位
```

### 恢复余数除法

**通俗理解：** 就像"先试减，不行就恢复"，先尝试减法，如果不够减就恢复原值。

```
算法步骤：
  1. 初始化：余数 = 被除数，商 = 0
  2. 循环（位数次）：
     a. 余数左移1位
     b. 余数 -= 除数
     c. 如果余数 >= 0：
        • 商左移1位，商 += 1
     d. 否则：
        • 余数 += 除数（恢复）
        • 商左移1位，商 += 0
  3. 结果：商和余数
```

### 除法示例

**示例1：13 ÷ 3 = 4 余 1**

```
被除数：1101 (13)
除数：   11 (3)

步骤：
  1. 余数=1101，商=0
  2. 余数左移：11010
     余数-除数：11010 - 11 = 10111（负数，恢复）
     商=0
  3. 余数左移：11010
     余数-除数：11010 - 11 = 10111（负数，恢复）
     商=00
  4. 余数左移：11010
     余数-除数：11010 - 11 = 10111（负数，恢复）
     商=000
  5. 余数左移：11010
     余数-除数：11010 - 11 = 10111（负数，恢复）
     商=0000
  6. 余数左移：11010
     余数-除数：11010 - 11 = 10111（负数，恢复）
     商=00000

简化计算：
  13 ÷ 3 = 4 余 1
  验证：3 × 4 + 1 = 13 ✓
```

### 不恢复余数除法（更快）

**通俗理解：** 就像"不恢复，直接继续"，如果不够减，直接继续下一位，最后统一处理。

```
算法步骤：
  1. 初始化：余数 = 被除数，商 = 0
  2. 循环（位数次）：
     a. 余数左移1位
     b. 如果余数 >= 0：
        • 余数 -= 除数
        • 商左移1位，商 += 1
     c. 否则：
        • 余数 += 除数
        • 商左移1位，商 += 0
  3. 如果余数 < 0：余数 += 除数（最后恢复）
  4. 结果：商和余数
```

---

## 五、快速算法

### Booth算法（快速乘法）

**通俗理解：** Booth算法就像"智能乘法"，通过识别连续的1来减少运算次数。

```
原理：
  识别乘数中的连续1：
    ...0111... = ...1000... - ...0001...
  
  例如：0111 = 1000 - 0001
  所以：A × 0111 = A × 1000 - A × 0001
       = A << 3 - A

优势：
  • 减少部分积的数量
  • 提高乘法速度
```

### 快速除法优化

```
优化方法：
  1. 使用查找表：预计算常用除法
  2. 牛顿迭代法：快速求倒数，然后乘法
  3. 硬件除法器：专用硬件加速

示例（牛顿迭代法求倒数）：
  求 1/x：
    y₀ = 初始估计
    yₙ₊₁ = yₙ × (2 - x × yₙ)
  
  然后：a ÷ x = a × (1/x)
```

---

## 六、总结

### 核心要点

```
✅ 加法：逐位相加，处理进位
✅ 减法：通过补码转换为加法
✅ 乘法：部分积相加，左移对齐
✅ 除法：试商减法，恢复或不恢复余数
✅ 快速算法：Booth算法、牛顿迭代法等
```

### 关键理解

- **加法**：逐位相加，处理进位，可以用全加器实现
- **减法**：通过补码转换为加法，简化实现
- **乘法**：部分积相加，乘数为1时加入，为0时跳过
- **除法**：试商减法，恢复或不恢复余数
- **快速算法**：通过优化减少运算次数

### 运算复杂度

| 运算 | 时间复杂度 | 说明 |
|------|-----------|------|
| **加法** | O(n) | n位加法需要n个全加器 |
| **减法** | O(n) | 转换为加法 |
| **乘法** | O(n²) | n位乘法需要n个部分积 |
| **除法** | O(n²) | n位除法需要n次试商 |

### 实际应用

```
CPU中的实现：
  • ALU（算术逻辑单元）执行这些运算
  • 硬件实现：速度快但成本高
  • 软件实现：成本低但速度慢
  • 现代CPU：硬件实现基本运算，软件实现复杂运算
```

---

**最后更新：** 2025年1月








