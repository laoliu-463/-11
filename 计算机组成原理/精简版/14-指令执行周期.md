# 14-指令执行周期

> 指令执行的三个阶段：取指、译码、执行  
> 最后更新：2025年1月

---

## 📑 目录

- [一、什么是指令执行周期？](#一什么是指令执行周期)
- [二、三个阶段详解](#二三个阶段详解)
- [三、不同指令的执行](#三不同指令的执行)
- [四、RTL描述](#四rtl描述)
- [五、总结](#五总结)

---

## 一、什么是指令执行周期？

### 定义

**定义：** 指令执行周期是指CPU执行一条指令所经历的完整过程，包括取指（从内存取指令）、译码（分析指令）、执行（执行操作）三个阶段。

**通俗理解：** 指令执行周期就像"做一道菜的步骤"：先看菜谱（取指）、理解步骤（译码）、然后执行（执行）。CPU每执行一条指令都要经过这些步骤。

### 基本周期

```
┌─────────────────────────────────────────────────┐
│          指令执行周期 (3阶段)                    │
└─────────────────────────────────────────────────┘

┌───────────────┐       ┌───────────────┐       ┌───────────────┐
│   取指 (IF)   │──────→│   译码 (ID)   │──────→│   执行 (EX)   │
│ Instruction   │       │  Instruction  │       │   Execute     │
│    Fetch      │       │    Decode     │       │               │
├───────────────┤       ├───────────────┤       ├───────────────┤
│               │       │               │       │               │
│ T0: MAR←PC    │       │ T3: 分析操作码 │       │ T5: 执行运算   │
│ T1: MDR←M[MAR]│       │ T4: 读取操作数 │       │     或         │
│     PC←PC+4   │       │     准备地址   │       │     访存       │
│ T2: IR←MDR    │       │     准备数据   │       │     或         │
│               │       │               │       │     转移       │
└───────┬───────┘       └───────────────┘       └───────┬───────┘
        │                                               │
        └───────────────────────────────────────────────┘
                        循环执行
```

### 5级流水线（现代设计）

```
┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐   ┌──────┐
│  IF  │──→│  ID  │──→│  EX  │──→│ MEM  │──→│  WB  │
│ 取指  │   │ 译码  │   │ 执行  │   │ 访存  │   │ 写回  │
└──────┘   └──────┘   └──────┘   └──────┘   └──────┘

IF: 指令取出
ID: 指令译码、读寄存器
EX: ALU运算或地址计算
MEM: 存储器访问(LOAD/STORE)
WB: 结果写回寄存器
```

---

## 二、三个阶段详解

### 1. 取指阶段 (IF - Instruction Fetch)

**通俗理解：** 取指就像"从书架上拿书"，CPU从内存中取出要执行的指令。

```
步骤：
  1. MAR ← PC（把PC的值送到MAR）
  2. MDR ← M[MAR]（从内存读取指令）
  3. PC ← PC + 4（PC指向下一条指令）
  4. IR ← MDR（指令送到IR）

时序：
  T0: MAR ← PC
  T1: MDR ← M[MAR]
      PC ← PC + 4
  T2: IR ← MDR

图示：
  ┌────┐      ┌────┐      ┌────┐      ┌────┐
  │ PC │ ───→ │MAR │ ───→ │内存│ ───→ │MDR │ ───→ │ IR │
  └────┘      └────┘      └────┘      └────┘      └────┘
    │                                      │
    └────────── PC + 4 ────────────────────┘
```

### 2. 译码阶段 (ID - Instruction Decode)

**通俗理解：** 译码就像"理解指令的含义"，分析指令要做什么操作，需要哪些数据。

```
步骤：
  1. 提取操作码（IR的高位）
  2. 提取寄存器号（IR的中间位）
  3. 读取寄存器值
  4. 符号扩展立即数

时序：
  T3: 操作码 ← IR[31:26]
      Rd ← IR[15:11]
      Rs ← IR[25:21]
      Rt ← IR[20:16]
  T4: A ← R[Rs]（读取源操作数1）
      B ← R[Rt]（读取源操作数2）
      Imm ← SignExt(IR[15:0])（立即数符号扩展）

图示：
  ┌────┐
  │ IR │
  └──┬─┘
     │
     ├─→ 操作码译码
     ├─→ 提取寄存器号
     └─→ 读取寄存器
         ┌────┐
         │ R1 │ ──→ A
         │ R2 │ ──→ B
         └────┘
```

### 3. 执行阶段 (EX - Execute)

**通俗理解：** 执行就像"实际干活"，根据指令类型执行相应的操作（运算、访存、跳转等）。

```
根据指令类型不同：

R型指令（ADD/SUB/AND/OR等）：
  T5: ALU_Result ← A op B（ALU运算）
      更新标志位(Z, N, C, V)
  T6: R[Rd] ← ALU_Result（写回寄存器）

I型指令（ADDI/LOAD/STORE）：
  T5: Address ← A + Imm（计算地址）
  T6: 访存操作

分支指令（BEQ/BNE/J）：
  T5: Target ← PC + Imm×4（计算目标地址）
  T6: if (条件满足)
         PC ← Target（跳转）
      else
         PC不变（不跳转）
```

---

## 三、不同指令的执行

### ADD指令（加法）

**示例：ADD R1, R2, R3**

```
执行过程：
  T0-T2: 取指
    MAR ← PC
    MDR ← M[MAR]
    PC ← PC + 4
    IR ← MDR
  
  T3-T4: 译码
    操作码 ← IR[31:26]
    R1 ← IR[15:11]（目的寄存器）
    R2 ← IR[25:21]（源寄存器1）
    R3 ← IR[20:16]（源寄存器2）
    A ← R[R2]（读取R2的值）
    B ← R[R3]（读取R3的值）
  
  T5-T6: 执行
    ALU_Result ← A + B（R2 + R3）
    更新标志位
    R[R1] ← ALU_Result（结果写回R1）

总时间：6个时钟周期
```

### LOAD指令（加载）

**示例：LOAD R1, [R2+100]**

```
执行过程：
  T0-T2: 取指（同上）
  
  T3-T4: 译码
    操作码 ← IR[31:26]
    R1 ← IR[15:11]（目的寄存器）
    R2 ← IR[25:21]（基址寄存器）
    Imm ← 100（偏移量）
    A ← R[R2]（读取基址）
  
  T5: 计算地址
    MAR ← A + Imm（R2 + 100）
  
  T6: 访问内存
    MDR ← M[MAR]（从内存读取）
  
  T7: 写回
    R[R1] ← MDR（结果写回R1）

总时间：7个时钟周期
```

### STORE指令（存储）

**示例：STORE [R2+100], R1**

```
执行过程：
  T0-T2: 取指（同上）
  
  T3-T4: 译码
    操作码 ← IR[31:26]
    R1 ← IR[20:16]（源寄存器）
    R2 ← IR[25:21]（基址寄存器）
    Imm ← 100
    A ← R[R2]
    B ← R[R1]（读取要存储的值）
  
  T5: 计算地址并准备数据
    MAR ← A + Imm
    MDR ← B
  
  T6: 写入内存
    M[MAR] ← MDR

总时间：6个时钟周期
```

### 分支指令（跳转）

**示例：BEQ R1, R2, target**

```
执行过程：
  T0-T2: 取指（同上）
  
  T3-T4: 译码
    操作码 ← IR[31:26]
    R1 ← IR[25:21]
    R2 ← IR[20:16]
    Imm ← IR[15:0]（偏移量）
    A ← R[R1]
    B ← R[R2]
  
  T5: 比较和计算目标地址
    Target ← PC + Imm×4
    if (A == B) {
      条件满足
    }
  
  T6: 条件跳转
    if (条件满足)
      PC ← Target（跳转）
    else
      PC不变（继续下一条）

总时间：6个时钟周期
```

---

## 四、RTL描述

### 什么是RTL？

**定义：** RTL（Register Transfer Language，寄存器传输语言）是一种描述数字系统行为的语言，用寄存器之间的数据传输来描述操作。

**通俗理解：** RTL就像"用文字描述数据流动"，用"寄存器A ← 寄存器B"这样的形式描述数据如何流动。

### 取指阶段的RTL

```
取指阶段 (IF):
  T0: MAR ← PC                    // 地址送往MAR
  T1: MDR ← M[MAR]                // 从存储器读取指令
      PC ← PC + 4                 // PC指向下一条指令
  T2: IR ← MDR                    // 指令送入IR
```

### 译码阶段的RTL

```
译码阶段 (ID):
  T3: 操作码 ← IR[31:26]          // 提取操作码
      Rd ← IR[15:11]              // 提取目的寄存器
      Rs ← IR[25:21]              // 提取源寄存器1
      Rt ← IR[20:16]              // 提取源寄存器2
  T4: A ← R[Rs]                   // 读取源操作数1
      B ← R[Rt]                   // 读取源操作数2
      Imm ← SignExt(IR[15:0])     // 立即数符号扩展
```

### 执行阶段的RTL

```
R型指令 (ADD/SUB/AND/OR等):
  T5: ALU_Result ← A op B       // ALU运算
      更新标志位(Z, N, C, V)
  T6: R[Rd] ← ALU_Result        // 写回寄存器

LOAD指令:
  T5: MAR ← A + Imm
  T6: MDR ← M[MAR]
  T7: R[Rt] ← MDR

STORE指令:
  T5: MAR ← A + Imm
      MDR ← R[Rt]
  T6: M[MAR] ← MDR

分支指令 (BEQ/BNE/J):
  T5: Target ← PC + Imm×4       // 计算目标地址
  T6: if (条件满足)
         PC ← Target            // 跳转
      else
         PC不变                 // 不跳转
```

---

## 五、总结

### 核心要点

```
✅ 指令周期 = 取指 + 译码 + 执行
✅ 取指：从内存读取指令到IR
✅ 译码：分析指令，读取操作数
✅ 执行：根据指令类型执行相应操作
✅ RTL：用寄存器传输描述操作
✅ 不同指令执行步骤不同
```

### 关键理解

- **取指阶段**：从内存读取指令，PC自动+4
- **译码阶段**：分析指令，提取操作码和操作数
- **执行阶段**：根据指令类型执行（运算、访存、跳转）
- **RTL描述**：用寄存器传输语言描述数据流动
- **不同指令**：执行步骤和周期数不同

### 指令执行时间

| 指令类型 | 执行周期 | 说明 |
|---------|---------|------|
| **R型** | 6周期 | 取指(3) + 译码(2) + 执行(1) |
| **LOAD** | 7周期 | 取指(3) + 译码(2) + 访存(2) |
| **STORE** | 6周期 | 取指(3) + 译码(2) + 访存(1) |
| **分支** | 6周期 | 取指(3) + 译码(2) + 跳转(1) |

### 性能优化

```
优化方向：
  • 流水线：重叠执行多条指令
  • 分支预测：减少分支延迟
  • Cache：减少访存时间
  • 指令级并行：同时执行多条指令
```

---

**最后更新：** 2025年1月


