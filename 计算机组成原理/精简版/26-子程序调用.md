# 26-子程序调用

> 子程序调用与返回、栈帧管理、参数传递  
> 最后更新：2025年1月

---

## 📑 目录

- [一、什么是子程序调用？](#一什么是子程序调用)
- [二、调用与返回](#二调用与返回)
- [三、栈帧管理](#三栈帧管理)
- [四、参数传递](#四参数传递)
- [五、总结](#五总结)

---

## 一、什么是子程序调用？

### 定义

**定义：** 子程序调用是指程序执行过程中，从主程序跳转到子程序执行，执行完后返回主程序继续执行的机制。

**通俗理解：** 子程序调用就像"调用函数"，主程序调用子程序（函数），子程序执行完后返回主程序继续执行。

### 调用过程

```
子程序调用过程：
  1. 保存返回地址（PC+4）
  2. 跳转到子程序入口
  3. 保存现场（寄存器）
  4. 执行子程序
  5. 恢复现场（寄存器）
  6. 返回主程序（恢复PC）
```

---

## 二、调用与返回

### CALL指令

**通俗理解：** CALL指令就像"跳转并保存地址"，跳转到子程序，同时保存返回地址。

```
CALL指令操作：
  1. SP ← SP - 4（栈指针减4）
  2. M[SP] ← PC + 4（保存返回地址）
  3. PC ← 子程序地址（跳转）

示例：
  CALL function
    → 保存返回地址到栈
    → 跳转到function
```

### RET指令

**通俗理解：** RET指令就像"恢复地址并返回"，从栈中取出返回地址，跳转回去。

```
RET指令操作：
  1. PC ← M[SP]（恢复返回地址）
  2. SP ← SP + 4（栈指针加4）

示例：
  RET
    → 从栈中取出返回地址
    → 跳转回主程序
```

---

## 三、栈帧管理

### 什么是栈帧？

**通俗理解：** 栈帧就像"函数的房间"，每个函数调用都有自己的栈帧，存放局部变量、参数、返回地址等。

```
栈帧结构（从高地址到低地址）：
┌─────────────────┐
│   返回地址      │ ← 调用者保存
├─────────────────┤
│   旧FP          │ ← 上一个栈帧指针
├─────────────────┤
│   局部变量      │ ← 当前函数
├─────────────────┤
│   参数          │ ← 调用者传递
└─────────────────┘
```

### 栈帧操作

```
函数调用时：
  1. 保存返回地址
  2. 保存旧FP（帧指针）
  3. 设置新FP = SP
  4. SP -= 局部变量空间

函数返回时：
  1. SP = FP（恢复栈指针）
  2. 恢复旧FP
  3. 恢复返回地址
  4. 返回
```

---

## 四、参数传递

### 参数传递方式

**通俗理解：** 参数传递就像"传递信息"，可以通过寄存器、栈、或两者结合传递。

```
参数传递方式：
  1. 寄存器传递（快，但寄存器有限）
  2. 栈传递（灵活，但较慢）
  3. 混合传递（常用，前几个用寄存器，其余用栈）

ARM约定：
  • 前4个参数：R0-R3
  • 其余参数：栈传递
  • 返回值：R0
```

### 参数传递示例

```
示例：调用 add(5, 3)
  
  寄存器传递：
    R0 ← 5（参数1）
    R1 ← 3（参数2）
    CALL add
    add函数：R0 ← R0 + R1
    返回：R0 = 8（返回值）

  栈传递：
    SP ← SP - 4
    M[SP] ← 3（参数2）
    SP ← SP - 4
    M[SP] ← 5（参数1）
    CALL add
    add函数：从栈读取参数
    返回：结果在R0
```

---

## 五、总结

### 核心要点

```
✅ 子程序调用：CALL保存返回地址，RET恢复返回地址
✅ 栈帧管理：每个函数有自己的栈帧
✅ 参数传递：寄存器（快）或栈（灵活）
✅ ARM约定：前4个参数用R0-R3，返回值用R0
✅ 现场保护：保存和恢复寄存器
```

### 关键理解

- **子程序调用**：CALL保存返回地址，RET恢复返回地址
- **栈帧**：每个函数有自己的栈帧，存放局部变量和参数
- **参数传递**：寄存器传递快，栈传递灵活
- **现场保护**：调用前保存，返回后恢复
- **ARM约定**：前4个参数用寄存器，其余用栈

---

**最后更新：** 2025年1月









