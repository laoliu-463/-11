# 26-子程序调用：上下文的保存与恢复

> **核心视角**：子程序调用 (Function Call) 本质上是一次**临时性的上下文切换**。
> 为了让 CPU 能跳过去执行另一段代码，然后再完美地跳回来，我们必须把当前的**状态**（PC、寄存器）找个地方存起来。这个地方就是**栈 (Stack)**。
> 最后更新：2025年1月

---

## 一、为什么需要栈？

如果只是简单的跳转，`JMP` 指令就够了。但子程序调用的关键在于**有去有回**。
*   **问题**：CPU 怎么知道回哪儿去？
*   **方案**：在跳走之前，把"回来的地址"（返回地址）记下来。
*   **进阶问题**：如果函数 A 调函数 B，B 又调 C 怎么办？
*   **方案**：我们需要一个**后进先出 (LIFO)** 的结构来存储这些返回地址。这就是**栈**。

---

## 二、栈帧 (Stack Frame)：函数的私有领地

每次函数调用，都会在栈上开辟一块区域，称为**栈帧**。它是该函数执行期间的**私有状态空间**。

```mermaid
graph BT
    subgraph 栈内存_高地址到低地址
        direction BT
        
        subgraph 函数A的栈帧
            返回地址A[返回地址到Main]
            局部变量A[局部变量A]
        end
        
        subgraph 函数B的栈帧
            返回地址B[返回地址到A]
            参数C[传给C的参数]
            局部变量B[局部变量B]
        end
        
        subgraph 函数C的栈帧
            返回地址C[返回地址到B]
            局部变量C[局部变量C]
            栈指针[栈指针SP]
        end
        
        函数A的栈帧 --> 函数B的栈帧
        函数B的栈帧 --> 函数C的栈帧
    end
    
    注释[SP始终指向栈顶]
    栈指针 -.-> 注释
```

### 栈帧里存了什么？
1.  **返回地址 (Return Address)**：函数执行完后，PC 该指哪儿。
2.  **保存的寄存器 (Saved Registers)**：
    *   **Caller Saved**：调用者觉得有用的数据，自己存起来。
    *   **Callee Saved**：被调用者如果要用某些寄存器，得先帮别人存好，走的时候再恢复。
3.  **局部变量 (Local Variables)**：函数内部定义的变量。
4.  **参数 (Arguments)**：如果寄存器放不下，多余的参数放在栈里。

---

## 三、调用与返回的硬件机制

### 1. CALL 指令 (调用)
1.  **保存现场**：`PUSH PC` (x86) 或 `LR = PC` (ARM)。
2.  **跳转**：`PC = Target Address`。

### 2. RET 指令 (返回)
1.  **恢复现场**：`POP PC` (x86) 或 `PC = LR` (ARM)。
2.  **栈平衡**：确保 SP (Stack Pointer) 回到调用前的状态。

---

## 四、总结

*   子程序调用不仅仅是代码跳转，更是**状态的压栈与出栈**。
*   **栈**是维护程序逻辑结构的物理基础。没有栈，就没有递归，就没有现代编程语言的函数机制。
