# 08-舍入与误差：有限状态的代价

> **核心视角**：计算机的**状态空间是有限的**，而现实世界的实数是**无限的**。当我们将无限的实数映射到有限的机器数时，必然会发生**信息丢失**。舍入 (Rounding) 就是这种映射的**策略**。
> 最后更新：2025年1月

---

## 一、舍入的本质：有损压缩

将一个高精度数值（如 `1/3` 或 `π`）存入有限位数的寄存器（如 32 位 float），就像把一张高清大图压缩成缩略图。

*   **截断 (Truncation)**：直接切掉多余部分。简单粗暴，但误差大。
*   **舍入 (Rounding)**：根据某种规则，选择一个最接近的“合法状态”来代表原值。

---

## 二、IEEE 754 的四种舍入模式

IEEE 754 标准定义了硬件必须支持的 4 种策略：

1.  **就近舍入 (Round to Nearest, ties to Even)** —— **默认模式**
    *   **策略**：舍入到最近的浮点数。
    *   **平局处理**：如果刚好在中间（如 x.5），则舍入到**偶数**（最低位为0）。
    *   **目的**：统计学上最公平，避免长期运算导致的系统性偏差（向大或向小漂移）。
2.  **朝 0 舍入 (Round toward Zero)**
    *   **策略**：直接截断小数。
    *   **应用**：强制类型转换 `(int)float` 时通常用这个。
3.  **朝 +∞ 舍入 (Round toward +Infinity)**
    *   **策略**：向上取整（Ceiling）。
    *   **应用**：区间算术，计算误差上界。
4.  **朝 -∞ 舍入 (Round toward -Infinity)**
    *   **策略**：向下取整（Floor）。
    *   **应用**：区间算术，计算误差下界。

---

## 三、误差的来源与累积

### 1. 截断误差 (Truncation Error)
*   **来源**：数值本身无法用二进制有限位精确表示。
*   **例子**：`0.1` 在二进制中是无限循环小数 `0.00011001100...`。存入 float 后，它就不再是 `0.1` 了，而是一个极接近 `0.1` 的数。
*   **后果**：`0.1 + 0.2 != 0.3`。

### 2. 大数吃小数 (Absorption)
*   **来源**：浮点数加法需要**对阶**。
*   **现象**：当一个极大数与一个极小数相加时，极小数在对阶过程中会被右移移出，导致**完全丢失**。
*   **例子**：`10000000.0 + 0.0000001 = 10000000.0`。

### 3. 相近数相减 (Cancellation)
*   **来源**：两个非常接近的数相减。
*   **现象**：有效数字互相抵消，结果只剩下原本是误差的低位垃圾数据，导致**有效位数急剧下降**。
*   **例子**：`1.2345678 - 1.2345677 = 0.0000001`。结果只有 1 位有效数字，精度损失惨重。

---

## 四、总结

*   计算机中的数学运算是**近似计算**。
*   **舍入**是硬件为了在有限资源下尽可能逼近真实值而做出的妥协。
*   程序员必须时刻警惕**精度丢失**，特别是在涉及金钱计算（应使用定点数或 Decimal）和科学计算（注意运算顺序）时。
