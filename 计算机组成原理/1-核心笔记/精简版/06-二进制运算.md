# 06-二进制运算：ALU的转换艺术

> **核心视角**：**运算**是计算机最核心的**转换函数**。ALU（算术逻辑单元）通过组合逻辑电路，将输入的**数据状态**转换为输出的**结果状态**。
> 最后更新：2025年1月

---

## 一、加法：万物之源

加法是计算机中最基础的**算术函数**，几乎所有其他运算（减、乘、除）最终都可以分解为加法。

### 1. 一位全加器 (Full Adder)
*   **输入**：$A$ (加数), $B$ (加数), $C_{in}$ (进位)。
*   **输出**：$S$ (和), $C_{out}$ (进位输出)。
*   **逻辑函数**：
    *   $S = A \oplus B \oplus C_{in}$ (异或：奇数个1则为1)
    *   $C_{out} = AB + BC_{in} + AC_{in}$ (多数表决：两个以上1则进位)

### 2. 并行加法器
*   **串行进位 (Ripple Carry)**：低位的 $C_{out}$ 传给高位的 $C_{in}$。像波浪一样传播，速度慢。
*   **超前进位 (Lookahead Carry)**：通过复杂的逻辑电路，直接根据输入 $A, B$ 预测出所有位的进位，速度快但电路复杂。

---

## 二、减法：加法的变体

在补码系统中，减法不需要专门的硬件电路。

*   **转换函数**：$A - B = A + (-B)_{补}$
*   **硬件实现**：
    1.  将 $B$ 的所有位取反（反相器）。
    2.  将 $C_{in}$ 设为 1（相当于加1）。
    3.  送入加法器进行 $A + (\sim B) + 1$。
*   **意义**：极大地节省了晶体管数量，体现了**数据表示（补码）**对**函数实现（ALU）**的优化。

---

## 三、乘法：移位与相加

乘法是**加法**的多次迭代。

### 1. 笔算乘法算法
*   **逻辑**：
    *   如果乘数当前位是 1，则将被乘数加到结果中。
    *   如果乘数当前位是 0，则加 0。
    *   每次迭代，被乘数左移（或乘数右移）。
*   **硬件**：需要加法器、移位寄存器和控制逻辑。

### 2. Booth 算法：跳过 0 和 1
*   **核心洞察**：一串连续的 1（如 `00111100`）可以看作 `01000000 - 00000100`。
*   **优化**：将多次加法转换为一次加法和一次减法。
*   **收益**：减少了加法操作的次数，提高了**函数执行速度**。

---

## 四、除法：移位与减法

除法是**乘法**的逆运算，也是最慢的整数运算。

### 1. 恢复余数法
*   **逻辑**：
    *   试着减一下（$R - D$）。
    *   如果结果为负（不够减），则恢复原值（$R + D$），商 0。
    *   如果结果为正（够减），则保留结果，商 1。
*   **问题**：每次不够减都要做加法恢复，效率低。

### 2. 加减交替法 (不恢复余数)
*   **优化**：不够减时，不立即恢复，而是下一轮直接做加法。
*   **本质**：优化了**状态转换路径**，减少了无效的中间步骤。

---

## 五、总结

*   **ALU** 是一个纯粹的组合逻辑电路（无记忆），它根据输入即时产生输出。
*   **补码** 的存在使得 ALU 可以用一套电路同时处理加法和减法。
*   **乘除法** 是通过**时序逻辑**（控制单元）驱动 ALU 多次循环执行加减法和移位操作来实现的。
