# 17-条件执行与流控制：状态的过滤器

> **核心视角**：流控制 (Flow Control) 通常意味着**跳转**（改变 PC）。但跳转会破坏流水线。
> **条件执行 (Conditional Execution)** 是一种**过滤器**机制：指令依然顺序流过流水线，但只有满足特定**状态条件**（Flags）的指令才会真正生效（Commit）。
> 最后更新：2025年1月

---

## 一、条件码 (Condition Codes)：状态的快照

ALU 在执行运算时，会顺便产生一组**元数据**，描述这次运算结果的特征。这些元数据保存在 **PSW (Program Status Word)** 中。

*   **N (Negative)**：结果是负数（最高位为1）。
*   **Z (Zero)**：结果是零。
*   **C (Carry)**：无符号运算产生进位/借位。
*   **V (Overflow)**：有符号运算产生溢出。

这些标志位是**上一条指令留下的遗产**，也是**下一条指令决策的依据**。

---

## 二、条件分支 (Branching)：改变河流的方向

传统的流控制是通过跳转指令实现的。

```assembly
CMP R1, R2      ; 比较 R1, R2 (本质是 R1 - R2)
BEQ Target      ; 如果 Z==1 (相等)，则跳转到 Target
ADD R3, R4, R5  ; 否则继续执行
...
Target:
SUB R3, R4, R5
```

*   **缺点**：遇到分支指令，CPU 的**流水线**可能需要停顿或清空（如果预测失败）。这在现代深流水线 CPU 中代价巨大（可能浪费 10~20 个周期）。

---

## 三、条件执行 (Predication)：自带过滤器的指令

ARM 架构引入了**全指令条件执行**的概念。每条指令都可以带一个后缀（如 `EQ`, `NE`, `GT`）。

```assembly
CMP R1, R2      ; 比较 R1, R2
ADDEQ R3, R4, R5; 只有当 Z==1 时，才执行 ADD。否则变成 NOP (空操作)。
SUBNE R3, R4, R5; 只有当 Z==0 时，才执行 SUB。
```

*   **优点**：
    *   **消灭跳转**：程序计数器 PC 依然顺序增加，流水线不被打断。
    *   **代码紧凑**：用指令后缀代替了跳转指令。
*   **代价**：
    *   指令编码空间被占用（ARM 32位指令中，高 4 位专门用于存条件码）。
    *   如果条件不满足，指令虽然不生效，但依然占用了取指和译码的时间（变成了 NOP）。

---

## 四、总结

*   **条件分支**是**粗粒度**的流控制，适合大段代码的跳转（如 `if-else` 块很大）。
*   **条件执行**是**细粒度**的流控制，适合短小的逻辑判断（如 `a = (b > c) ? b : c`）。
*   它们都是基于**状态标志位 (NZCV)** 来决定未来的**状态变换**。
