# 25-中断系统：事件驱动的内核

> **核心视角**：中断 (Interrupt) 是计算机系统的**神经脉冲**。它强制 CPU 暂停当前的**线性执行流**（函数），转而去处理一个突发的**异步事件**（中断服务程序），处理完后再恢复原状态。这是操作系统实现**多任务**和**实时响应**的基础。
> 最后更新：2025年1月

---

## 一、中断的本质：硬件触发的函数调用

普通函数调用 (`CALL`) 是**软件**预先安排好的。
中断 (`INT`) 是**硬件**随时可能触发的。

### 1. 流程对比

| 步骤 | 普通函数调用 | 中断处理 |
| :--- | :--- | :--- |
| **触发** | 执行 `CALL` 指令 | 外部信号 / 内部异常 |
| **保存断点** | 压栈 PC | 压栈 PC + **PSW (状态字)** |
| **寻址** | 指令中的地址 | **中断向量表** |
| **执行** | 子程序 | **中断服务程序 (ISR)** |
| **返回** | `RET` | `IRET` (恢复 PC + PSW) |

*   **关键点**：中断必须保存 **PSW (Program Status Word)**，因为中断可能发生在任何两条指令之间，不能改变被中断程序的标志位状态（如进位、零标志）。

---

## 二、中断处理完整流程图

```mermaid
sequenceDiagram
    participant 主程序 as 主程序执行
    participant CPU as CPU核心
    participant 中断控制器 as 中断控制器
    participant ISR as 中断服务程序
    participant 栈 as 系统栈
    
    Note over 主程序,栈: 正常执行中...
    主程序->>CPU: 执行指令N
    
    中断控制器->>CPU: 中断请求信号IRQ
    
    CPU->>CPU: 完成当前指令N
    CPU->>CPU: 检查中断使能位IE
    
    alt IE=1 且有中断请求
        CPU->>栈: 保存PC (返回地址)
        CPU->>栈: 保存PSW (状态字)
        Note over CPU,栈: 保存现场
        
        CPU->>CPU: 关中断 (IE=0)
        CPU->>中断控制器: 读取中断向量号
        中断控制器-->>CPU: 返回向量号N
        
        CPU->>CPU: 查中断向量表<br/>获取ISR入口地址
        CPU->>ISR: 跳转到ISR
        
        Note over ISR: 中断服务程序执行
        ISR->>ISR: 保存用到的寄存器
        ISR->>ISR: 处理中断事件
        ISR->>ISR: 清除中断标志
        ISR->>ISR: 恢复寄存器
        
        ISR->>栈: 执行IRET指令
        栈-->>CPU: 恢复PSW
        栈-->>CPU: 恢复PC
        
        CPU->>CPU: 开中断 (IE=1)
        CPU->>主程序: 返回指令N+1继续执行
    else IE=0 或无中断
        CPU->>主程序: 继续执行指令N+1
    end
    
    Note over 主程序,栈: 恢复正常执行
```

---

## 三、中断分类：内忧与外患

### 中断分类树状图

```mermaid
graph TD
    Root[中断分类] --> External[外中断<br/>External Interrupt]
    Root --> Internal[内中断<br/>Exception/Trap]
    
    External --> Maskable[可屏蔽中断INTR<br/>键盘/鼠标/网卡]
    External --> NonMaskable[不可屏蔽中断NMI<br/>电源故障/硬件错误]
    
    Internal --> Fault[故障Fault<br/>可恢复]
    Internal --> Trap[陷阱Trap<br/>预设的]
    Internal --> Abort[终止Abort<br/>致命错误]
    
    Fault --> PageFault[缺页异常<br/>修复后重新执行]
    Fault --> DivZero[除零错误]
    
    Trap --> SysCall[系统调用<br/>用户态→内核态]
    Trap --> Breakpoint[断点调试]
    
    Abort --> HardwareError[硬件故障<br/>直接终止进程]
    
    style External fill:#ccffcc
    style Internal fill:#ffcccc
    style NonMaskable fill:#ff9999
    style Abort fill:#ff9999
```

### 1. 外中断 (Interrupt) —— 外部事件
由 CPU 外部设备触发，与当前指令无关。
*   **可屏蔽中断 (INTR)**：如键盘输入、打印机就绪。CPU 可以通过设置 `IF` 标志位来**忽略**（关中断）。
*   **不可屏蔽中断 (NMI)**：如电源掉电、内存校验错。天塌下来的大事，CPU **必须**立即响应。

### 2. 内中断 (Exception/Trap) —— 内部异常
由当前执行的指令触发。
*   **故障 (Fault)**：可修复的错误。如**缺页异常**。修复后重新执行该指令。
*   **陷阱 (Trap)**：预设的"坑"。如**系统调用 (System Call)**、断点调试。
*   **终止 (Abort)**：不可修复的致命错误。如硬件故障。直接杀进程。

---

## 四、中断判优：谁更重要？

当多个中断同时发生，或者在处理一个中断时又来了新中断，CPU 如何抉择？

### 中断优先级示意图

```mermaid
graph LR
    subgraph 优先级从高到低
        P1[硬件故障<br/>最高优先级] --> P2[程序异常<br/>缺页/除零]
        P2 --> P3[外部中断<br/>时钟/DMA]
        P3 --> P4[I/O设备<br/>键盘/鼠标]
        P4 --> P5[软件中断<br/>最低优先级]
    end
    
    Note1[高优先级可以<br/>打断低优先级]
    P1 -.-> Note1
    
    style P1 fill:#ff9999
    style P5 fill:#ccffcc
```

1.  **硬件排队器**：硬件电路决定优先级（如故障 > DMA > I/O）。
2.  **中断嵌套**：
    *   允许高优先级中断打断低优先级中断的处理。
    *   实现：在 ISR 中执行**开中断**指令。

---

## 五、总结

*   中断系统将 CPU 从**主动轮询**的低效模式中解放出来，转变为**被动响应**的高效模式。
*   它是**操作系统**的基石：
    *   **时钟中断**驱动了进程调度（分时多任务）。
    *   **I/O 中断**驱动了设备驱动程序。
    *   **系统调用**（软中断）是用户态进入内核态的唯一大门。

---

## 核心考点与习题映射 (Exam Focus)
> **来源**：`101-I-O系统练习题`

### 1. 中断系统进阶
*   **中断判优 (101-Q7)**：解决并发冲突。
*   **中断掩码 (101-Q14)**：
    *   **作用**：动态改变处理顺序 (非响应顺序)。
    *   **设置原则**：屏蔽自己 + 屏蔽低优先级。
*   **堆栈作用 (101-Q8)**：保存 PC 和 PSW (恢复现场)。
