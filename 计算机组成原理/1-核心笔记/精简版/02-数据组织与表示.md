# 02-数据组织与表示

> 数据单位、端格式、内存对齐  
> 最后更新：2025年1月

---

## 📑 目录

- [一、数据单位](#一数据单位)
- [二、端格式（字节序）](#二端格式字节序)
- [三、内存对齐](#三内存对齐)
- [四、实际应用](#四实际应用)
- [五、总结](#五总结)

---

## 一、数据单位

### 基本数据单位

**通俗理解：** 数据单位就像"度量衡"，定义了计算机存储和表示数据的基本单位，从最小的位（Bit）到字节（Byte）再到字（Word）。

```
位（Bit）：
  • 最小单位：0 或 1
  • 8个位 = 1个字节
  • 类比：像"原子"，最小的单位

字节（Byte）：
  • 8位 = 1字节
  • 基本存储单位
  • 可表示0-255（无符号）
  • 类比：像"分子"，由8个原子组成

字（Word）：
  • 16位 = 2字节（半字）
  • 32位 = 4字节（字，常见）
  • 64位 = 8字节（双字）
  • 类比：像"单词"，由多个字节组成
```

### 数据类型大小

| 数据类型 | 大小（字节） | 范围示例 |
|---------|------------|---------|
| char    | 1          | 0-255    |
| short   | 2          | ±32767   |
| int     | 4          | ±21亿    |
| long    | 4或8       | 平台相关 |
| float   | 4          | IEEE754  |
| double  | 8          | IEEE754  |

---

## 二、端格式（字节序）

### 什么是端格式？

**定义：** 端格式（字节序）是指多字节数据在内存中的字节排列顺序，决定高字节和低字节的排列方式。

**通俗理解：** 端格式就像"数字书写方式"，大端序像人类写数字，高位在前（12345678），小端序像倒过来读，低位在前（78563412）。

### 大端序（Big-Endian）

**定义：** 大端序是指高位字节存储在低地址，低字节存储在高地址的存储方式。

**通俗理解：** 就像"从左到右读数字"，最重要的部分（高字节）放在最前面。

**特点：**
- 人类可读性强（从左到右读）
- 网络字节序标准
- 许多RISC处理器使用

**示例：32位整数 0x12345678**

```
内存布局（大端序）：
  地址      内容（十六进制）    说明
  ──────────────────────────────────────
  0x1000    12              ← 最高字节（MSB）
  0x1001    34
  0x1002    56
  0x1003    78              ← 最低字节（LSB）
  
  阅读顺序：从左到右 = 12 34 56 78 ✓

可视化：
  0x1000  0x1001  0x1002  0x1003
  ┌──────┬──────┬──────┬──────┐
  │  12  │  34  │  56  │  78  │
  └──────┴──────┴──────┴──────┘
    ↑ MSB                      ↑ LSB
  （低地址）                 （高地址）

使用大端序的平台：
  • PowerPC
  • SPARC
  • 某些ARM（可配置）
  • 网络传输（标准）
```

### 小端序（Little-Endian）

**定义：** 小端序是指低字节存储在低地址，高字节存储在高地址的存储方式。

**通俗理解：** 就像"从右到左读数字"，最不重要的部分（低字节）放在最前面。

**特点：**
- 与人类阅读习惯相反
- x86/x64架构使用
- 许多ARM处理器默认使用

**示例：32位整数 0x12345678**

```
内存布局（小端序）：
  地址      内容（十六进制）    说明
  ──────────────────────────────────────
  0x1000    78              ← 最低字节（LSB）
  0x1001    56
  0x1002    34
  0x1003    12              ← 最高字节（MSB）
  
  阅读顺序：从右到左 = 12 34 56 78（需反转）

可视化：
  0x1000  0x1001  0x1002  0x1003
  ┌──────┬──────┬──────┬──────┐
  │  78  │  56  │  34  │  12  │
  └──────┴──────┴──────┴──────┘
    ↑ LSB                      ↑ MSB
  （低地址）                 （高地址）

使用小端序的平台：
  • Intel x86/x64
  • ARM（默认）
  • 许多嵌入式系统
```

### 对比示例

| 特性 | 大端序 | 小端序 |
|------|--------|--------|
| **存储顺序** | 高字节在前 | 低字节在前 |
| **地址顺序** | 0x1000: 12, 0x1001: 34 | 0x1000: 78, 0x1001: 56 |
| **人类阅读** | 符合习惯 | 需要转换 |
| **网络传输** | 标准 | 需要转换 |
| **典型架构** | PowerPC, SPARC | x86, x86-64, ARM |

**实际示例：**
```
数值：0x12345678

大端序存储：
  地址:  0x1000  0x1001  0x1002  0x1003
  内容:    12      34      56      78
           ↑ 从低地址开始读：12 34 56 78 ✓

小端序存储：
  地址:  0x1000  0x1001  0x1002  0x1003
  内容:    78      56      34      12
           ↑ 从低地址开始读：78 56 34 12
           需反转为：12 34 56 78 ✓

关键：
  • 字节内容相同
  • 排列顺序不同
  • CPU自动处理转换
```

---

## 三、内存对齐

### 什么是内存对齐？

**定义：** 内存对齐是指数据在内存中的存储地址必须是其大小的整数倍，以提高访问效率。

**通俗理解：** 内存对齐就像"停车位对齐"，车辆必须停在指定的位置，不能随意停放。对齐的数据访问更快，因为CPU可以一次读取完整的数据。

### 对齐规则

```
对齐规则：
  • char（1字节）：任意地址
  • short（2字节）：地址必须是2的倍数
  • int（4字节）：地址必须是4的倍数
  • long（8字节）：地址必须是8的倍数

为什么需要对齐？
  • CPU读取对齐数据更快
  • 某些架构要求对齐（否则出错）
  • 提高缓存效率
```

### 对齐示例

**结构体对齐示例：**

```
struct Example {
    char  a;   // 1字节，地址0x1000（任意）
    int   b;   // 4字节，需要4字节对齐
    short c;   // 2字节，需要2字节对齐
};

内存布局（小端序，4字节对齐）：
  地址      内容        说明
  ───────────────────────────────
  0x1000    [a]         char a
  0x1001    (填充)
  0x1002    (填充)
  0x1003    (填充)
  0x1004    [b字节0]    int b (低字节)
  0x1005    [b字节1]
  0x1006    [b字节2]
  0x1007    [b字节3]    int b (高字节)
  0x1008    [c字节0]    short c (低字节)
  0x1009    [c字节1]    short c (高字节)
  0x100A    (填充)
  0x100B    (填充)
  
  总大小：12字节（不是7字节！）

说明：
  • a占用1字节，但后面有3字节填充（为了对齐b）
  • b必须在4的倍数地址（0x1004）
  • c可以在2的倍数地址（0x1008）
  • 末尾填充2字节（使整个结构体对齐到4字节）
```

### 对齐规则表

| 数据类型 | 大小 | 对齐要求 | 示例地址 |
|---------|------|---------|---------|
| char    | 1    | 1       | 任意    |
| short   | 2    | 2       | 0x1002  |
| int     | 4    | 4       | 0x1004  |
| float   | 4    | 4       | 0x1004  |
| double  | 8    | 8       | 0x1008  |
| long    | 4或8 | 4或8    | 平台相关 |

---

## 四、实际应用

### 网络传输中的端格式

**问题：** 不同端格式的计算机通过网络通信时，需要统一字节序。

**解决方案：** 使用"网络字节序"（大端序）

```
网络字节序转换函数：
  htons() - Host TO Network Short（主机转网络，短整型）
  htonl() - Host TO Network Long（主机转网络，长整型）
  ntohs() - Network TO Host Short（网络转主机，短整型）
  ntohl() - Network TO Host Long（网络转主机，长整型）

示例：
  主机字节序（小端）：0x12345678
  网络字节序（大端）：0x78563412
  
  发送前：使用htonl()转换
  接收后：使用ntohl()转换
```

### 文件读写中的端格式

**问题：** 不同端格式的系统读写二进制文件时可能出错。

**解决方案：**
1. 使用文本格式
2. 统一使用网络字节序
3. 显式转换字节序

```
正确做法：
  // 写入时转换为网络字节序
  uint32_t value = 0x12345678;
  uint32_t network_value = htonl(value);
  write(fd, &network_value, sizeof(uint32_t));
  
  // 读取时转换为主机字节序
  uint32_t network_value;
  read(fd, &network_value, sizeof(uint32_t));
  uint32_t value = ntohl(network_value);
```

---

## 五、总结

### 核心要点

```
✅ 数据单位：位 → 字节 → 字
✅ 端格式：大端序（高字节在前）vs 小端序（低字节在前）
✅ 内存对齐：数据地址必须是其大小的倍数
✅ 网络传输：使用网络字节序（大端）
✅ 跨平台开发：注意端格式差异
```

### 关键理解

- **数据单位**定义了存储的基本单位（位、字节、字）
- **端格式**决定多字节数据的排列顺序
- **内存对齐**提高访问效率，某些架构必须对齐
- **网络传输**需要统一字节序（网络字节序=大端序）
- **跨平台开发**要注意端格式差异

### 常见陷阱

**陷阱1：假设端格式**
- ❌ 错误：假设是小端序，直接操作字节
- ✅ 正确：使用网络字节序函数或可移植的方法

**陷阱2：字节序与位序混淆**
- 字节序（Endianness）：字节的排列顺序
- 位序（Bit Order）：位的排列顺序（通常是固定的）

---

**最后更新：** 2025年1月

