# 05-IEEE浮点数：动态范围的代价

> **核心视角**：浮点数是一种**复杂的编码函数**，它牺牲了**精度**（尾数有限）和**运算速度**（逻辑复杂），换取了极大的**数值范围**（指数），以模拟现实世界中的连续量。
> 最后更新：2025年1月

---

## 一、为什么需要浮点数？

*   **定点数的局限**：
    *   32位定点整数最大只能表示到 $2 \times 10^9$。
    *   无法同时表示原子的大小 ($10^{-10}$) 和宇宙的尺度 ($10^{26}$)。
*   **解决方案**：**科学计数法**的二进制化。
    *   $V = (-1)^S \times M \times 2^E$
    *   将有限的状态空间拆分为三部分：**符号**、**尺度**（指数）、**精度**（尾数）。

---

## 二、IEEE 754 编码函数

### 1. 格式定义 (S-E-M)

| 精度 | 总位数 | S (符号) | E (指数) | M (尾数) | 偏置值 (Bias) |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **单精度 (float)** | 32 | 1 | 8 | 23 | 127 |
| **双精度 (double)** | 64 | 1 | 11 | 52 | 1023 |

### 2. 关键设计细节

#### A. 指数 (Exponent)：移码表示
*   **设计**：存储值 = 真实指数 + Bias。
*   **目的**：为了让指数部分可以像无符号整数一样**直接比较大小**。
    *   真实指数 $-126$ (最小) $\rightarrow$ 存储为 $1$。
    *   真实指数 $+127$ (最大) $\rightarrow$ 存储为 $254$。
    *   $0$ 和 $255$ 保留用于特殊值。

#### B. 尾数 (Mantissa)：隐藏位 (Hidden Bit)
*   **设计**：规格化数的尾数总是 $1.xxxxxx$。
*   **目的**：既然第一位总是1，就不需要存储它。
    *   **收益**：白赚了1位精度（23位存储空间 $\rightarrow$ 24位有效精度）。

---

## 三、特殊状态：处理未知与异常

IEEE 754 专门保留了指数全0和全1的状态，用于表示非正常数值。

| 指数 (E) | 尾数 (M) | 含义 | 解释 |
| :--- | :--- | :--- | :--- |
| **全 0** | **0** | **±0** | 解决了 0 无法用规格化形式表示的问题。 |
| **全 0** | **非 0** | **非规格化数** | 用于表示极小的数，填补 0 到最小规格化数之间的空隙。 |
| **全 1** | **0** | **±∞** | 运算溢出（如 $1.0/0.0$）。 |
| **全 1** | **非 0** | **NaN** | 非法运算结果（如 $0.0/0.0$, $\sqrt{-1}$）。 |

---

## 四、浮点运算：沉重的函数

浮点运算远比定点运算复杂，因为**指数**和**尾数**需要分别处理并相互配合。

### 1. 加法步骤 (Add)
1.  **对阶 (Align)**：比较两个数的指数，将小指数数的尾数右移，直到指数相同。
    *   *代价*：右移会导致精度丢失。
2.  **尾数加减 (Calculate)**：执行定点加减法。
3.  **规格化 (Normalize)**：
    *   如果结果溢出（如 $1.1 + 1.1 = 11.0$），右移尾数，指数+1。
    *   如果结果太小（如 $1.0 - 0.99 = 0.01$），左移尾数，指数-1。
4.  **舍入 (Round)**：将结果截断到规定的位数（如23位）。

### 2. 性能影响
*   **延迟**：浮点加法通常需要 3-5 个时钟周期，而整数加法只需 1 个周期。
*   **结合律失效**：由于舍入误差，$(A+B)+C$ 可能不等于 $A+(B+C)$。这使得编译器难以优化浮点代码。

---

## 五、总结

*   **浮点数**是计算机为了模拟连续实数而做出的妥协。
*   它通过**S-E-M**结构，在有限的32/64位状态空间中，实现了极大的动态范围。
*   代价是**精度不均匀**（数值越大，精度越低）和**运算复杂**。
