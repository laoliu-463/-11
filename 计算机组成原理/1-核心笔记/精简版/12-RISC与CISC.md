# 12-RISC与CISC：两种函数库设计哲学

> **核心视角**：指令集设计就是设计 CPU 的**API**。
> **CISC (Complex Instruction Set Computer)**：提供**大而全**的函数库，硬件帮你做所有事。
> **RISC (Reduced Instruction Set Computer)**：提供**小而精**的原子操作，复杂功能由软件（编译器）组合实现。
> 最后更新：2025年1月

---

## 一、CISC：硬件保姆 (The Hardware Does It All)

在内存昂贵、编译器弱智的 1970 年代，CISC 的设计目标是**让汇编程序员少写代码**。

*   **特点**：
    *   **指令复杂**：一条指令能干很多事。例如 x86 的 `REP MOVSB` 可以自动拷贝整个字符串。
    *   **变长编码**：指令长度不固定（1~15字节），为了节省每一比特的存储空间。
    *   **访存自由**：几乎所有指令都能直接操作内存操作数（如 `ADD [EAX], 1`）。
*   **代价**：
    *   硬件译码器极其复杂。
    *   指令执行时间差异巨大，难以流水线化。
    *   **80/20 法则**：80% 的时间里，CPU 都在跑那 20% 的简单指令。复杂的指令利用率极低。

## 二、RISC：极简主义 (Keep It Simple, Stupid)

在编译器成熟、内存降价的 1980 年代，RISC 决定**把复杂性甩给编译器**。

*   **特点**：
    *   **指令简单**：每条指令只做一件微小的事。
    *   **定长编码**：所有指令长度固定（如 32位），译码极快。
    *   **Load/Store 架构**：**只有** LOAD 和 STORE 指令能访问内存。运算指令只能操作寄存器。
*   **优势**：
    *   硬件简单，可以腾出晶体管做更大的 Cache 和更多的寄存器。
    *   **流水线极度高效**：因为指令规整，执行时间可预测。
*   **代价**：
    *   代码密度低（程序变大了）。
    *   编译器负担重。

## 三、举例对比：a = a + b

假设 `a` 在内存 `[1000]`，`b` 在内存 `[2000]`。

### CISC (x86)
```assembly
ADD [1000], [2000]  ; 一条指令搞定：读b，读a，相加，写回a
```

### RISC (MIPS/ARM)
```assembly
LW  R1, 2000        ; 1. 把 b 搬到寄存器
LW  R2, 1000        ; 2. 把 a 搬到寄存器
ADD R2, R2, R1      ; 3. 在寄存器中相加
SW  R2, 1000        ; 4. 把结果搬回内存
```

看似 RISC 变慢了（4条指令 vs 1条），但 RISC 的每条指令都极快且能并行执行，最终总时间往往更短。

---

## 四、殊途同归：现代处理器的融合

现在的 CPU 已经不再是纯粹的 CISC 或 RISC：

*   **x86 (CISC 的皮，RISC 的芯)**：
    *   前端译码器将复杂的 x86 指令翻译成微操作 (**uOps**)。
    *   后端执行引擎是一个超标量 RISC 核心，全速执行这些 uOps。
*   **ARM (RISC 的皮，增强的功能)**：
    *   引入了 NEON (SIMD) 等复杂指令来加速特定任务。
    *   指令编码也变得更加紧凑（Thumb-2）。

---

## 五、总结

| 特性 | CISC (x86) | RISC (ARM, RISC-V) | 视角 |
| :--- | :--- | :--- | :--- |
| **指令集** | 复杂，功能强 | 简单，原子化 | **API 设计** |
| **硬件复杂度** | 高 (微码控制) | 低 (硬布线) | **实现成本** |
| **代码密度** | 高 | 低 | **存储效率** |
| **哲学** | 硬件解决困难 | 软件解决困难 | **责任分配** |

理解 RISC vs CISC，就是理解**软硬件界面的权衡 (Trade-off)**。
