# 10-寻址方式：数据定位的算法

> **核心视角**：寻址方式是 CPU 用来计算**操作数有效地址 (Effective Address, EA)** 的算法。它解决了**函数**（指令）如何找到其**参数**（数据状态）的问题。
> 最后更新：2025年1月

---

## 一、寻址的本质：距离与灵活性的权衡

数据可能存在于三个地方：
1.  **指令内部**（最近，最快，但固定）。
2.  **CPU 寄存器**（很近，很快，有限）。
3.  **内存**（较远，较慢，巨大）。

寻址方式就是定义 CPU 如何在这些地方定位数据。

---

## 二、基础寻址：数据在哪里？

### 1. 立即寻址 (Immediate)
*   **算法**：`Data = Instruction_Field`
*   **含义**：数据直接打包在指令里。
*   **场景**：常数赋值。`i = 0`。
*   **特点**：最快，但数据是静态的（编译时确定）。

### 2. 寄存器寻址 (Register)
*   **算法**：`EA = Ri`
*   **含义**：数据在 CPU 的"口袋"（寄存器）里。
*   **场景**：频繁运算的变量。`for (i...)` 中的 `i`。
*   **特点**：非常快，指令短（寄存器号只需几位）。

### 3. 直接寻址 (Direct)
*   **算法**：`EA = Constant_Address`
*   **含义**：数据在内存的固定位置。
*   **场景**：全局变量。`static int count;`
*   **特点**：访问内存，慢。地址固定，不灵活。

### 4. 寄存器间接寻址 (Register Indirect)
*   **算法**：`EA = Mem[Ri]`
*   **含义**：寄存器里存的不是数据，而是数据的**指针**。
*   **场景**：指针访问。`*ptr`。
*   **特点**：极大的灵活性，是实现动态数据结构的基础。

---

## 三、偏移寻址：结构化数据的定位

这组寻址方式的核心思想是：**基准点 + 偏移量**。

### 1. 基址寻址 (Base Addressing)
*   **算法**：`EA = Base_Reg + Offset`
*   **场景**：**重定位**。
    *   程序在内存中移动时，只需要修改**基址寄存器**，指令中的 Offset 不用变。
    *   访问局部变量（`EBP - 4`）。

### 2. 变址寻址 (Indexed Addressing)
*   **算法**：`EA = Base_Addr + Index_Reg`
*   **场景**：**数组访问**。
    *   `Array[i]`：`Array` 是基准地址，`i` 是变址寄存器。
    *   循环中只需要修改 `Index_Reg` 即可遍历数组。

### 3. 相对寻址 (PC-Relative)
*   **算法**：`EA = PC + Offset`
*   **场景**：**跳转指令**。
    *   `if (x) goto L1`。
    *   保持代码的**位置无关性**（Position Independent Code）。无论代码加载到哪里，跳转的目标总是"向下 5 行"。

---

## 四、堆栈寻址：隐式的定位

*   **算法**：`EA = SP` (Stack Pointer)
*   **含义**：地址隐含在堆栈指针中。
*   **场景**：函数调用栈帧、零地址指令运算。
*   **特点**：硬连线的 LIFO 逻辑。

---

## 五、总结

| 寻址方式 | 核心算法 | 数据/函数视角 |
| :--- | :--- | :--- |
| **立即** | Val = Imm | 数据融合在函数中（硬编码）。 |
| **寄存器** | Val = Reg | 数据在 CPU 内部状态中。 |
| **直接** | Addr = Const | 数据在内存固定位置。 |
| **间接** | Addr = *Reg | 数据位置由运行时状态决定（指针）。 |
| **基址/变址** | Addr = Reg+Off | 数据是结构化的（数组、对象、栈帧）。 |

寻址方式越复杂，CPU 计算地址的开销越大，但软件编写越灵活。**RISC** 倾向于简化寻址方式（只保留 Load/Store），而 **CISC** 提供复杂的寻址方式（如直接在内存中做加法）。
