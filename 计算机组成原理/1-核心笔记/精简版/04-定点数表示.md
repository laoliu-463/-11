# 04-定点数表示：简化运算的艺术

> **核心视角**：**补码**不仅仅是一种负数的表示法，它是一种精妙的**数学变换函数**，使得计算机的**加法电路**（Function）可以通用地处理减法，极大地简化了硬件设计。
> 最后更新：2025年1月

---

## 一、进化的动力：让函数更简单

我们在设计数字表示法（State）时，最终目标是让CPU的运算器（Function）设计得越简单越好。

### 1. 原码 (Sign-Magnitude)：人类的直觉
*   **表示**：最高位是符号位（0正1负），其余位是绝对值。
*   **问题**：
    *   **两个零**：`+0` (0000) 和 `-0` (1000)。状态浪费，且比较逻辑复杂。
    *   **函数复杂**：加法器无法直接处理减法。计算 `5 + (-3)` 需要先判断符号，再决定是做加法还是减法。
    *   **结论**：对人类友好，对机器不友好。

### 2. 反码 (One's Complement)：中间产物
*   **表示**：正数不变，负数按位取反。
*   **问题**：依然有两个零。进位处理复杂（循环进位）。

### 3. 补码 (Two's Complement)：最终的解 ⭐
*   **表示**：正数不变，负数 = 反码 + 1。
*   **核心魔法**：**模运算**。
    *   在有限位数的系统中（如8位，模为256），减去一个数 $B$ 等价于加上它的补数 $(M - B)$。
    *   $A - B \equiv A + (-B)_{补} \pmod M$
*   **函数收益**：
    *   **统一加减法**：ALU只需要设计一个**加法器**。减法操作 $A - B$ 被转化为 $A + (-B)_{补}$。
    *   **唯一的零**：`0000 0000`。
    *   **符号位参与运算**：符号位不需要特殊处理，直接当做数值位一起加。

> **通俗类比：时钟模型**
> *   **模 (Modulus)**：时钟的一圈是 12 小时。
> *   **减法变加法**：假设现在是 6 点，你想回到 3 点（做减法 $6 - 3$）。
>     *   **方法一（减法）**：逆时针拨 3 格。
>     *   **方法二（加法）**：顺时针拨 9 格（$12 - 3 = 9$）。
> *   **结果**：$6 + 9 = 15$。因为时钟只能显示 12 个数，所以 $15$ 实际上就是 $3$（$15 \pmod{12} = 3$）。
> *   **结论**：在模 12 的系统里，**减 3** 等价于 **加 9**。补码就是利用这个原理，把减法变成了加法。

---

## 二、移码 (Excess Representation)：为了比较大小

*   **定义**：补码的符号位取反。
*   **用途**：主要用于**浮点数的阶码**。
*   **数据视角**：
    *   补码：`-128` (10000000) 到 `+127` (01111111)。如果不看符号位，二进制数值上 `10000000` 比 `01111111` 大，这与实际大小相反。
    *   移码：`-128` (00000000) 到 `+127` (11111111)。二进制数值的大小顺序与真值的大小顺序**完全一致**。
*   **函数收益**：比较两个浮点数的大小时，可以直接按无符号整数比较阶码，无需处理符号位逻辑。

---

## 三、溢出 (Overflow)：状态容器的破裂

当运算结果超出了寄存器（状态容器）能表示的范围时，就发生了溢出。

### 1. 溢出的本质
**有限的状态空间**无法容纳**无限的数学结果**。

### 2. 检测函数
硬件如何知道发生了溢出？它不需要理解数值的大小，只需要观察**进位信号**。

*   **逻辑**：
    *   **单符号位判别**：两个正数加出负数，或两个负数加出正数。（逻辑：$V = A_s B_s \overline{S_s} + \overline{A_s} \overline{B_s} S_s$）
    *   **双符号位判别**：模4补码。00/11正常，01/10溢出。
    *   **进位判别**：最高位进位 $C_n$ 与次高位进位 $C_{n-1}$ 不一致。（逻辑：$V = C_n \oplus C_{n-1}$）

> **通俗类比：汽车里程表**
> *   假设里程表只有 6 位数（最大 999,999）。
> *   当你开到 999,999 公里时，再开 1 公里，里程表会变成 **000,000**。
> *   **这就是溢出**：真实的里程是 1,000,000，但因为容器（里程表）太小装不下，高位被丢弃了，结果看起来像是“归零”了。

---

## 四、总结

*   **原码**是给人看的。
*   **补码**是给ALU用的，它通过数学变换将减法消解为加法。
*   **移码**是给比较器用的，它保持了二进制的字典序。
*   **溢出**是有限状态机的必然边界。
