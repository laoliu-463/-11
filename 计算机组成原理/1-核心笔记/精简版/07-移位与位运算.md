# 07-移位与位运算

> 逻辑移位、算术移位、循环移位、位操作  
> 最后更新：2025年1月

---

## 📑 目录

- [一、移位运算概述](#一移位运算概述)
- [二、逻辑移位](#二逻辑移位)
- [三、算术移位](#三算术移位)
- [四、循环移位](#四循环移位)
- [五、位操作指令](#五位操作指令)
- [六、总结](#六总结)

---

## 一、移位运算概述

### 什么是移位运算？

**定义：** 移位运算是指将数据的二进制位整体向左或向右移动的运算，包括逻辑移位、算术移位和循环移位三种类型。

**通俗理解：** 移位运算就像"把数字的所有位整体向左或向右移动"，左移相当于乘以2的幂次，右移相当于除以2的幂次。就像把数字的每一位"搬移"位置，移出的位丢弃，空出的位补0或补符号位。

### 三种移位类型

```
┌─────────────────────────────────────────┐
│          移位运算三大类型                │
├─────────────────────────────────────────┤
│  1. 逻辑移位  →  无符号数               │
│  2. 算术移位  →  有符号数  ⭐           │
│  3. 循环移位  →  特殊用途               │
└─────────────────────────────────────────┘

核心公式:
  x << n = x × 2^n   (左移n位 = 乘2^n)
  x >> n = x ÷ 2^n   (右移n位 = 除2^n)
```

### 移位运算的作用

```
主要用途：
  • 快速乘除2的幂次
  • 位操作和掩码
  • 数据打包和解包
  • 加密算法
  • 图形处理

性能优势：
  • 移位比乘除快得多
  • 硬件实现简单
  • 功耗低
```

---

## 二、逻辑移位

### 逻辑左移 (SHL)

**通俗理解：** 所有位左移，右边补0，就像"数字整体向左移动，右边补零"。

```
原理: 所有位左移，右边补0

示例：12 << 1 = 24
  0000 1100  (12)
  ↓ 左移1位
  0001 1000  (24)  = 12 × 2 ✓
  
示例：12 << 2 = 48
  0000 1100  (12)
  ↓ 左移2位
  0011 0000  (48)  = 12 × 4 ✓

规律: x << n = x × 2^n
      5 << 3 = 5 × 8 = 40
```

### 逻辑右移 (SHR)

**通俗理解：** 所有位右移，左边补0，就像"数字整体向右移动，左边补零"。

```
原理: 所有位右移，左边补0

示例：12 >> 1 = 6
  0000 1100  (12)
  ↓ 右移1位
  0000 0110  (6)   = 12 ÷ 2 ✓
  
示例：12 >> 2 = 3
  0000 1100  (12)
  ↓ 右移2位
  0000 0011  (3)   = 12 ÷ 4 ✓

规律: x >> n = ⌊x ÷ 2^n⌋
      13 >> 1 = 6  (13÷2=6.5，向下取整)
```

### 逻辑移位特点

```
适用场景：
  • 无符号数
  • 位操作
  • 数据打包

注意事项：
  • 左移可能溢出
  • 右移可能丢失精度
  • 负数逻辑右移会变成正数（不适合有符号数）
```

---

## 三、算术移位 ⭐⭐⭐

### 算术左移 (SAL)

**通俗理解：** 与逻辑左移相同，低位补0，但要注意溢出。

```
原理: 与逻辑左移相同，低位补0

示例：12 << 1 = 24
  0000 1100  (+12)
  ↓ 算术左移1位
  0001 1000  (+24)  = 12 × 2 ✓

注意事项：
  • 可能溢出
  • 符号位可能改变
```

### 算术右移 (SAR) ⭐ 最重要

**通俗理解：** 高位补符号位，保持符号不变，就像"保持数字的符号，向右移动"。

```
原理: 高位补符号位，保持符号不变

正数示例：
  0000 1100  (+12)
  ↓ 算术右移1位
  0000 0110  (+6)   符号位0扩展 ✓

负数示例：
  1111 1100  (-4)
  ↓ 算术右移1位
  1111 1110  (-2)   符号位1扩展 ✓

特殊情况：-1
  1111 1111  (-1)
  ↓ 算术右移任意位
  1111 1111  (-1)   始终是-1！
```

### 为什么算术右移要补符号位？

```
原因：
  • 保持有符号数的正确性
  • 负数右移后仍是负数
  • 符合数学上的除法运算

对比：
  逻辑右移：1111 1100 (-4) >> 1 = 0111 1110 (126) ✗ 错误！
  算术右移：1111 1100 (-4) >> 1 = 1111 1110 (-2)  ✓ 正确！
```

### 算术移位应用

```
快速乘除：
  • x << 1 = x × 2（左移1位 = 乘2）
  • x >> 1 = x ÷ 2（右移1位 = 除2）
  • x << n = x × 2^n
  • x >> n = x ÷ 2^n

示例：
  10 << 2 = 10 × 4 = 40
  40 >> 2 = 40 ÷ 4 = 10
  比乘除快得多！
```

---

## 四、循环移位

### 循环左移 (ROL)

**通俗理解：** 左移时，移出的位从右边补回来，就像"循环队列"。

```
原理: 左移时，移出的位从右边补回来

示例：1100 循环左移2位
  1100 0000
  ↓ 循环左移2位
  0000 1100

  移出的"11"从右边补回来

应用：
  • 加密算法
  • 数据重排
  • 位操作
```

### 循环右移 (ROR)

**通俗理解：** 右移时，移出的位从左边补回来。

```
原理: 右移时，移出的位从左边补回来

示例：0011 循环右移2位
  0000 0011
  ↓ 循环右移2位
  1100 0000

  移出的"11"从左边补回来
```

### 带进位循环移位

```
带进位循环左移 (RCL)：
  移出的位进入进位标志
  进位标志进入最低位

带进位循环右移 (RCR)：
  移出的位进入进位标志
  进位标志进入最高位

应用：
  • 多精度运算
  • 加密算法
```

---

## 五、位操作指令

### 位操作类型

**通俗理解：** 位操作就像"对每一位单独操作"，可以设置、清除、翻转特定位。

```
主要位操作：
  1. AND（与）：清除位
  2. OR（或）：设置位
  3. XOR（异或）：翻转位
  4. NOT（非）：取反
  5. TEST（测试）：检查位
```

### AND（与）操作

**通俗理解：** 就像"只有两个都是1，结果才是1"，用于清除特定位。

```
规则：
  0 AND 0 = 0
  0 AND 1 = 0
  1 AND 0 = 0
  1 AND 1 = 1

应用：清除特定位
  1011 0110
  AND 1111 0000  (掩码)
  ────────────
  1011 0000  (清除低4位)

示例：清除低4位
  x = x & 0xF0
```

### OR（或）操作

**通俗理解：** 就像"只要有一个是1，结果就是1"，用于设置特定位。

```
规则：
  0 OR 0 = 0
  0 OR 1 = 1
  1 OR 0 = 1
  1 OR 1 = 1

应用：设置特定位
  1011 0000
  OR  0000 1111  (掩码)
  ────────────
  1011 1111  (设置低4位)

示例：设置低4位为1
  x = x | 0x0F
```

### XOR（异或）操作

**通俗理解：** 就像"两个不同才是1，相同是0"，用于翻转特定位。

```
规则：
  0 XOR 0 = 0
  0 XOR 1 = 1
  1 XOR 0 = 1
  1 XOR 1 = 0

应用：翻转特定位
  1011 0110
  XOR 0000 1111  (掩码)
  ────────────
  1011 1001  (翻转低4位)

特殊应用：
  • x XOR x = 0（清零）
  • x XOR 0 = x（不变）
  • 交换两个变量：a = a XOR b; b = a XOR b; a = a XOR b
```

### NOT（非）操作

**通俗理解：** 就像"0变1，1变0"，全部取反。

```
规则：
  NOT 0 = 1
  NOT 1 = 0

示例：
  NOT 1011 0110 = 0100 1001

应用：
  • 取反所有位
  • 生成掩码
```

### 位操作应用示例

```
1. 检查特定位是否为1
   if (x & 0x01) { ... }  // 检查最低位

2. 设置特定位为1
   x = x | 0x08  // 设置第3位

3. 清除特定位为0
   x = x & 0xF7  // 清除第3位（~0x08）

4. 翻转特定位
   x = x ^ 0x08  // 翻转第3位

5. 提取特定位段
   low = x & 0x0F  // 提取低4位
   high = (x >> 4) & 0x0F  // 提取高4位
```

---

## 六、总结

### 核心要点

```
✅ 逻辑移位：无符号数，补0
✅ 算术移位：有符号数，补符号位
✅ 循环移位：移出的位从另一边补回来
✅ 左移 = 乘2的幂次
✅ 右移 = 除2的幂次
✅ 位操作：AND、OR、XOR、NOT
```

### 关键理解

- **逻辑移位**：适用于无符号数，左右都补0
- **算术移位**：适用于有符号数，右移时补符号位
- **循环移位**：移出的位从另一边补回来，不丢失
- **左移**：快速乘以2的幂次
- **右移**：快速除以2的幂次
- **位操作**：可以精确控制每一位

### 性能优势

```
移位 vs 乘除：
  • 移位：1个时钟周期
  • 乘法：多个时钟周期
  • 除法：更多时钟周期

优化建议：
  • 能用移位就用移位
  • x × 8 → x << 3
  • x ÷ 4 → x >> 2
```

### 实际应用

```
常见应用：
  • 快速乘除2的幂次
  • 位掩码操作
  • 数据打包/解包
  • 加密算法
  • 图形处理（像素操作）
  • 网络协议（位字段）
```

---

**最后更新：** 2025年1月

