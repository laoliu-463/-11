# 27-函数与参数：状态传递的协议

> **核心视角**：函数调用是两个独立代码块之间的**协作**。为了协作，它们必须就“如何传递数据（状态）”达成一致。这个协议就是 **ABI (Application Binary Interface)** 中的**调用约定 (Calling Convention)**。
> 最后更新：2025年1月

---

## 一、传递方式：寄存器 vs 内存

参数和返回值本质上是需要从 Caller 传递给 Callee 的**数据状态**。

### 1. 寄存器传递 (Register Passing) —— 贵宾通道
*   **原理**：利用 CPU 内部的高速寄存器传递参数。
*   **优点**：**极快**。无需访问内存。
*   **限制**：寄存器数量有限。
*   **ARM 约定**：`R0`~`R3` 传递前 4 个参数。`R0` 传递返回值。
*   **x86-64 约定**：`RDI`, `RSI`, `RDX`, `RCX`, `R8`, `R9` 传递前 6 个参数。

### 2. 栈传递 (Stack Passing) —— 货运通道
*   **原理**：将参数压入栈（内存）中，Callee 去栈里取。
*   **优点**：容量无限。
*   **缺点**：**慢**。涉及内存读写。
*   **场景**：参数超过寄存器数量时（如第 5 个参数）。

---

## 二、责任划分：谁来打扫战场？

函数调用结束后，栈指针 SP 必须恢复原状。谁负责调整 SP？

1.  **Caller Clean-up**：调用者负责。
    *   例子：C 语言的 `cdecl`。允许可变参数（如 `printf`），因为只有 Caller 知道传了几个参数。
2.  **Callee Clean-up**：被调用者负责。
    *   例子：Windows API 的 `stdcall`。代码更紧凑（RET n 指令），但不支持可变参数。

---

## 三、总结

*   **函数**是软件逻辑的模块，**调用约定**是硬件层面的接口协议。
*   理解参数传递，能让你明白为什么：
    *   参数越少越好（能进寄存器）。
    *   结构体传指针比传值快（避免大规模栈拷贝）。
    *   `printf` 这种变参函数是如何实现的。
