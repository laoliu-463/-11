# 09-指令系统基础

> 指令格式、操作码编码、地址数分类  
> 最后更新：2025年1月

---

## 📑 目录

- [一、什么是指令格式？](#一什么是指令格式)
- [二、按地址数分类](#二按地址数分类)
- [三、操作码编码](#三操作码编码)
- [四、指令格式示例](#四指令格式示例)
- [五、总结](#五总结)

---

## 一、什么是指令格式？

### 定义

**定义：** 指令格式是指令的编码方式，告诉CPU"要做什么"和"在哪里找数据"。不同的格式决定了指令的长短和操作方式。

**通俗理解：** 指令格式就像邮件的格式，告诉CPU"要做什么"和"在哪里找数据"。不同的格式决定了指令的长短和操作方式。

### 指令格式组成

```
指令格式 = 操作码 + 地址码

┌──────────┬──────────┬──────────┬──────────┐
│  操作码  │  地址1   │  地址2   │  地址3   │
│  (OP)    │  (A1)    │  (A2)    │  (A3)    │
└──────────┴──────────┴──────────┴──────────┘

操作码：告诉CPU做什么（ADD、SUB、LOAD等）
地址码：告诉CPU在哪里找数据（寄存器号、内存地址等）
```

---

## 二、按地址数分类

### 分类总览

**通俗理解：** 按地址数分类就像"不同复杂度的命令"，零地址最简单（栈操作），三地址最清晰（三个地址分开）。

```
┌────────┬────────────┬────────┬────────┐
│分类    │格式        │示例    │特点    │
├────────┼────────────┼────────┼────────┤
│零地址  │OP          │ADD     │栈操作  │
│一地址  │OP+A        │ADD 100 │隐含AC  │
│二地址  │OP+D+S      │ADD R1,R2│x86   │
│三地址  │OP+Rd+Rs+Rt │ADD R1,R2,R3│RISC│
└────────┴────────────┴────────┴────────┘
```

### 1. 零地址指令

**通俗理解：** 就像"把栈顶两个数相加"，数据都在栈里，不用写地址。

```
格式: OP

示例: ADD（栈顶两个数相加）
  栈: [5] [3]
  执行ADD后: [8]

特点:
  • 操作数在栈顶
  • 结果也在栈顶
  • 适合栈式计算机
  • 指令短，但需要多条指令

计算C=A+B需要的指令数: 7条
  PUSH A
  PUSH B
  ADD
  POP C
```

### 2. 一地址指令

**通俗理解：** 就像"给这个数加100"，结果存在默认的地方（累加器）。

```
格式: OP + A

示例: ADD 100（累加器 + 100）
  假设AC = 50
  执行ADD 100后: AC = 150

特点:
  • 一个操作数在指令中
  • 另一个操作数在累加器（隐含）
  • 结果存在累加器

计算C=A+B需要的指令数: 3条
  LOAD A    (AC = A)
  ADD B     (AC = A + B)
  STORE C   (C = AC)
```

### 3. 二地址指令

**通俗理解：** 就像"把R2的值加到R1"，R1既是源也是目标。

```
格式: OP + D + S

示例: ADD R1, R2（R1 = R1 + R2）
  R1 = 10, R2 = 5
  执行后: R1 = 15, R2 = 5

特点:
  • 第一个地址是源也是目标
  • 第二个地址是源
  • x86常用

计算C=A+B需要的指令数: 2-3条
  MOV R1, A    (R1 = A)
  ADD R1, B    (R1 = R1 + B)
  MOV C, R1    (C = R1)
```

### 4. 三地址指令

**通俗理解：** 就像"R1 = R2 + R3"，三个地址分开，更清晰。

```
格式: OP + Rd + Rs + Rt

示例: ADD R1, R2, R3（R1 = R2 + R3）
  R2 = 10, R3 = 5
  执行后: R1 = 15, R2 = 10, R3 = 5

特点:
  • 三个地址分开
  • 源地址不变
  • RISC常用

计算C=A+B需要的指令数: 1条（加上LOAD/STORE）
  ADD R1, R2, R3  (假设R2=A, R3=B)
  或
  LOAD R2, A
  LOAD R3, B
  ADD R1, R2, R3
  STORE C, R1
```

### 地址数对比

| 地址数 | 格式 | 指令数（C=A+B） | 优点 | 缺点 |
|--------|------|----------------|------|------|
| **零地址** | OP | 7条 | 指令短 | 指令数多 |
| **一地址** | OP+A | 3条 | 指令中等 | 需要累加器 |
| **二地址** | OP+D+S | 2-3条 | 指令数少 | 源地址被覆盖 |
| **三地址** | OP+Rd+Rs+Rt | 1条 | 最清晰 | 指令较长 |

---

## 三、操作码编码

### 什么是操作码？

**通俗理解：** 操作码就像"动作指令"，告诉CPU做什么操作。比如"加法"的编码是0001，"减法"是0010。

### 三种编码方式

```
1. 定长操作码（RISC）
   所有指令操作码长度相同
   优点: 译码简单，流水线友好
   缺点: 编码空间固定

2. 变长操作码（CISC）
   常用指令短操作码
   优点: 灵活，指令多
   缺点: 译码复杂

3. 扩展操作码 ⭐折中
   用前缀来扩展
   示例(4位OP):
     0000-1110: 15条三地址
     1111 0000-1110: 15条二地址
     1111 1111 0000-1111: 16条零地址
```

### 扩展操作码示例

**示例：4位操作码的扩展**

```
扩展操作码设计：
  三地址指令：0000-1110（15条）
    0000: ADD R1, R2, R3
    0001: SUB R1, R2, R3
    ...
    1110: XOR R1, R2, R3
  
  二地址指令：1111 0000-1110（15条）
    1111 0000: ADD R1, R2
    1111 0001: SUB R1, R2
    ...
    1111 1110: XOR R1, R2
  
  零地址指令：1111 1111 0000-1111（16条）
    1111 1111 0000: ADD（栈操作）
    1111 1111 0001: SUB
    ...
    1111 1111 1111: XOR

总指令数：15 + 15 + 16 = 46条
```

---

## 四、指令格式示例

### MIPS指令格式

```
MIPS三种指令格式：

R型（寄存器型）：
┌──────┬──────┬──────┬──────┬──────┬──────┐
│ OP   │  Rs  │  Rt  │  Rd  │ shamt│ funct│
└──────┴──────┴──────┴──────┴──────┴──────┘
  6位    5位    5位    5位    5位    6位

I型（立即数型）：
┌──────┬──────┬──────┬──────────────────┐
│ OP   │  Rs  │  Rt  │   立即数(16位)    │
└──────┴──────┴──────┴──────────────────┘
  6位    5位    5位        16位

J型（跳转型）：
┌──────┬──────────────────────────────────┐
│ OP   │        目标地址(26位)            │
└──────┴──────────────────────────────────┘
  6位             26位
```

### ARM指令格式

```
ARM指令格式（32位定长）：

┌──────┬──────┬──────┬──────┬──────┬──────┐
│ Cond │  OP  │  S   │  Rn  │  Rd  │其他字段│
└──────┴──────┴──────┴──────┴──────┴──────┘
  4位    4位   1位    4位    4位    15位

Cond: 条件码（条件执行）
OP: 操作码
S: 是否设置标志位
Rn: 源寄存器
Rd: 目的寄存器
```

---

## 五、总结

### 核心要点

```
✅ 指令格式 = 操作码 + 地址码
✅ 按地址数：零地址、一地址、二地址、三地址
✅ 操作码编码：定长、变长、扩展
✅ 扩展操作码：用前缀扩展，平衡指令数和复杂度
✅ 不同架构：MIPS（R型/I型/J型）、ARM（定长32位）
```

### 关键理解

- **指令格式**决定指令如何编码
- **地址数**影响指令数和清晰度
- **操作码编码**影响译码复杂度和指令数量
- **扩展操作码**是折中方案
- **不同架构**有不同的指令格式

### 设计权衡

```
设计权衡：
  • 指令数 vs 指令长度
  • 译码复杂度 vs 灵活性
  • 指令数 vs 地址数
  • 定长 vs 变长
```

---

**最后更新：** 2025年1月










