# 09-指令系统基础：函数的接口定义

> **核心视角**：指令系统 (ISA) 是计算机的**函数库接口**。每一条指令都是一个**基础函数**，定义了函数名（操作码）和参数列表（操作数）。
> 最后更新：2025年1月

---

## 一、指令格式：编码一个函数调用

一条机器指令本质上就是一次**函数调用**。

### 1. 核心组成
*   **操作码 (Opcode)**：**函数名**。告诉 CPU 执行什么操作（如 `ADD`, `LOAD`, `JMP`）。
*   **地址码 (Address)**：**参数列表**。告诉 CPU 操作对象（数据状态）在哪里。

### 2. 编码的艺术：有限位数的博弈
假设我们有 32 位来编码一条指令。我们需要在**函数数量**（操作码位数）和**寻址范围**（地址码位数）之间做权衡。

*   **定长指令 (RISC)**：所有指令长度相同（如32位）。
    *   *优点*：译码电路简单（函数解析快）。
    *   *缺点*：浪费空间（简单指令也要占32位）。
*   **变长指令 (CISC)**：指令长度不一（1-15字节）。
    *   *优点*：紧凑（常用指令短）。
    *   *缺点*：译码复杂（CPU不知道下一条指令从哪里开始，必须先解析当前指令）。

---

## 二、地址数：参数的数量

根据一条指令能携带的参数（地址）数量，可以将指令分类。

### 1. 三地址指令 (3-Address)
*   **格式**：`OP A1, A2, A3`
*   **语义**：`A1 = f(A2, A3)`
*   **代码**：`ADD R1, R2, R3` (R1 = R2 + R3)
*   **特点**：最接近高级语言，清晰明了，但指令最长。

### 2. 二地址指令 (2-Address)
*   **格式**：`OP A1, A2`
*   **语义**：`A1 = f(A1, A2)`
*   **代码**：`ADD EAX, EBX` (EAX += EBX)
*   **特点**：**破坏性更新**。A1 既是源也是目的，原有的 A1 状态被覆盖。x86 架构常用。

### 3. 一地址指令 (1-Address)
*   **格式**：`OP A1`
*   **语义**：`ACC = f(ACC, A1)`
*   **代码**：`ADD 100` (Accumulator += Mem[100])
*   **特点**：隐含了一个参数（累加器 ACC）。早期计算机常用，节省指令空间。

### 4. 零地址指令 (0-Address)
*   **格式**：`OP`
*   **语义**：`Stack[Top-1] = f(Stack[Top-1], Stack[Top])`
*   **代码**：`ADD` (Pop a, Pop b, Push a+b)
*   **特点**：基于**栈**的架构（如 Java 虚拟机）。参数隐含在栈顶。

---

## 三、操作码扩展：在夹缝中生存

如果指令字长固定（如16位），如何既支持三地址指令（需要长地址码），又支持零地址指令（不需要地址码）？

**扩展操作码技术**：
*   **原理**：利用高位操作码的特定值作为"前缀"，将剩余的地址位转换为操作码位。
*   **类比**：电话号码。
    *   `110`：3位号码（短操作码，无参数）。
    *   `138-xxxx-xxxx`：11位号码（长参数）。
    *   系统看到 `1` 开头知道后面还有很多位；看到 `110` 知道这就结束了。

---

## 四、总结

*   **指令**是硬件提供的**原子函数**。
*   **ISA 设计**就是在有限的二进制位宽内，最大化**函数表达能力**（操作码）和**数据访问能力**（地址码）的艺术。
