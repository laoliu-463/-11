# 基础题-01：冒泡排序

## 题目

**问题**：实现冒泡排序算法

**要求**：
1. 实现冒泡排序函数
2. 支持升序和降序排序
3. 优化版本：提前终止

---

## 输入输出

- **输入**：无序数组
- **输出**：排序后的数组

---

## 样例

**输入**：
```
数组：[64, 34, 25, 12, 22, 11, 90]
```

**输出**：
```
排序后：[11, 12, 22, 25, 34, 64, 90]
```

---

## 思路提示

1. **基本思路**：
   - 比较相邻元素，如果顺序错误则交换
   - 每轮将最大（或最小）元素"冒泡"到末尾
   - 重复n-1轮

2. **优化思路**：
   - 如果某一轮没有发生交换，说明已经有序
   - 可以提前终止排序

---

## 时间与空间复杂度

- **时间复杂度**：
  - 最好情况：O(n)（已有序，优化版）
  - 最坏情况：O(n²)
  - 平均情况：O(n²)

- **空间复杂度**：O(1)

---

## 参考答案（可选）

```java
// 基本冒泡排序
public static void bubbleSort(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

// 优化版冒泡排序（提前终止）
public static void bubbleSortOptimized(int[] arr) {
    int n = arr.length;
    for (int i = 0; i < n - 1; i++) {
        boolean swapped = false;  // 标记是否发生交换
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                // 交换
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                swapped = true;
            }
        }
        // 如果这一轮没有交换，说明已经有序
        if (!swapped) {
            break;
        }
    }
}
```

---

**难度**：⭐⭐  
**类型**：基础排序算法



