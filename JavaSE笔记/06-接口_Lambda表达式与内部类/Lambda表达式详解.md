# Lambda 表达式详解：代码的“简写神器”

在 Java 8 之前，如果我们想给一个方法传一段逻辑（比如排序规则），必须写一堆臃肿的“匿名内部类”。**Lambda 表达式**的出现，让我们能像传递数据一样传递代码。

---

## 1. 什么是 Lambda（大白话版）

- **本质**：就是一个“匿名函数”。
- **目的**：简化代码，只关注“干什么”，而不是“怎么写”。
- **比喻**：以前你要雇人（写类、写方法），现在你直接把活儿（逻辑）写在纸上递过去。

---

## 2. 基本语法：三部曲

Lambda 的标准长相：`(参数) -> { 代码块 }`

- **`()`**：参数列表。如果没有参数，就写空括号。
- **`->`**：箭头，固定写法。
- **`{}`**：具体干活的代码。

**超级简写规则：**
1. 参数类型可以不写（编译器会自己猜）。
2. 如果只有一个参数，`()` 也可以不写。
3. 如果代码块只有一行，`{}`、`return`、分号 都可以不写。

---

## 3. 核心前提：函数式接口

并不是所有地方都能用 Lambda。它只能用于**函数式接口**。
- **什么是函数式接口？** 只有一个抽象方法的接口。
- **标志**：通常带有 `@FunctionalInterface` 注解。
- **比喻**：这个萝卜坑只有一个位子，Lambda 往里一跳正好填满。

---

## 4. 常见应用场景

### 4.1 遍历集合 (forEach)
```java
list.forEach(item -> System.out.println(item));
```

### 4.2 排序 (Comparator)
```java
// 以前：要写一堆 compare
// 现在：
list.sort((a, b) -> a - b);
```

### 4.3 开启线程
```java
new Thread(() -> System.out.println("Lambda 启动线程")).start();
```

---

## 5. 进阶武器：方法引用 (Method Reference)

如果你 Lambda 的代码块里只是调用了一个现成的方法，可以进一步简写。
- **写法**：`对象::方法名` 或 `类名::方法名`
- **例子**：
    - `str -> System.out.println(str)`  👉  `System.out::println`
    - `(a, b) -> Math.max(a, b)` 👉 `Math::max`

---

## 6. 面试高频问答（大白话版）

### Q1：Lambda 表达式有什么优缺点？
**答：**
- **优点**：代码极其简洁，开发效率高，配合 Stream API 处理数据非常爽。
- **缺点**：可读性有时变差（如果不熟悉的话），调试（Debug）比普通方法稍微麻烦一点。

### Q2：什么是函数式接口？常见的有哪些？
**答：**
只有一个抽象方法的接口。
Java 内置了四大金刚：
1. `Consumer` (消费型)：给它东西，它只干活不返回。
2. `Supplier` (供给型)：不给它东西，它给你产出。
3. `Function` (函数型)：给它 A，它转成 B 返回。
4. `Predicate` (断言型)：给它东西，它判断对错（返回 true/false）。

### Q3：Lambda 表达式里可以修改外部的局部变量吗？
**答：**
不行。Lambda 引用外部的局部变量，该变量必须是 `final` 的（或者是“隐式 final”，即你后面没改过它）。
**原因**：为了线程安全，防止 Lambda 执行时外部变量已经销毁或被篡改。

---

## 7. 一句话总结

Lambda 表达式让 Java 代码从“又臭又长”变得“短小精悍”，它是你通往函数式编程和 Stream 流的必经之路。
