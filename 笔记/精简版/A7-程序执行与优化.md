# A7 程序执行与优化

> 子程序与函数调用、程序执行过程与性能优化  
> 涵盖原文：26-子程序调用、27-函数与参数、28-程序执行过程，并综合性能优化要点  
> 最后更新：2025年1月

---

## 📑 目录

- [一、子程序调用机制](#一子程序调用机制)
- [二、函数与参数传递](#二函数与参数传递)
- [三、程序执行全过程](#三程序执行全过程)
- [四、性能分析与优化策略](#四性能分析与优化策略)
- [五、检查清单](#五检查清单)

---

## 一、子程序调用机制

### 1. 基本流程
```
调用者 → 保存现场 → 传递参数 → 跳转到被调用者入口
被调用者 → 建立栈帧 → 执行 → 处理返回值 → 恢复现场 → RET
```
- **返回地址**：通过栈或寄存器保存（x86：`CALL` 自动压栈）
- **栈帧结构**（高地址→低地址）：旧BP → 返回地址 → 参数 → 局部变量

### 2. 重入与递归
- **重入**：函数能安全地被中断并再次调用（需无静态数据或采取保护）
- **递归**：利用栈帧实现，每次调用独立的局部变量/参数副本

---

## 二、函数与参数传递

### 1. 传参方式
| 方式 | 特点 | 适用 |
|------|------|------|
| 值传递 | 拷贝实参，形参修改不影响实参 | 简单安全 |
| 引用/地址传递 | 传递地址，形参可影响实参 | 需要修改外部变量 |
| 寄存器传递 | 参数少且调用频繁时使用 | 提高效率 |
| 栈传递 | 参数数量可变，结合调用约定 | 常见于高级语言 |

### 2. 调用约定 (Calling Convention)
- **CDECL**：参数从右到左入栈，调用者清栈
- **STDCALL**：参数从右到左入栈，被调用者清栈
- **FASTCALL**：前几个参数使用寄存器传递
- 考点：栈平衡、返回地址位置、寄存器保存者

---

## 三、程序执行全过程

### 1. 源程序到执行的四阶段
1. **编译**：源代码 → 目标代码（语法分析、优化）
2. **链接**：目标模块、库合并，重定位符号
3. **装载**：装入内存，建立虚实地址映射
4. **运行**：按指令循环执行，可能产生中断、异常

### 2. 运行时内存布局
```
高地址 ┌─────────┐
      │  栈 Stack │ ← 向下增长
      ├─────────┤
      │  堆 Heap  │ ← 向上增长
      ├─────────┤
      │  全局/静态区 |
      ├─────────┤
      │  代码区 Text |
低地址 └─────────┘
```
- 栈/堆冲突 → 栈溢出、内存碎片化
- 链接方式：静态链接、装入时动态链接、运行时动态链接

---

## 四、性能分析与优化策略

### 1. 计算路线
- **执行时间** = 指令数 × CPI × 时钟周期 (或 `指令数 / (主频 × 每秒指令数)`)
- **热点识别**：使用性能剖析工具定位最耗时函数

### 2. 优化手段
| 层次 | 方法 |
|------|------|
| 算法级 | 改进时间复杂度、减少不必要计算 |
| 编译级 | 循环展开、消除冗余、寄存器分配 |
| 架构级 | 利用流水线、减少分支、提高命中率 |
| 系统级 | I/O并行、使用DMA、异步处理 |

---

## 四、高频考题示例

### 例题1：栈帧结构
```
函数调用：caller → callee(a, b)

栈帧布局（高地址→低地址）：
  高地址 ┌─────────────┐
        │ 返回地址    │ ← CALL自动压入
        ├─────────────┤
        │ 参数 b      │ ← 从右到左压入
        ├─────────────┤
        │ 参数 a      │
        ├─────────────┤
        │ 旧BP        │ ← PUSH EBP
        ├─────────────┤
        │ 局部变量    │ ← SUB ESP, size
  低地址 └─────────────┘
```

### 例题2：执行时间计算
```
程序执行：
  • 指令数：500条
  • 平均CPI：1.5
  • 时钟频率：1GHz

求：执行时间

解答：
  执行时间 = 500 × 1.5 / 1GHz = 750ns
```

### 例题3：性能优化
```
原程序：100条指令，CPI=2，时间=100ns
优化后：80条指令，CPI=1.5，时间=?

求：加速比

解答：
  优化后时间 = 80 × 1.5 / 1GHz = 120ns
  加速比 = 100/120 ≈ 0.83（实际变慢！）
  
  原因：指令减少不足以弥补CPI增加
```

---

## 五、检查清单

| 检查项 | ✓ | 说明 |
|--------|---|------|
| 能画出典型栈帧结构 |   | 标明返回地址、基址指针、参数 |
| 理解不同调用约定的栈恢复方式 |   | CALL/RET 与清栈者 |
| 清楚编译→链接→装载→运行四阶段 |   | 每阶段输入输出 |
| 会算执行时间、吞吐率、加速比 |   | 结合 A1 性能公式 |
| 熟悉常见优化策略 |   | 区分软件 vs 硬件优化 |
| 理解栈溢出和内存碎片化 |   | 堆栈冲突的危害 |

---

更多实例请查阅原主题 `26~28` 以及性能优化相关内容。
