# 11-指令分类

> 六大类指令：数据传送、算术、逻辑、移位、控制转移、I/O  
> 最后更新：2025年1月

---

## 📑 目录

- [一、指令分类概述](#一指令分类概述)
- [二、数据传送指令](#二数据传送指令)
- [三、算术运算指令](#三算术运算指令)
- [四、逻辑运算指令](#四逻辑运算指令)
- [五、移位操作指令](#五移位操作指令)
- [六、控制转移指令](#六控制转移指令)
- [七、I/O操作指令](#七io操作指令)
- [八、总结](#八总结)

---

## 一、指令分类概述

### 六大类指令

**通俗理解：** 指令就像程序员的工具箱，分为6大类，每类有不同用途。

```
1. 数据传送 (30-40%) ⭐最多
   MOV, LOAD, STORE, PUSH, POP
   
2. 算术运算 (20-40%)
   ADD, SUB, MUL, DIV, INC, DEC
   
3. 逻辑运算 (10-15%)
   AND, OR, XOR, NOT, TEST
   
4. 移位操作 (5-10%)
   SHL, SHR, ROL, ROR
   
5. 控制转移 (15-20%)
   JMP, CALL, RET, Bxx
   
6. I/O操作 (1-5%)
   IN, OUT, 或内存映射
```

### 指令使用频率

```
程序中的指令分布：
  • 数据传送：30-40%（最多）
  • 算术运算：20-40%
  • 控制转移：15-20%
  • 逻辑运算：10-15%
  • 移位操作：5-10%
  • I/O操作：1-5%（最少）

优化方向：
  • 优化数据传送指令（使用最多）
  • 优化算术运算指令
  • 减少控制转移延迟
```

---

## 二、数据传送指令

### 指令类型

**通俗理解：** 数据传送指令就像"搬运工"，负责把数据从一个地方搬到另一个地方。

```
主要指令：
  • MOV：寄存器间移动
  • LOAD：从内存加载到寄存器
  • STORE：从寄存器存储到内存
  • PUSH：压栈
  • POP：出栈
```

### MOV指令

```
功能: 寄存器间移动数据

格式: MOV 目标, 源

示例:
  MOV R1, R2    // R1 = R2
  MOV R1, #100  // R1 = 100（立即数）

特点:
  • 最快的指令之一
  • 不访问内存
  • 只操作寄存器
```

### LOAD/STORE指令

```
LOAD指令：
  功能: 从内存加载到寄存器
  格式: LOAD 寄存器, [地址]
  示例: LOAD R1, [0x1000]  // R1 = M[0x1000]

STORE指令：
  功能: 从寄存器存储到内存
  格式: STORE [地址], 寄存器
  示例: STORE [0x1000], R1  // M[0x1000] = R1

特点:
  • RISC架构只有LOAD/STORE可以访存
  • 其他指令只能操作寄存器
```

### PUSH/POP指令

```
PUSH指令：
  功能: 压栈（数据入栈）
  格式: PUSH 源
  操作: SP ← SP - 4, M[SP] ← 源

POP指令：
  功能: 出栈（数据出栈）
  格式: POP 目标
  操作: 目标 ← M[SP], SP ← SP + 4

应用:
  • 函数调用（保存寄存器）
  • 参数传递
  • 局部变量
```

---

## 三、算术运算指令

### 基本算术指令

**通俗理解：** 算术运算指令就像"计算器"，执行加减乘除等数学运算。

```
主要指令：
  • ADD：加法
  • SUB：减法
  • MUL：乘法
  • DIV：除法
  • INC：加1
  • DEC：减1
```

### ADD指令

```
功能: 两个数相加

格式: ADD 目标, 源1, 源2

示例:
  ADD R1, R2, R3    // R1 = R2 + R3
  ADD R1, R2, #10   // R1 = R2 + 10（立即数）

特点:
  • 影响标志位（Z、N、C、V）
  • 最常用的算术指令
```

### SUB指令

```
功能: 两个数相减

格式: SUB 目标, 源1, 源2

示例:
  SUB R1, R2, R3    // R1 = R2 - R3
  SUB R1, R2, #5    // R1 = R2 - 5

特点:
  • 影响标志位
  • 可以通过补码转换为加法
```

### MUL/DIV指令

```
MUL指令：
  功能: 两个数相乘
  格式: MUL 目标, 源1, 源2
  特点: 可能需要多个周期

DIV指令：
  功能: 两个数相除
  格式: DIV 目标, 源1, 源2
  特点: 可能需要多个周期，可能产生异常
```

---

## 四、逻辑运算指令

### 基本逻辑指令

**通俗理解：** 逻辑运算指令就像"位操作工具"，对每一位进行逻辑运算。

```
主要指令：
  • AND：按位与
  • OR：按位或
  • XOR：按位异或
  • NOT：按位取反
  • TEST：测试（AND但不保存结果）
```

### AND指令

```
功能: 按位与

格式: AND 目标, 源1, 源2

示例:
  AND R1, R2, R3    // R1 = R2 & R3
  AND R1, R2, #0xF  // R1 = R2 & 0xF（清除高4位）

应用:
  • 清除特定位（掩码操作）
  • 提取特定位段
```

### OR指令

```
功能: 按位或

格式: OR 目标, 源1, 源2

示例:
  OR R1, R2, R3     // R1 = R2 | R3
  OR R1, R2, #0xF0  // R1 = R2 | 0xF0（设置高4位）

应用:
  • 设置特定位
  • 组合位字段
```

### XOR指令

```
功能: 按位异或

格式: XOR 目标, 源1, 源2

示例:
  XOR R1, R2, R3    // R1 = R2 ^ R3
  XOR R1, R1, R1    // R1 = 0（快速清零）

应用:
  • 翻转特定位
  • 快速清零
  • 交换两个变量（不使用临时变量）
```

---

## 五、移位操作指令

### 移位指令类型

**通俗理解：** 移位操作指令就像"移动数字的位"，左移相当于乘2的幂次，右移相当于除2的幂次。

```
主要指令：
  • SHL：逻辑左移
  • SHR：逻辑右移
  • SAL：算术左移
  • SAR：算术右移
  • ROL：循环左移
  • ROR：循环右移
```

### 移位指令应用

```
快速乘除：
  SHL R1, 2    // R1 = R1 × 4（左移2位）
  SHR R1, 3    // R1 = R1 ÷ 8（右移3位）

位操作：
  ROL R1, 1    // 循环左移1位
  ROR R1, 1    // 循环右移1位
```

---

## 六、控制转移指令

### 指令类型

**通俗理解：** 控制转移指令就像"改变程序执行顺序"，可以跳转、调用函数、返回等。

```
主要指令：
  • JMP：无条件跳转
  • CALL：函数调用
  • RET：函数返回
  • Bxx：条件分支（BEQ、BNE、BLT等）
```

### JMP指令

```
功能: 无条件跳转

格式: JMP 目标地址

示例:
  JMP 0x1000    // PC = 0x1000

特点:
  • 改变程序执行顺序
  • PC直接设置为目标地址
```

### CALL/RET指令

```
CALL指令：
  功能: 函数调用
  格式: CALL 函数地址
  操作: 
    SP ← SP - 4
    M[SP] ← PC + 4（保存返回地址）
    PC ← 函数地址

RET指令：
  功能: 函数返回
  格式: RET
  操作:
    PC ← M[SP]
    SP ← SP + 4
```

### 条件分支指令

```
BEQ：相等则跳转
  BEQ R1, R2, target  // if (R1 == R2) PC = target

BNE：不等则跳转
  BNE R1, R2, target  // if (R1 != R2) PC = target

BLT：小于则跳转
  BLT R1, R2, target  // if (R1 < R2) PC = target

BGT：大于则跳转
  BGT R1, R2, target  // if (R1 > R2) PC = target
```

---

## 七、I/O操作指令

### I/O指令类型

**通俗理解：** I/O操作指令就像"与外部设备通信"，输入数据或输出数据。

```
主要方式：
  1. 专用I/O指令（IN/OUT）
  2. 内存映射I/O（通过LOAD/STORE）

专用I/O指令：
  • IN：从I/O端口输入
  • OUT：向I/O端口输出

内存映射I/O：
  • 使用LOAD/STORE指令
  • I/O设备映射到内存地址空间
```

### 内存映射I/O

```
原理：
  I/O设备映射到内存地址空间
  访问特定地址 = 访问I/O设备

示例：
  LOAD R1, [0xFF00]  // 读取键盘（0xFF00是键盘地址）
  STORE [0xFF04], R1 // 写入显示器（0xFF04是显示器地址）

优点：
  • 不需要专用I/O指令
  • 统一的内存访问方式
  • 简化指令集
```

---

## 八、总结

### 核心要点

```
✅ 六大类指令：数据传送、算术、逻辑、移位、控制转移、I/O
✅ 数据传送最多（30-40%）
✅ 算术运算次之（20-40%）
✅ 控制转移第三（15-20%）
✅ 不同指令有不同的用途和特点
```

### 关键理解

- **数据传送**：MOV、LOAD、STORE、PUSH、POP
- **算术运算**：ADD、SUB、MUL、DIV
- **逻辑运算**：AND、OR、XOR、NOT
- **移位操作**：SHL、SHR、SAR、ROL、ROR
- **控制转移**：JMP、CALL、RET、Bxx
- **I/O操作**：IN、OUT或内存映射

### 指令优化

```
优化方向：
  • 优化数据传送指令（使用最多）
  • 提高算术运算速度
  • 减少控制转移延迟
  • 使用内存映射I/O（简化指令集）
```

---

**最后更新：** 2025年1月






