# 05-IEEE浮点数

> IEEE 754浮点数标准、格式、运算、特殊值  
> 最后更新：2025年1月

---

## 📑 目录

- [一、什么是IEEE 754？](#一什么是ieee-754)
- [二、浮点数格式](#二浮点数格式)
- [三、数值分类](#三数值分类)
- [四、浮点运算](#四浮点运算)
- [五、转换示例](#五转换示例)
- [六、总结](#六总结)

---

## 一、什么是IEEE 754？

### 定义

**定义：** IEEE 754是国际电气电子工程师学会制定的浮点数算术标准，定义了浮点数的二进制表示格式、运算规则、舍入方式、异常处理和特殊值表示。

**通俗理解：** IEEE 754就像"浮点数的世界语"，统一了所有计算机如何表示小数。就像度量衡统一后，全世界都能用同样的方式测量，IEEE 754让所有计算机都能用同样的方式处理小数。

### 标准的重要性

```
✓ 统一了浮点数表示
✓ 保证不同平台的兼容性
✓ 定义了精确的运算规则
✓ 提供了特殊值（∞、NaN）
✓ 标准化了舍入模式

制定时间: 1985年
修订版本: 2008年（IEEE 754-2008）
应用范围: 几乎所有现代计算机
```

---

## 二、浮点数格式

### 通用格式

**通俗理解：** 浮点数格式就像"科学计数法"，把一个数分成三部分：符号（正负）、指数（10的几次方）、尾数（有效数字）。例如 123.45 = +1.2345 × 10²，浮点数也用类似方式存储。

```
┌──┬──────────┬────────────────────┐
│S │    E     │         M          │
└──┴──────────┴────────────────────┘
符号位  指数字段    尾数/有效数字

S - 符号位 (Sign bit)
    0 = 正数
    1 = 负数

E - 指数字段 (Exponent)
    使用偏置表示

M - 尾数/有效数字 (Mantissa/Significand)
    规格化数有隐藏位

值 = (-1)^S × 1.M × 2^(E-Bias)
```

### 单精度（32位）

```
┌──┬──────────┬───────────────────────┐
│S │    E     │          M            │
└──┴──────────┴───────────────────────┘
 1    8位         23位

总共: 32位 = 4字节

参数:
  • 偏置值 Bias = 127
  • 指数范围: E ∈ [1, 254]
  • 真实指数: e ∈ [-126, 127]
  • 精度: 约7位十进制数字

表示范围:
  • 最小正规格化: ≈ 1.18×10⁻³⁸
  • 最大正规格化: ≈ 3.40×10³⁸
  • 最小正非规格化: ≈ 1.40×10⁻⁴⁵
```

### 双精度（64位）

```
┌──┬───────────┬──────────────────────────────┐
│S │     E     │             M                │
└──┴───────────┴──────────────────────────────┘
 1    11位              52位

总共: 64位 = 8字节

参数:
  • 偏置值 Bias = 1023
  • 指数范围: E ∈ [1, 2046]
  • 真实指数: e ∈ [-1022, 1023]
  • 精度: 约16位十进制数字

表示范围:
  • 最小正规格化: ≈ 2.23×10⁻³⁰⁸
  • 最大正规格化: ≈ 1.80×10³⁰⁸
  • 最小正非规格化: ≈ 4.94×10⁻³²⁴
```

---

## 三、数值分类

### 分类总览

**通俗理解：** IEEE 754把浮点数分成几类，就像图书馆把书分类：普通数（规格化）、很小的数（非规格化）、特殊数（0、无穷、NaN）。每类有不同的表示方式和用途。

```
┌──────────┬────┬────────┬──────────┬─────────────────┐
│  类型    │ S  │   E    │    M     │  值             │
├──────────┼────┼────────┼──────────┼─────────────────┤
│ +0       │ 0  │   0    │    0     │ 0               │
│ -0       │ 1  │   0    │    0     │ 0               │
│ 非规格化 │ x  │   0    │  非0     │ ±0.M×2^(-126)  │
│ 规格化   │ x  │ 1~254  │   任意   │ ±1.M×2^(e)     │
│ +∞       │ 0  │  255   │    0     │ +∞              │
│ -∞       │ 1  │  255   │    0     │ -∞              │
│ NaN      │ x  │  255   │  非0     │ NaN             │
└──────────┴────┴────────┴──────────┴─────────────────┘

注: 单精度为例，E=255；双精度为E=2047
```

### 1. 规格化数

**条件：** 1 ≤ E ≤ 254 (单精度)

**格式：** (-1)^S × 1.M × 2^(E-Bias)

**特点：**
- 有隐藏位1
- 尾数实际是 1.M
- 这是常规数值

**示例：**
```
0 10000001 01000000000000000000000
S=0, E=129, M=010...
值 = 1.01₂ × 2^(129-127)
   = 1.25 × 2²
   = 5.0
```

**图示：**
```
规格化数结构：
┌──┬──────────┬────────────────────┐
│0 │ 10000001 │ 010000000000000... │
└──┴──────────┴────────────────────┘
正  指数=129   尾数=0.01...
    真实指数=2  隐藏位1 → 1.01
    值 = 1.01 × 2² = 5.0
```

### 2. 非规格化数

**条件：** E = 0, M ≠ 0

**格式：** (-1)^S × 0.M × 2^(-126/-1022)

**特点：**
- 无隐藏位，尾数是 0.M
- 真实指数固定
- 用于表示极小数，填补0附近空白

**通俗理解：** 非规格化数就像"极小的数"，用来表示接近0但又不等于0的数，填补0和最小正数之间的空白。

**示例：**
```
0 00000000 10000000000000000000000
值 = 0.1₂ × 2⁻¹²⁶ ≈ 2⁻¹²⁷
```

### 3. 零

**条件：** E=0, M=0

**特点：**
- ±0: 两种表示，比较时相等
- 1/+0=+∞, 1/-0=-∞

**通俗理解：** 有正零和负零，虽然值相等，但符号不同，某些运算（如1/0）会区分。

### 4. 无穷大

**条件：** E=max, M=0

**产生：** 溢出, 1.0/0.0

**运算：** ∞+x=∞, ∞×x=±∞

**通俗理解：** 无穷大就像"太大了无法表示"，当计算结果超出范围时就用∞表示。

### 5. NaN

**条件：** E=max, M≠0

**类型：** qNaN(静默), sNaN(信号)

**产生：** 0/0, ∞-∞, √(-1)

**运算：** NaN参与→NaN, NaN≠NaN

**通俗理解：** NaN（Not a Number）就像"无效的结果"，当运算没有意义时（如0/0）就返回NaN。NaN不等于任何值，包括它自己。

---

## 四、浮点运算

### 加减法

**通俗理解：** 就像"不同单位的数相加"，先统一单位（对阶），再相加，最后规范化。

```
步骤：
1. 对阶（较小指数对齐）
   • 指数小的尾数右移
   • 指数对齐到较大的值

2. 尾数相加/减
   • 考虑符号位

3. 规格化、舍入
   • 调整到标准格式

示例：5.0 + 2.5
  5.0 = 1.01₂ × 2²
  2.5 = 1.01₂ × 2¹
  
  对阶：2.5 → 0.101₂ × 2²
  相加：1.01 + 0.101 = 1.111₂ × 2² = 7.5
```

### 乘法

**通俗理解：** 符号同号为正、异号为负；指数相加；尾数相乘。

```
步骤：
1. 符号: S₁ XOR S₂
2. 指数: e₁ + e₂
3. 尾数: M₁ × M₂
4. 规格化、舍入

示例：5.0 × 2.0
  5.0 = 1.01₂ × 2²
  2.0 = 1.0₂ × 2¹
  
  符号: 0 XOR 0 = 0 (正)
  指数: 2 + 1 = 3
  尾数: 1.01 × 1.0 = 1.01
  
  结果: 1.01₂ × 2³ = 10.0
```

### 除法

**通俗理解：** 类似乘法，但指数相减，尾数相除。

```
步骤：
1. 符号: S₁ XOR S₂
2. 指数: e₁ - e₂
3. 尾数: M₁ ÷ M₂
4. 规格化、舍入

示例：10.0 ÷ 2.0
  10.0 = 1.01₂ × 2³
  2.0 = 1.0₂ × 2¹
  
  符号: 0 XOR 0 = 0 (正)
  指数: 3 - 1 = 2
  尾数: 1.01 ÷ 1.0 = 1.01
  
  结果: 1.01₂ × 2² = 5.0
```

### 特殊运算规则

```
∞+∞=∞, ∞-∞=NaN, ∞×0=NaN, ∞/x=∞, x/∞=0
NaN传播: 任何涉及NaN的运算→NaN
零运算: 0/0=NaN, x/0=±∞(x≠0)
```

---

## 五、转换示例

### 十进制 → IEEE 754

**示例1：12.5**

```
步骤：
1. 转换为二进制：12.5 = 1100.1₂
2. 规格化：1100.1₂ = 1.1001₂ × 2³
3. 提取各部分：
   S = 0 (正数)
   E = 3 + 127 = 130 = 10000010₂
   M = 1001... (去掉隐藏的1)
4. 组合：0 10000010 10010000000000000000000
```

**示例2：-0.375**

```
步骤：
1. 转换为二进制：0.375 = 0.011₂
2. 规格化：0.011₂ = 1.1₂ × 2⁻²
3. 提取各部分：
   S = 1 (负数)
   E = -2 + 127 = 125 = 01111101₂
   M = 10000... (去掉隐藏的1)
4. 组合：1 01111101 10000000000000000000000
```

### IEEE 754 → 十进制

**示例1：0x40A00000**

```
解析：
S = 0
E = 10000010₂ = 130
M = 01000000000000000000000

真实指数 = 130 - 127 = 3
尾数 = 1.01₂ = 1.25
值 = 1.25 × 2³ = 10.0
```

**示例2：0xFF800000**

```
解析：
S = 1
E = 11111111₂ = 255
M = 00000000000000000000000

判断: E=255, M=0 → -∞
```

---

## 六、总结

### 核心要点

```
✅ IEEE 754是统一的浮点数标准
✅ 格式: S-E-M 三段式
✅ 单精度: 1-8-23 (32位), Bias=127
✅ 双精度: 1-11-52 (64位), Bias=1023
✅ 规格化使用隐藏位1.M
✅ 特殊值: ±0, ±∞, NaN
✅ 浮点运算有误差，需注意精度
```

### 关键理解

- **IEEE 754**统一了浮点数表示，保证跨平台兼容
- **规格化数**使用隐藏位1，提升精度
- **非规格化数**填补0附近的空白
- **特殊值**处理边界情况（0、∞、NaN）
- **浮点运算**有误差，不能直接用==比较

### 常见问题

**Q: 为什么 0.1 + 0.2 ≠ 0.3？**
A: 0.1和0.2在二进制中是无限循环小数，存储时被舍入，产生误差。

**Q: 浮点数能精确比较吗？**
A: 不应该用 == 比较，应使用: |a - b| < ε

**Q: 为什么有 +0 和 -0？**
A: 符号位独立存储，某些运算需要区分（如 1/±0）

**Q: NaN == NaN 为什么是 false？**
A: IEEE 754标准规定，NaN 不等于任何值（包括自己）

---

**最后更新：** 2025年1月


