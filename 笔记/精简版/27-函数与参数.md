# 27-函数与参数

> 函数调用机制、参数传递方式、栈传递参数  
> 最后更新：2025年1月

---

## 📑 目录

- [一、函数调用机制](#一函数调用机制)
- [二、参数传递方式](#二参数传递方式)
- [三、栈传递参数](#三栈传递参数)
- [四、返回值处理](#四返回值处理)
- [五、总结](#五总结)

---

## 一、函数调用机制

### 函数调用过程

**通俗理解：** 函数调用就像"临时离开去办事"，保存当前位置，去执行函数，执行完后回来继续。

```
函数调用完整过程：

调用前：
  1. 准备参数（寄存器或栈）
  2. 保存返回地址
  3. 跳转到函数入口

函数内：
  1. 保存现场（寄存器）
  2. 设置栈帧
  3. 执行函数体
  4. 准备返回值

返回时：
  1. 恢复现场（寄存器）
  2. 恢复栈帧
  3. 返回主程序
```

---

## 二、参数传递方式

### 三种传递方式

**通俗理解：** 参数传递就像"传递信息"，可以通过寄存器、栈、或两者结合传递。

```
1. 寄存器传递
   • 优点：快
   • 缺点：寄存器有限
   • 应用：少量参数

2. 栈传递
   • 优点：灵活，参数数量不限
   • 缺点：较慢
   • 应用：大量参数

3. 混合传递 ⭐常用
   • 前几个参数用寄存器
   • 其余参数用栈
   • 平衡速度和灵活性
```

### ARM调用约定

```
ARM调用约定（AAPCS）：
  • 前4个参数：R0-R3
  • 第5个及以后：栈传递
  • 返回值：R0（或R0-R3，如果返回值大）
  • 调用者保存：R0-R3, R12, LR
  • 被调用者保存：R4-R11, SP

示例：
  int add(int a, int b, int c, int d, int e);
  
  参数传递：
    a → R0
    b → R1
    c → R2
    d → R3
    e → 栈（M[SP]）
```

---

## 三、栈传递参数

### 栈传递规则

**通俗理解：** 栈传递参数就像"把东西放在桌子上"，参数按顺序压栈，函数从栈中读取。

```
栈传递规则：
  • 参数从右到左压栈（C语言约定）
  • 或从左到右压栈（Pascal约定）
  • 调用者负责清理栈

示例（C语言，从右到左）：
  add(5, 3, 2)
  
  压栈顺序：
    SP ← SP - 4
    M[SP] ← 2（参数3）
    SP ← SP - 4
    M[SP] ← 3（参数2）
    SP ← SP - 4
    M[SP] ← 5（参数1）
  
  函数内读取：
    a = M[SP + 8]（参数1）
    b = M[SP + 4]（参数2）
    c = M[SP]（参数3）
```

---

## 四、返回值处理

### 返回值传递

**通俗理解：** 返回值就像"带回结果"，通常通过寄存器返回，大返回值可能通过栈返回。

```
返回值传递：
  • 小返回值（≤32位）：R0
  • 中等返回值（64位）：R0-R1
  • 大返回值（>64位）：通过栈返回

示例：
  int add(int a, int b) {
      return a + b;
  }
  
  返回值在R0：
    R0 ← a + b
    RET
```

---

## 五、总结

### 核心要点

```
✅ 函数调用：保存返回地址，跳转，执行，返回
✅ 参数传递：寄存器（快）、栈（灵活）、混合（常用）
✅ ARM约定：前4个参数R0-R3，返回值R0
✅ 栈传递：从右到左压栈（C语言）
✅ 返回值：小值用寄存器，大值用栈
```

### 关键理解

- **函数调用**：保存返回地址，跳转，执行，返回
- **参数传递**：寄存器传递快，栈传递灵活，混合传递常用
- **ARM约定**：前4个参数用R0-R3，返回值用R0
- **栈传递**：从右到左压栈（C语言约定）
- **返回值**：小值用寄存器，大值用栈

---

**最后更新：** 2025年1月









