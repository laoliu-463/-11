# Ch02 数据表示与运算

> 覆盖 30 篇详细笔记中的主题：02 数据组织与表示、03 数制与编码、04 定点数表示、05 IEEE 浮点数、06 二进制运算、07 移位与位运算、08 舍入与误差  
> 最后更新：2025 年 1 月

---

## 📚 章节结构与映射

| 本章分节 | 对应原主题 | 关键问题 |
|----------|-------------|-----------|
| 1. 数据单位与存储布局 | 02 | 字节编址、端序、内存对齐如何影响数据访问？ |
| 2. 数制与编码体系 | 03 | 二/十/十六进制如何互转？BCD、ASCII、Unicode 各自特点？ |
| 3. 定点数表示（原码/补码/移码） | 04 | 各编码的取值范围、转换与溢出判断？ |
| 4. 浮点数与 IEEE754 | 05 | 阶码偏置、规格化/非规格化、特殊值如何理解？ |
| 5. 二进制运算与移位技巧 | 06/07 | 补码加减、乘除、移位/位操作的常考算法？ |
| 6. 舍入模式与误差控制 | 08 | 四种舍入模式、误差来源及规避策略？ |
| 7. 速查表与自测清单 | 02~08 | 高频公式与自检步骤。 |

---

## 1. 数据单位与存储布局（主题 02）

### 1.1 基本单位
| 名称 | 含义 | 备注 |
|------|------|------|
| bit | 最小信息单元 (0/1) | 与逻辑/传输相关 |
| byte | 8 bit | 字节编址的基础 |
| word | 若干字节（32 位系统常为 4 字节） | CPU 一次处理的自然宽度 |

### 1.2 字节编址与端序
- **大端 (Big-Endian)**：高位字节放低地址 → 网络字节序标准。
- **小端 (Little-Endian)**：低位字节放低地址 → x86/ARM 默认。
- 计算题常要求给出某个数在不同端序下的内存布局，牢记“地址 + 偏移”思路。

### 1.3 内存对齐
- 对齐规则：`char` 任意、`short` 对齐 2、`int` 对齐 4、`long/double` 对齐 8。
- 目的：减少总线访问次数、避免某些架构的对齐异常。
- 结构体填充题：从高到低记录字段大小并按最大对齐方式填充。

---

## 2. 数制与编码体系（主题 03）

### 2.1 进制转换技巧
```
十进制 → 二进制：除 2 取余，逆序排列
二进制 → 十进制：位权求和
二进制 ↔ 十六进制：四位一组直接映射
```
- **常考**：带符号二进制转换、十六进制表示的补码数。

### 2.2 BCD / ASCII / Unicode
- **BCD**：4 bit 表示一位十进制，适合金融/显示但浪费空间。
- **ASCII**：7 bit（0~127），`'0'=48`、`'A'=65`、`'a'=97`，题目常问字符与数值转换。
- **Unicode / UTF-8**：变长编码（1~4 字节），兼容 ASCII，中文等多字节字符会出现 `E4 B8 AD` 这类编码。

---

## 3. 定点数表示（主题 04）

| 编码 | 表示方法 | 取值范围 | 运算特性 |
|------|-----------|-----------|-----------|
| 原码 | 最高位符号，其余为绝对值 | `[-(2^{n-1}-1), 2^{n-1}-1]` | 符号位需单独处理 |
| 反码 | 正数同原码，负数按位取反 | 同原码 | 加减仍需末位 +1 |
| 补码 | 正数同原码，负数 = 反码 + 1 | `[-2^{n-1}, 2^{n-1}-1]` | **统一加法器**，硬件友好 |
| 移码 | 补码符号位取反 | 浮点阶码使用 | 易比较大小 |

- **补码转换口诀**：负数补码 = 原码除符号位取反 + 1；补码转原码反之。
- **溢出判断**：符号位进位 ≠ 次高位进位；或“同符号相加结果异号”。

---

## 4. 浮点数与 IEEE 754（主题 05）

### 4.1 单精度结构
```
| 符号 1 bit | 阶码 8 bit (偏置 127) | 尾数 23 bit (隐含 1) |
值 = (-1)^s × 1.f × 2^{E-127}
```
- 阶码全 0 → 非规格化数/0；阶码全 1 → ±∞ 或 NaN。
- 同理，双精度偏置 1023，尾数 52 bit。

### 4.2 常考问题
1. **规格化判断**：阶码 ≠ 0 且 ≠ 全 1。
2. **非规格化数**：阶码 0，隐含 1 变为 0.f，提高零附近精度。
3. **舍入**：默认“就近舍入，等距取偶”。
4. **特殊值**：`E=255, f=0` → ±∞；`E=255, f≠0` → NaN。

---

## 5. 二进制运算与移位技巧（主题 06 & 07）

### 5.1 补码加减流程
```
若计算 A - B ⇒ A + (B 的补码)
按位相加保留 n 位
检测溢出（符号位进位 ⊕ 次高位进位）
```

### 5.2 乘除法
- 乘法：移位相加（串行）、Booth 算法可处理负数并减少加法次数。
- 除法：恢复余数 vs 不恢复余数，对应硬件实现不同。

### 5.3 移位/位操作
| 操作 | 规则 | 典型用途 |
|------|------|----------|
| 逻辑左移 (SHL) | 末位补 0 | ×2^k |
| 算术右移 (SAR) | 保留符号位 | /2^k（向下取整） |
| 循环移位 (ROL/ROR) | 末位回到首位 | CRC、加密 |
| 位运算 | `&` 清零、`|` 置位、`^` 取异或、`~` 取反 | 位掩码、奇偶判断 |

---

## 6. 舍入模式与误差控制（主题 08）

| 模式 | 规则 | 示例（2.5） | 适用场景 |
|------|------|-------------|-----------|
| 就近舍入（默认） | 最接近，等距取偶 | 2 | IEEE754，避免偏差 |
| 向零舍入 | 直接截断 | 2 | 整数除法 |
| 向上舍入 | 向 +∞ | 3 | 上界估计 |
| 向下舍入 | 向 -∞ | 2 | 下界估计 |

**误差来源**：大数 + 小数（小数被吞）、相近数相减（有效位减少）、多步计算累积误差。  
**控制策略**：使用双精度、重排运算顺序、尽量用整数/分数表示。

---

## 7. 速查表与自测清单

### 7.1 高频速记
- 补码 ↔ 原码转换、浮点阶码偏置、移位与乘除的对应关系。
- 结构体对齐：总长度需是最大对齐数的倍数。
- ASCII/Unicode：牢记常见字符的数值，UTF-8 兼容 ASCII。

### 7.2 自测问题
1. 给出一个 32 位数，分别写出大小端内存布局。
2. 已知补码 `1111 0010`，写出对应十进制数。
3. 给出 IEEE754 二进制串，解析实际值及类别。
4. 解释为何 `0.1 + 0.2 ≠ 0.3`（浮点误差）。
5. 设计一个将数组按 8 字节对齐存储的结构体。

---

**使用提示**：本章内容已直接整合主题 02~08 的核心知识，可配合同目录下的附录/练习（若需要更长示例）使用。
