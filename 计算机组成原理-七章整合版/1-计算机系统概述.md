# 第1章：计算机系统概述

---
[原始文件: 01-计算机体系结构概述.md]

# 01-计算机体系结构概述

> 计算机体系结构基础、冯诺依曼结构、发展历史  
> 最后更新：2025年1月

---

## 📑 目录

- [一、什么是计算机体系结构](#一什么是计算机体系结构)
- [二、体系结构层次](#二体系结构层次)
- [三、冯诺依曼结构](#三冯诺依曼结构)
- [四、计算机发展历史](#四计算机发展历史)
- [五、总结](#五总结)

---

## 一、什么是计算机体系结构？

### 定义

**定义：** 计算机体系结构是计算机系统各级界面的特性，包括指令集、数据类型、I/O机制等程序员可见的属性。

**通俗理解：** 计算机体系结构就像"建筑蓝图"，定义了计算机"做什么"（What），而组成原理定义了"怎么做"（How）。体系结构关注程序员能看到的接口和性能，不关心底层电路如何实现。

### 核心要点

```
体系结构 = 程序员可见的接口
组成原理 = 硬件如何实现

类比：
  体系结构 = 汽车的功能（能跑、能转弯、能刹车）
  组成原理 = 汽车的构造（发动机、变速箱、刹车系统）
```

---

## 二、体系结构层次

### 三层结构

**通俗理解：** 体系结构分为三层，就像"房子的三层结构"：顶层是用户看到的（ISA），中层是建筑结构（微体系结构），底层是建筑材料（物理实现）。

```
┌─────────────────────────────────────┐
│   指令集架构 (ISA)                   │  ← 程序员可见
│   "房子能做什么"                      │
│   • 指令格式                          │
│   • 寄存器                            │
│   • 数据类型                          │
├─────────────────────────────────────┤
│   微体系结构 (Microarchitecture)     │  ← 硬件实现
│   "房子怎么建的"                      │
│   • 流水线                            │
│   • Cache                            │
│   • 分支预测                          │
├─────────────────────────────────────┤
│   物理实现                            │  ← 电路级
│   "用什么材料建的"                    │
│   • 晶体管                            │
│   • 电路设计                          │
│   • 工艺制程                          │
└─────────────────────────────────────┘
```

### 各层特点

| 层次 | 关注点 | 示例 |
|------|--------|------|
| **ISA** | 指令格式、寄存器、数据类型 | ARM指令集、x86指令集 |
| **微体系结构** | 如何实现ISA | 5级流水线、Cache设计 |
| **物理实现** | 电路、工艺 | 7nm工艺、CMOS技术 |

---

## 三、冯诺依曼结构

### 什么是冯诺依曼结构？

**定义：** 冯诺依曼结构（存储程序计算机）是指程序和数据都存储在同一个存储器中，CPU按顺序执行指令的计算机结构。

**通俗理解：** 冯诺依曼结构就像"图书馆+阅读室"：程序和数据都放在"图书馆"（存储器）里，CPU在"阅读室"里按顺序读取和执行。

### 五大组成部分

```
┌─────────────────────────────────────────────────┐
│           冯诺依曼结构五大组成部分                │
└─────────────────────────────────────────────────┘

┌──────────┐      ┌──────────┐      ┌──────────┐
│  运算器  │      │  控制器   │      │  存储器   │
│  (ALU)   │◄─────┤   (CU)    │─────►│ (Memory) │
└────┬─────┘      └─────┬─────┘      └────┬─────┘
     │                  │                  │
     └──────────────────┴──────────────────┘
                        │
              ┌─────────┴─────────┐
              │                    │
         ┌────▼────┐         ┌────▼────┐
         │输入设备  │         │输出设备  │
         │(Input)  │         │(Output)│
         └─────────┘         └─────────┘

1. 运算器 (ALU)：执行算术和逻辑运算
2. 控制器 (CU)：控制指令执行流程
3. 存储器 (Memory)：存储程序和数据
4. 输入设备 (Input)：输入数据和程序
5. 输出设备 (Output)：输出结果
```

### 核心特点

**存储程序概念：**
- 程序和数据都存储在存储器中
- 程序可以像数据一样被修改
- CPU按顺序执行指令

**工作流程：**
```
1. 程序加载到存储器
2. CPU从存储器取指令
3. CPU执行指令
4. 结果写回存储器或输出
5. 重复步骤2-4
```

### 改进型哈佛结构

**与冯诺依曼结构的区别：**

| 特性 | 冯诺依曼结构 | 哈佛结构 |
|------|------------|---------|
| **存储器** | 程序和数据共享 | 程序和数据分离 |
| **总线** | 单总线 | 双总线（指令总线+数据总线） |
| **优点** | 结构简单 | 可并行访问，速度快 |
| **应用** | 通用计算机 | 嵌入式系统、DSP |

```
哈佛结构示意图：

┌──────────┐      ┌──────────────┐
│   CPU    │─────►│ 指令存储器    │
│          │      │ (Instruction)│
│          │◄─────┴──────────────┘
│          │
│          │      ┌──────────────┐
│          │─────►│ 数据存储器    │
│          │      │   (Data)      │
└──────────┘◄─────┴──────────────┘
    双总线并行访问
```

---

## 四、计算机发展历史

### 五个发展阶段

**通俗理解：** 计算机发展就像"交通工具的进化"：从马车（电子管）到汽车（晶体管）到高铁（集成电路），越来越快、越来越小、越来越便宜。

```
┌─────────────────────────────────────────────────┐
│          计算机发展五个阶段                       │
└─────────────────────────────────────────────────┘

第一代 (1946-1957) - 电子管时代
  • 特点：体积大、耗电多、速度慢
  • 代表：ENIAC（18000个电子管，30吨）
  • 速度：每秒几千次运算
  • 类比：像"第一辆汽车"，巨大且笨重

第二代 (1958-1964) - 晶体管时代
  • 特点：体积减小、速度提升
  • 代表：IBM 7090
  • 速度：每秒几十万次运算
  • 类比：像"改进的汽车"，更小更快

第三代 (1965-1970) - 集成电路时代
  • 特点：多个晶体管集成在一个芯片上
  • 代表：IBM System/360
  • 速度：每秒百万次运算
  • 类比：像"现代汽车"，集成度高

第四代 (1971至今) - 大规模集成电路时代
  • 特点：微处理器出现，个人计算机普及
  • 代表：Intel 4004（第一个微处理器）
  • 速度：每秒数十亿次运算
  • 类比：像"现代汽车"，功能强大且普及

第五代 (未来) - 超大规模集成电路
  • 特点：量子计算、神经网络芯片
  • 代表：量子计算机、AI芯片
  • 速度：指数级提升
  • 类比：像"未来交通工具"，革命性突破
```

### 关键里程碑

| 年份 | 事件 | 意义 |
|------|------|------|
| **1946** | ENIAC诞生 | 第一台通用电子计算机 |
| **1947** | 晶体管发明 | 开启第二代计算机 |
| **1958** | 集成电路发明 | 开启第三代计算机 |
| **1971** | Intel 4004 | 第一个微处理器 |
| **1981** | IBM PC | 个人计算机普及 |
| **2000s** | 多核处理器 | 并行计算时代 |

---

## 五、总结

### 核心要点

```
✅ 体系结构 = 程序员可见的接口（What）
✅ 组成原理 = 硬件实现方式（How）
✅ 三层结构：ISA → 微体系结构 → 物理实现
✅ 冯诺依曼结构：存储程序、五大组成部分
✅ 发展历史：电子管 → 晶体管 → 集成电路 → 大规模集成电路
```

### 关键理解

- **体系结构**关注"做什么"，**组成原理**关注"怎么做"
- **冯诺依曼结构**是经典结构，程序和数据共享存储器
- **哈佛结构**改进版，程序和数据分离，速度更快
- 计算机发展遵循"更快、更小、更便宜"的规律

---

**最后更新：** 2025年1月

---
[原始文件: 28-程序执行过程.md]

# 28-程序执行过程

> 编译、加载、执行三个阶段  
> 最后更新：2025年1月

---

## 📑 目录

- [一、程序执行全流程](#一程序执行全流程)
- [二、编译阶段](#二编译阶段)
- [三、加载阶段](#三加载阶段)
- [四、执行阶段](#四执行阶段)
- [五、总结](#五总结)

---

## 一、程序执行全流程

### 完整流程

**通俗理解：** 程序执行就像"从写代码到运行程序的完整过程"，包括编译（把高级语言翻译成机器码）、加载（把程序放到内存）、执行（CPU运行指令）三个阶段。

```
程序执行全流程：

源程序 (高级语言)
    ↓
┌───────────────┐
│  预处理器      │ 处理 #include, #define
└───────┬───────┘
    ↓
┌───────────────┐
│  编译器        │ 翻译成汇编语言
└───────┬───────┘
    ↓
┌───────────────┐
│  汇编器        │ 翻译成机器码
└───────┬───────┘
    ↓
目标文件 (.obj/.o)
    ↓
┌───────────────┐
│  链接器        │ 链接库文件，生成可执行文件
└───────┬───────┘
    ↓
可执行文件 (.exe)
    ↓
┌───────────────┐
│  加载器        │ 加载到内存
└───────┬───────┘
    ↓
┌───────────────┐
│  CPU 执行     │ 取指、译码、执行
└───────────────┘
```

### 三个阶段

| 阶段 | 主要工作 | 产物 | 工具 |
|------|---------|------|------|
| **编译时** | 翻译源代码 | 机器码 | 编译器、汇编器、链接器 |
| **加载时** | 加载到内存 | 进程 | 操作系统加载器 |
| **运行时** | 执行指令 | 结果 | CPU |

---

## 二、编译阶段

### 编译过程

**通俗理解：** 编译阶段就像"翻译过程"，把人类能理解的高级语言翻译成CPU能理解的机器码。

```
编译过程：
  1. 预处理：处理宏和头文件
  2. 编译：语法分析、代码生成
  3. 汇编：生成机器码
  4. 链接：合并文件、链接库

示例：
  int a = 5;
  int b = a + 3;
  
  ↓ 编译
  
  MOV R0, #5
  ADD R1, R0, #3
```

---

## 三、加载阶段

### 加载过程

**通俗理解：** 加载阶段就像"准备运行"，操作系统创建进程，把可执行文件加载到内存，设置程序计数器（PC）和栈指针（SP），准备参数和环境变量，然后开始执行。

```
加载过程：
  1. 创建进程
     • 分配进程ID
     • 创建进程控制块 (PCB)
     • 分配虚拟地址空间
  
  2. 加载程序到内存
     • 读取可执行文件头
     • 分配内存空间
     • 加载代码段和数据段
  
  3. 初始化
     • 设置程序计数器 (PC)
     • 设置栈指针 (SP)
     • 准备参数和环境变量
  
  4. 开始执行
     • 跳转到程序入口点
```

### 进程内存布局

```
高地址
┌─────────────┐
│   内核空间   │  操作系统使用
├─────────────┤
│   栈 Stack  │  ← 向下增长
│     ↓       │  局部变量、函数调用
├─────────────┤
│      ⋮      │  未使用空间
├─────────────┤
│   堆 Heap   │  ← 向上增长
│     ↑       │  动态分配 (malloc)
├─────────────┤
│ 未初始化数据 │  BSS段
├─────────────┤
│  初始化数据  │  Data段
├─────────────┤
│  代码段      │  Text段 (程序指令)
└─────────────┘
低地址
```

---

## 四、执行阶段

### 指令执行

**通俗理解：** 执行阶段就像"CPU运行指令"，CPU从内存取指令，译码，执行，循环进行。

```
指令执行循环：
  while (程序未结束) {
    1. 取指：从内存读取指令
    2. 译码：分析指令
    3. 执行：执行操作
    4. 更新PC：指向下一条指令
  }
```

### 执行流程

```
执行流程：
  开始
    ↓
  取指 (IF)
    ↓
  译码 (ID)
    ↓
  执行 (EX)
    ↓
  访存 (MEM，如果需要)
    ↓
  写回 (WB，如果需要)
    ↓
  更新PC
    ↓
  继续下一条指令
```

---

## 五、总结

### 核心要点

```
✅ 三个阶段：编译、加载、执行
✅ 编译：源代码 → 机器码
✅ 加载：可执行文件 → 内存中的进程
✅ 执行：CPU取指、译码、执行
✅ 内存布局：代码段、数据段、堆、栈
```

### 关键理解

- **编译阶段**：把高级语言翻译成机器码
- **加载阶段**：把可执行文件加载到内存，创建进程
- **执行阶段**：CPU循环执行指令（取指、译码、执行）
- **内存布局**：代码段、数据段、堆、栈
- **完整流程**：从源代码到程序运行的完整过程

---

**最后更新：** 2025年1月

---
[原始文件: 29-性能优化.md]

# 29-性能优化

> CPU性能指标、优化方法、性能分析  
> 最后更新：2025年1月

---

## 📑 目录

- [一、性能指标](#一性能指标)
- [二、优化方法](#二优化方法)
- [三、性能分析](#三性能分析)
- [四、总结](#四总结)

---

## 一、性能指标

### 核心性能指标

**通俗理解：** 性能指标就像"衡量标准"，用来评估CPU的性能。

```
核心性能指标：
  1. CPI (Cycles Per Instruction)
     每条指令的平均周期数
     • 理想：1（流水线）
     • 实际：>1（有冒险和停顿）
  
  2. 时钟频率 (Clock Frequency)
     CPU的工作频率
     • 单位：GHz
     • 越高越快（但功耗也越高）
  
  3. 执行时间 (Execution Time)
     程序执行的总时间
     • 执行时间 = 指令数 × CPI × 时钟周期
     • 越小越好
  
  4. MIPS (Million Instructions Per Second)
     每秒百万条指令
     • MIPS = 时钟频率 / CPI
     • 越高越好
```

### 性能公式

```
性能公式：
  执行时间 = 指令数 × CPI × 时钟周期
           = 指令数 × CPI / 时钟频率
  
  MIPS = 时钟频率 / CPI / 10⁶
  
  加速比 = 优化前时间 / 优化后时间
```

---

## 二、优化方法

### CPU优化方法

**通俗理解：** 优化方法就像"提高效率的方法"，可以从多个方面优化。

```
1. 提高时钟频率
   • 使用更快的工艺
   • 优化电路设计
   • 限制：功耗和散热

2. 降低CPI
   • 使用流水线（理想CPI=1）
   • 使用分支预测（减少控制冒险）
   • 使用前递技术（减少数据冒险）
   • 使用多级Cache（减少访存延迟）

3. 减少指令数
   • 使用RISC架构（指令简单）
   • 编译器优化（减少冗余指令）
   • 使用SIMD指令（并行处理）

4. 提高并行度
   • 超标量（同时执行多条指令）
   • 多核（多个CPU核心）
   • 超线程（一个核心多个线程）
```

### 存储系统优化

```
1. 使用多级Cache
   • L1 Cache：最快，容量小
   • L2 Cache：较快，容量中等
   • L3 Cache：较慢，容量大
   • 提高命中率，减少访存延迟

2. 优化Cache性能
   • 增大Cache容量
   • 提高相联度
   • 使用LRU替换算法
   • 优化程序访问模式（提高局部性）

3. 使用虚拟存储
   • 页式管理
   • TLB快表
   • 减少缺页率
```

---

## 三、性能分析

### 性能瓶颈分析

**通俗理解：** 性能瓶颈分析就像"找出慢的地方"，找出限制性能的因素。

```
性能瓶颈：
  1. CPU瓶颈
     • CPI高（流水线停顿多）
     • 分支预测失败
     • 数据冒险多
  
  2. 存储瓶颈
     • Cache命中率低
     • 内存带宽不足
     • 缺页率高
  
  3. I/O瓶颈
     • 磁盘访问慢
     • 网络延迟高
     • DMA效率低
```

### 优化策略

```
优化策略：
  1. 识别瓶颈
     • 使用性能分析工具
     • 测量各部分的执行时间
     • 找出最慢的部分
  
  2. 针对性优化
     • CPU瓶颈 → 优化算法、减少分支
     • 存储瓶颈 → 优化Cache、提高局部性
     • I/O瓶颈 → 使用DMA、优化调度
  
  3. 平衡优化
     • 避免过度优化某一部分
     • 考虑整体性能
     • 权衡性能和成本
```

---

## 四、总结

### 核心要点

```
✅ 性能指标：CPI、时钟频率、执行时间、MIPS
✅ 优化方法：提高频率、降低CPI、减少指令数、提高并行度
✅ 存储优化：多级Cache、提高命中率、优化访问模式
✅ 性能分析：识别瓶颈、针对性优化、平衡优化
✅ 性能公式：执行时间 = 指令数 × CPI × 时钟周期
```

### 关键理解

- **性能指标**：CPI、时钟频率、执行时间、MIPS
- **优化方法**：从多个方面优化（频率、CPI、指令数、并行度）
- **存储优化**：多级Cache、提高命中率、优化访问模式
- **性能分析**：识别瓶颈，针对性优化
- **平衡优化**：考虑整体性能和成本

---

**最后更新：** 2025年1月

---
[原始文件: 30-综合应用.md]

# 30-综合应用

> 计算机组成原理知识综合应用  
> 最后更新：2025年1月

---

## 📑 目录

- [一、知识体系](#一知识体系)
- [二、综合应用场景](#二综合应用场景)
- [三、设计实例](#三设计实例)
- [四、总结](#四总结)

---

## 一、知识体系

### 计算机组成原理知识体系

**通俗理解：** 计算机组成原理知识体系就像"完整的知识地图"，涵盖了从数据表示到系统设计的各个方面。

```
计算机组成原理知识体系：

1. 基础概念
   • 计算机体系结构
   • 数据组织与表示
   • 数制与编码

2. 数据表示与运算
   • 定点数表示（原码、反码、补码）
   • 浮点数表示（IEEE 754）
   • 二进制运算
   • 移位与位运算
   • 舍入与误差

3. 指令系统
   • 指令格式
   • 寻址方式
   • 指令分类
   • RISC vs CISC

4. CPU与控制器
   • CPU结构
   • 指令执行周期
   • 控制器设计
   • 流水线技术
   • 条件执行

5. 存储系统
   • 存储层次结构
   • Cache技术
   • 虚拟存储
   • 辅助存储

6. 总线与I/O
   • 总线系统
   • I/O接口
   • DMA技术
   • 中断系统

7. 程序执行
   • 子程序调用
   • 函数与参数
   • 程序执行过程
```

---

## 二、综合应用场景

### 场景1：指令执行优化

**问题：** 如何提高指令执行速度？

**解决方案：**
```
1. 使用流水线技术
   • 5级流水线：IF → ID → EX → MEM → WB
   • 理想加速比 = 5
   • 实际受冒险影响

2. 解决流水线冒险
   • 结构冒险：哈佛结构（分离指令和数据Cache）
   • 数据冒险：前递技术（Forwarding）
   • 控制冒险：分支预测（Branch Prediction）

3. 优化Cache性能
   • 提高命中率（>95%）
   • 使用多级Cache
   • 优化程序访问模式
```

### 场景2：存储系统设计

**问题：** 如何设计高效的存储系统？

**解决方案：**
```
1. 存储层次结构
   • 寄存器 → L1 Cache → L2 Cache → L3 Cache → 主存 → 磁盘
   • 从快到慢，从贵到便宜，从容量小到容量大

2. Cache设计
   • 映射方式：组相联（平衡性能和复杂度）
   • 替换算法：LRU（最近最少使用）
   • 写策略：写回（性能好）

3. 虚拟存储
   • 页式管理
   • TLB快表（加速地址转换）
   • 页面置换：LRU算法
```

### 场景3：I/O系统优化

**问题：** 如何提高I/O效率？

**解决方案：**
```
1. 使用DMA技术
   • CPU只初始化，不参与传输
   • 提高CPU利用率
   • 适合大数据量传输

2. 中断系统
   • 及时响应I/O事件
   • 中断优先级管理
   • 中断嵌套处理

3. 磁盘调度
   • SCAN算法（电梯算法）
   • 减少寻道时间
   • 提高磁盘利用率
```

---

## 三、设计实例

### 实例：简单CPU设计

**设计要求：** 设计一个支持基本指令的CPU

**设计步骤：**
```
1. 指令系统设计
   • 指令格式：R型、I型、J型
   • 寻址方式：立即数、寄存器、直接
   • 指令类型：ADD、SUB、LOAD、STORE、JMP

2. CPU结构设计
   • 控制器：硬布线或微程序
   • 数据通路：ALU、寄存器、总线
   • 流水线：5级流水线

3. 存储系统设计
   • 指令存储器：分离的指令Cache
   • 数据存储器：数据Cache
   • 主存：DRAM

4. 性能优化
   • 流水线优化
   • Cache优化
   • 分支预测
```

---

## 四、总结

### 核心要点

```
✅ 知识体系：从基础概念到系统设计的完整体系
✅ 综合应用：指令执行、存储系统、I/O系统
✅ 设计实例：CPU设计、系统优化
✅ 性能优化：多方面的优化策略
✅ 平衡设计：性能、成本、功耗的平衡
```

### 关键理解

- **知识体系**：涵盖从数据表示到系统设计的各个方面
- **综合应用**：多个知识点结合解决实际问题
- **设计实例**：从指令系统到CPU结构的完整设计
- **性能优化**：多方面的优化策略
- **平衡设计**：考虑性能、成本、功耗的平衡

### 学习建议

```
学习建议：
  • 理解基本概念（数据表示、指令系统）
  • 掌握设计方法（CPU设计、存储系统设计）
  • 学会性能分析（识别瓶颈、优化策略）
  • 综合应用（多个知识点结合）
  • 实践设计（简单CPU设计、系统优化）
```

---

**最后更新：** 2025年1月

---
[原始文件: A1-计算机系统概述.md]

# A1 计算机系统概述

> 计算机体系结构整体框架与性能视角  
> 涵盖原文：01-计算机体系结构概述、29-性能优化、30-综合应用  
> 最后更新：2025年1月

---

## 📑 目录

- [一、体系结构全景](#一体系结构全景)
- [二、性能指标与优化](#二性能指标与优化)
- [三、综合应用思维](#三综合应用思维)
- [四、快速复习清单](#四快速复习清单)

---

## 一、体系结构全景

### 1. 冯诺依曼 VS 哈佛
- **冯诺依曼结构**：指令和数据共享同一存储空间，控制器依次取指 → *优点*：结构简单；*缺点*：取指/访存冲突
- **哈佛结构**：指令、数据分离（现代CPU多为改进型哈佛） → *优点*：并行取指/访存；*缺点*：结构更复杂

### 2. 体系结构三层模型
```
┌──────────────┐  ISA：指令集架构      ← 程序员可见
│ 应用层       │  汇编指令、寄存器、地址空间
├──────────────┤
│ ISA层        │  程序设计接口、性能指标
├──────────────┤
│ 微体系结构层 │  流水线、乱序执行、预测
└──────────────┘
```
- **ISA**：定义“做什么”——指令格式、寻址方式、数据类型
- **微体系结构**：实现“怎么做”——流水线、缓存、控制逻辑
- **物理实现**：门电路、布局布线

### 3. 408考试视角
- **知识块**：数据/运算、指令系统、CPU、存储、I/O、系统性能
- **命题趋势**：综合题常涉及“完整分析链路”（指令 → CPU执行 → Cache ↔ 主存 → I/O）

---

## 二、性能指标与优化

### 1. 基础指标
| 指标 | 公式 | 说明 |
|------|------|------|
| CPI | `总时钟周期 / 指令数` | 每条指令平均时钟周期 |
| MIPS | `指令数 / 执行时间 / 10^6` | 百万指令吞吐率（受CPI、主频影响） |
| 性能 | `1 / 执行时间` | 性能 ∝ 1/延迟 |

### 2. Amdahl 定律
```
加速比 S = 1 / [(1 - P) + P / N]
```
- `P`：可并行部分比例，`N`：加速因子（处理器数、优化倍率）
- **核心结论**：提升受“串行部分”限制 → 优先优化热点串行段

### 3. 优化方向速览
- **硬件**：提高主频、扩展流水线深度、加大Cache、引入预测
- **编译器**：循环展开、指令调度、寄存器分配
- **软件**：算法改进、数据局部性、并行化
- **系统**：减少I/O瓶颈、优化存储层次、使用DMA

---

## 三、综合应用思维

### 1. 设计题常见套路
1. **需求分析**：吞吐 vs 延迟、功耗 vs 成本、实时性 vs 一致性
2. **体系结构选择**：指令集类型、流水线级数、Cache层次、I/O策略
3. **性能评估**：定量计算（CPI、命中率、带宽），提供优化方案

### 2. 典型综合题框架
```
输入             计算               输出
┌────────┐   ┌──────────┐   ┌────────┐
│ 指令流/数据 │→ │ CPU执行链路 │ →│ I/O设备 │
└────────┘   └──────────┘   └────────┘
   ↑              ↑                ↑
  编译优化       Cache/主存层次     DMA/中断
```
- 当题目给出“访存统计 + Cache命中率”时：先算访存次数，再算有效访问时间
- 当题目涉及“IO与CPU并行”时：关注 DMA / 中断对CPU占用的影响

### 3. 复习建议
- “概念 → 公式 → 应用”三段式速记卡片
- 整理一张“知识地图”：标出数据流、控制流、存储层次的交互

---

## 四、高频考题示例

### 例题1：性能计算
```
某CPU执行程序需要：
  • 指令数：1000条
  • 平均CPI：2
  • 时钟频率：2GHz

求：执行时间和MIPS

解答：
  时钟周期 = 1/2GHz = 0.5ns
  执行时间 = 1000 × 2 × 0.5ns = 1000ns = 1μs
  MIPS = 2GHz / (2 × 10^6) = 1000 MIPS
```

### 例题2：Amdahl定律
```
程序中30%可并行，70%串行
使用4个处理器并行化

求：加速比

解答：
  S = 1 / [(1-0.3) + 0.3/4]
    = 1 / [0.7 + 0.075]
    = 1 / 0.775
    ≈ 1.29倍
```

### 例题3：Cache性能
```
Cache访问时间：1ns，命中率90%
主存访问时间：100ns

求：平均访存时间

解答：
  AMAT = 1 + (1-0.9) × 100 = 1 + 10 = 11ns
  加速比 = 100/11 ≈ 9.1倍
```

---

## 五、快速复习清单

| 检查项 | ✓ | 备注 |
|--------|---|------|
| 记住 ISA 与微体系结构的区别 |   | 面试高频问题 |
| 掌握 CPI / 执行时间 / 性能三者关系 |   | 不同题型的单位要统一 |
| 会用 Amdahl 定律计算并行加速比 |   | 注意小数转换 |
| 能画出典型的存储层次结构 |   | 强化局部性理解 |
| 清楚 DMA、Cache、流水线的互相影响 |   | 综合题关键 |
| 掌握分支预测和流水线冒险 |   | 现代处理器重点 |

---

**温馨提示**：需要细节时回看原主题 `01、29、30` 的完整笔记。
